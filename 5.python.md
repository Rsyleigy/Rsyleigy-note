# 1、Python基础

## 1.1、输入和输出

```python
# 输入的所有内容都是字符串类型
变量 = input('提示词') 
```

-----

- 例子1

```python
name = input('请输入您的姓名：')
print(name)
```

- 例子2

```python
age = input('请输入您的年龄：')
print(age)
```

- 用法：用作停顿

```python
age = input('请输入您的年龄：')
age2 = int(age)
print(age2+1)
print(type(age))
print("hello world")
print("正在抽取一等奖...")
input('回车暂停')
print("正在抽取二等奖...")
print("hello world")
print("hello world")
```

-------

- print 默认情况下，自带了一个换行符 
  - ctrl + 鼠标左键，查看源码

```python
print("hello")
print("world")
```

> print源码

```python
def print(self, *args, sep=' ', end='\n', file=None): # known special case of print
    """
    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
    
    Prints the values to a stream, or to sys.stdout by default.
    Optional keyword arguments:
    file:  a file-like object (stream); defaults to the current sys.stdout.
    sep:   string inserted between values, default a space.
    end:   string appended after the last value, default a newline.
    flush: whether to forcibly flush the stream.
    """
    pass
```

- sep参数 逗号拼接值的时候，默认是以空格拼接

```python
name = input('请输入您的姓名：')
print('您的姓名是：'+name)  # 您的姓名是:小虎
print('您的姓名是:', name) # 您的姓名是: 小虎

# 使用修改sep参数的值来修改拼接符号
print('您的姓名是:', name, sep='') # 您的姓名是:小虎
```

- end 指定输出结尾的方式，默认是\n换行

```python
print("hello",end=',')
print("world")

输出：
hello,world

```



## 1.2、变量

- python其实提供了一种类似于数学里的未知数的表达，将一个值赋值给一个未知数，那这个未知数在python叫做变量

```python
name = '小虎' 
```

- 注意事项：给变量起名字遵循一些原则
  - 由英文大小写组成，数字，下划线组成
  - 不能以数字开头
  - 不能是python中的关键字

```
name12 √
12name × 以数字开头
12_name × 以数字开头
name_12 √
name_12&qwe × 存在除_以外的特殊字符
def = 100 × 是关键字
```

- 给变量起名字的规范

  - 要见名知意 name  
  - 起名字的格式遵循驼峰式或者下划线式

  ```python
  # 驼峰式 给变量起名，首个单词全部小写，从第二个单词开始，首字母大写
  highStudent = '刘畅'
  
  # 下划线式 单词全部小写，由下划线拼接
  high_student = '小虎'
  ```

  - 尽量不要使用拼音，推荐使用英语单词

## 1.3、基本数据类型

### 1.3.1 字符串 str

- 使用单引号将若干个字符括起来的序列，叫做字符串

```python
a1 = '这是一个字符串'
```

- 使用双引号将若干个字符括起来的序列，叫做字符串

```python
a2 = "这是一个字符串"
```

- 使用三个单引号或者三个双引号将若干个字符括起来的序列，叫做字符串

```python
a3 = '''这也是一个字符串'''
a4 = """这也是一个字符串"""

# 可以多行的编写
a5 = '''
春眠不觉晓
处处闻啼鸟
'''

a5 = """
春眠不觉晓
处处闻啼鸟
"""
```

### 1.3.2 整数 int

```python
num1 = 100
```

### 1.3.3 小数 float

```python
num2 = 12.34
```

### 1.3.4 布尔 bool

```
True False
```

## 1.4、类型转换

```python
s1 = '100'
s2 = '100' + 100 # python中不允许字符串直接与数值相加
print(s2)
```

------

- int()

```python
s1 = '100'
s2 = int('100') + 100 
print(s2)
```

- 字符串中符合数值的样式才可以转数值，否则报错

```python
s3 = int('数加') 
```

- str() 转字符串

```python
s4 = str(200)
print(s4)
```

- type() python内置查看元素数据类型的函数

```python
s4 = str(200)
print(s4)
print(type(s4))
```

- bool()    0  0.0   ''  ""  转bool都是False

```python
print(bool(-1))
print(bool(2))
print(bool(0))
print(bool('nihao'))
print(bool("nihao"))
print(bool(''))
print(bool(""))
print(bool(0.0))
print(bool(1.2))
print(bool(-1.2))
```

```python
# 用法
if 0:  # bool(0)
    print("大于")
else:
    print("不大于")
```

## 1.5、注释

> 用于解释说明的文字，不会被程序解释运行的

- 好处
  - 帮助我们理解代码逻辑
  - 帮助我们排错

- 种类

  - 单行注释

  ```python
  # 要注释的文字
  # 这是调用了python输出的语法，将字符串"hello world"输出在控制台中
  print("hello world")
  
  a = 100  # 将数值100赋值给变量a
  ```

  - 多行注释

  ```python
  '''
  这是一个多行注释
  这是一个多行注释
  '''
  
  """
  这是一个多行注释
  这是一个多行注释
  """
  ```

  快捷键：ctrl + /  选中按一次注释，再按一次放开注释

## 1.6、pass

- 主要作用是来维护语法规范的，用于后续学习中的语句结构中，维持语法的完整性

```python
num1 = 10
num2 = 20
if num1>num2:
    pass
else:
    print("num1小于num2")
```

## 1.7、字符串格式化

> 输出的内容是：您的姓名是xxxx, 年龄是xxx, 就读于xxxx, 专业是xxxx。

- format()  适用于所有版本的python，官方推荐的方式

```python
# 原始字符串拼接做法
name = input('请输入您的姓名:')
age = input('请输入您的年龄:')
university = input('请输入您的大学:')
major = input('请输入您的专业:')

text = "您的姓名是"+name+",年龄是"+age+",就读于"+university+",专业是"+major
print(text)
```

-------------------

```python
# 按照索引位置填充
name = input('请输入您的姓名:')
age = input('请输入您的年龄:')
university = input('请输入您的大学:')
major = input('请输入您的专业:')

text = "您的姓名是{0},年龄是{1},就读于{2},专业是{3}".format(name,age,university,major)
print(text)
```

----------------------

```python
# 默认按照顺序填充
name = input('请输入您的姓名:')
age = input('请输入您的年龄:')
university = input('请输入您的大学:')
major = input('请输入您的专业:')

text = "您的姓名是{},年龄是{},就读于{},专业是{}".format(name,age,university,major)
print(text) 
```

----------------------

```python
# 第一种情况的复用
name = input('请输入您的姓名:')
age = input('请输入您的年龄:')
university = input('请输入您的大学:')
major = input('请输入您的专业:')

text = "您的姓名是{0},年龄是{1},就读于{2},专业是{3}, 不好意思没听清，您的专业是{3}".format(name,age,university,major)
print(text)
```

---------------------

```python
# 不用遵循位置，使用变量的方式使用
name = input('请输入您的姓名:')
age = input('请输入您的年龄:')
university = input('请输入您的大学:')
major = input('请输入您的专业:')

text = "您的姓名是{xhz},年龄是{dwd},就读于{wwt},专业是{xh}, 复用{xhz}".format(dwd=name, wwt=age, xhz=university, xh=major)
print(text)
```

- %

```python
name = input('请输入您的姓名:')
age = input('请输入您的年龄:')
university = input('请输入您的大学:')
major = input('请输入您的专业:')

text = "您的姓名是%s,年龄是%s,就读于%s,专业是%s" % (name, age, university, major)
print(text)
```

- f-{}的方式  是python3.6版本才开始出现的方式

```python
name = input('请输入您的姓名:')
age = input('请输入您的年龄:')
university = input('请输入您的大学:')
major = input('请输入您的专业:')

text = f"您的姓名是{name},年龄是{age},就读于{university},专业是{major},{name}"
print(text)
```

# 2、语句结构

## 2.1 选择结构

- if语句

```python
# 格式1：
if 布尔类型结果的值:
	当if中是True的时候执行这里的代码
	
age = input("请输入您的年龄：")
if int(age) > 18:
    print("您成年了！")
```

> 注意事项：
>
> 1、python严格的使用缩进来表示包含关系
>
> 2、if语句中必须要有一个语句体，如果不知道要实现什么，你可以使用pass维护完整性

```python
# 格式2 有两个选择
if 布尔类型结果的值:
	当if中是True的时候执行这里的代码
else:
    当if中是False的时候执行这里的代码

age = input("请输入您的年龄：")
if int(age) > 18:
    print("您成年了！")
else:
    print("您未成年！")
```

```python
# 格式3：多个路径选择
if 布尔类型结果的值:
	当if中是True的时候执行这里的代码
elif 布尔类型结果的值:
    当elif中是True的时候执行这里的代码
...

score = input("请输入您的考试成绩：")
score = int(score)
if 100 >= score >= 90:  # python是允许连续比较的
    print("奖励吃肯德基")
elif 90 > score >= 70:
    print("奖励一套试卷")
elif 70 > score >= 60:
    print("奖励三套试卷")
elif 0 <= score < 60:
    print("棍棒伺候")
else:
    print("输入错误，请在0-100中输入")
```

## 2.2 循环结构

- range知识的使用，可以生成一个范围的序列数据

```python
# 使用1
range(10) # 0,1,2,3,4,5,6,7,8,9

# 使用2，给定一个开始值
range(1,11) # 1,2,3,4,5,6,7,8,9,10

# 使用3，给定一个开始值，还可以给一个步长
range(1,11,2) # 1,3,5,7,9
range(1,11,-1)

for i in range(10, 0, -2): 
    print(i) # 10,8,6,4,2
```



### 2.2.1 for循环

- 格式1

```python
for 变量1,[变量2,..] in 可以遍历的序列:
	使用变量

# 需求：在控制台中输出10次hello world
for i in range(10):
    print("hello world")
    

# 需求：求1-100之和
res = 0
for i in range(1, 101):
    res = res + i
print(f"1-100的和为{res}")
```

- 格式2

```python
for 变量1,[变量2,..] in 可以遍历的序列:
	使用变量
else:
	for循环正常结束的情况下，才会走else
```



### 2.2.2 while循环

- 格式1

```python
while bool类型的值:
	语句体

# 需求：使用while循环输出10次hello world
num = 1
while num <= 10:
    print("hello world")
    num = num + 1
```

- 格式2

```python
while bool类型的值:
	语句体
else:
    while循环正常结束的情况下，才会走else
```

--------------------

- for循环和while的区别
  - for循环主要应用在确定了一个范围内循环  （吃葡萄）
  - 当范围不确定的时候优先使用while循环    （喝水）

## 2.3 控制条件语句

### 2.3.1 continue 跳过当次循环

```python
# 需求：输出1-10，当遇到5的时候，使用一次continue
for i in range(1, 11):
    if i == 5:
        continue
    print(i)
else:
    print("好好学习，天天向上")  # 这里的else会正常执行
    
------------------------------------------------------
# 用while循环改写
num = 1
while num <= 10:
    if num == 5:
        num = num + 1
        continue
    print(num)
    num = num + 1
else:
    print("hello world") # 这里的else会正常执行
```



### 2.3.2 break  终止循环

```python
# 需求：输出1-10，当遇到5的时候，使用一次break
for i in range(1, 11):
    if i == 5:
        break  # 结束整个for循环
    print(i)
else:
    print("今天天气不错")  # 循环中遇到break，这里的else不会执行

print("hello world")  # 正常执行
-------------------------------------------------------------
# 用while循环改写
num = 1
while num <= 10:
    if num == 5:
        num = num + 1
        break
    print(num)
    num = num + 1
else:
    print("hello world") # 循环中遇到break，这里的else不会执行

print("---------------------")
print(num) # 6
```

-----------------

> 小练习

```python
# 计算1~100中奇数的和
sum1 = 0
for i in range(1, 101):
    if i % 2 == 1:
        sum1 = sum1 + i
else:
    print(f"1-100之间的奇数和为：{sum1}")
```

# 3、数据类型详解

## 3.1 字符串 str

> 简单理解就是由若干个字符构成的字符序列，叫做字符串，例如'abc',"abc"，...
>
> 字符串存在一些功能，可以让我们对字符串做操作

- 定义一个字符串

```python
s1 = 'abcdef'
s2 = s1 
print(s2) # 打印的是地址值对应内存中的具体的值
```

- 字符串一旦被定义就不能被改变，指的是内存中的字符串本身不能被改变，变量赋值只是改变地址值

```python
s1 = 'hello'
s1 = 'world'
```

字符串的特点与功能(调用完功能会，会返回一个新的结果字符串)

特点：python中的字符串具有索引的概念

```python
name = 'shujiakeji'
```

##### 独有功能

```python
s1 = 'xiaohu'
s2 = s1.功能()

print(s1) # 'xiaohu'
print(s2) # 调用完功能之后得到的字符串
```

- 转大写 upper()

```python
s1 = 'Hello world'
s2 = s1.upper()
print(s1) # Hello world
print(s2) # HELLO WORLD
```

- 转小写 lower()

```python
s1 = 'HELLO WorlD'
s2 = s1.lower()
print(s1)  # 'HELLO WorlD'
print(s2)  # hello world
```

--------------------------

转大写或小写场景：用户登录

```python
while True:
    name = input('请输入用户名:')
    if name == 'q' or name == 'Q':
        break
    else:
        password = input('请输入密码:')
        # 代码格式化快捷键 ctrl + alt + L
        if name == 'root' and password == '123456':
            print('登录成功！')
            break
        else:
            print('登录失败！')
```

----------------------------------------------------------------

```python
while True:
    name = input('请输入用户名:')  # q Q
    if name.upper() == 'Q':
        break
    else:
        password = input('请输入密码:')
        # 代码格式化快捷键 ctrl + alt + L
        if name == 'root' and password == '123456':
            print('登录成功！')
            break
        else:
            print('登录失败！')
```

----------------------------------

```python
while True:
    name = input('请输入用户名:')  # q Q
    if name.upper() == 'Q':
        break
    password = input('请输入密码:')
    # 代码格式化快捷键 ctrl + alt + L
    if name == 'root' and password == '123456':
        print('登录成功！')
        break
    else:
        print('登录失败！')
```

- 判断字符串内容是否是数字 isdecimal() 

```python
s1 = '100' 
b1 = s1.isdecimal() 
print(b1) # True
```

--------------------

场景：

```python
# 需求: 输入一个整数数字，与100相加之后输出
num1 = input('请输入一个数字:')
if num1.isdecimal():
    num1 = int(num1)+100
    print(num1)
else:
    print("输入格式错误！")
```

- 判断字符串以xxx前缀开头 startswith() 

```python
s1 = '我爱数加科技'
b1 = s1.startswith('爱')
print(b1)
```

- 判断字符串以xxx后缀结尾 endswith()

```python
s1 = '我爱数加科技'
b1 = s1.endswith('爱')
print(b1)
```

- strip()默认用法：去除空格
  str.[strip](https://so.csdn.net/so/search?q=strip&spm=1001.2101.3001.7020)()  ： 去除字符串两边的空格
  str.lstrip() ： 去除字符串左边的空格
  str.rstrip() ： 去除字符串右边的空格

  注：此处的空格包含'\n', '\r',  '\t',  ' '

  ~~~python
  a=' abc de a  1'
  print(a.strip())
  print(a.lstrip())
  print(a.rstrip())
  ~~~
  去除指定字符
  str.strip('do')  ：去除字符串两端指定的字符
  str.lstrip('do') ：用于去除左边指定的字符
  str.rstrip('do') ：用于去除右边指定的字符

  ~~~python
  dodo = "say hello say boy saaayaaas"
  
  # print(dodo.strip('say'))
  print(dodo.strip('yas'))
  # 当传入的参数中加入空格时
  print(dodo.strip('say '))
  print(dodo.lstrip('say'))
  print(dodo.rstrip('say'))
  ~~~

  

##### 公共功能

- 获取长度 len() 如果小括号中传入的是字符串，获取的是字符串的字符个数

```python
name = 'shujiakeji'
len1 = len(name)
print(len1)
```

-------------------------

> 遍历字符串，得到字符串中每个字符

```python
for i in range(len(name)): # 0-9
    print(name[i])
```

- 通过索引获取元素

```python
# 字符串名[索引]
name = 'shujiakeji'
print(name[0]) # s
print(name[9]) # i
print(name[-1]) # i
```

- 切片

```python
info = '我爱数加科技'
print(info[2:4])
print(info[-4:-2])
print(info[::-2])  # 第三个部分代表的是步长，负的就是从后往前
```

in 表示字符串包含某一个小字符串

##### 字符串相关练习

- 写代码实现，用户输入自己的国籍，如果是以中国开头，输出中国人，否则输出外国人

```python
text = input('请输入您的国籍:')
if text.startswith('中国'):
	print('中国人')
else:
	print('外国人')
```

---------

```python
text = input('请输入您的国籍:')
if text[0:2] == '中国':
    print('中国人')
else:
    print('外国人')
```

- 编写程序，将字符串中所有的数加的词，替换成shujia

```python
s1 = '今天我在数加科技学习到了python的语法知识，很开心能在数加学习'
s1 = s1.replace('数加','shujia')
print(s1)
```

- 根据用户输入的文本信息，统计出‘数’这个字的出现次数

```python
# 字符串可以直接使用for循环进行遍历，得到每一个字符
text = input('请输入一段话:')

count = 0
for i in text:
    if i=='数':
        count = count+1
print(f'数这个字出现了{count}次')
```

- 根据用户输入的文本信息（只包含英语字母和数字），将所有的字母和数字单独提取出来

```python
# 21321341221345
# dqwedqwbnbbujbnj
text = input('请输入一段话:') # dqwedqw213bn213412b4buj213b45nj

number_str = ''
zimu_str = ''
for i in text:
    if i.isdecimal():
        number_str = number_str + i
    else:
        zimu_str = zimu_str + i

print(f'分离出数字：{number_str}, 非数字：{zimu_str}')
```

- 判断字符串中是否包含数加，如果包含，表示这个人是数加人  使用in关键字

```python
text = input('输入您的类别：')
if '数加' in text:
    print('是数加人')
else:
    print('非数加人')
```



## 3.2 整数 int

所有的整数，包括负数

## 3.3 小数 float

所有的整数，包括负数

## 3.4 布尔 bool

True, False

## 3.5 列表 list

> 是一个可变的,允许发生重复元素的有序序列，将来我们可以使用列表存储我们自己的元素

```
格式：[元素1,元素2,元素3,...]  每个元素的类型可以是不一样的
举例：[100,12.12,True,[11,22,33],'shujia']
```

#### 列表调用功能的特点：调用完功能后，基本上是在原有的列表中做修改

#### 独有功能

- 增加

  - append  在列表末尾处添加元素

  ```python
  # 定义一个空列表
  list1 = []
  list2 = list() # 使用python内置函数创建空列表
  ```

  ------------------

  ```python
  list1 = []
  list1.append('张三')
  ```

  -----------------------------

  ```python
  # 用户注册
  list1 = []
  while True:
      name = input('输入注册用户名:')
      if name.upper() == 'Q':
          break
      list1.append(name)
  
  print(f"当前注册的用户：{'，'.join(list1)}")
  ```

  - insert 指定索引位置添加元素

  ```python
  list1 = [11, 22, 33, 44, 55]
  print(f'list1插入数据之前：{list1}')  # [11, 22, 33, 44, 55]
  list1.insert(2, 66)
  print(f'list1插入数据之后：{list1}')  # [11, 22, 66, 33, 44, 55]
  ```

- 删除

  - remove() 已知元素值的情况下进行删除

  ```python
  list1 = [11,22,33,44,55,66]
  list1.remove(元素值)#返回删除元素后的列表
  ```

  > 注意：remove() 如果删除一个不存在的元素值，程序会报错

  - pop() 根据索引删除元素

  ```
  ist1 = [11,22,33,44,55,66]
  list1.pop(索引)
  print(list1)
  ```

  > 注意：
  >
  > ​	a. pop() 函数有返回值，返回被删除的元素
  >
  > ​	b. pop() 如果删除没有的索引值，程序也会报错

  - del python中的关键字删除

  ```python
  list1 = [11, 22, 33, 44, 55, 66]
  del list1[索引]
  ```

- 修改 

```python
list1 = [11, 22, 33, 44, 55, 66]
list1[索引] = 新的值
```

- 反转 reverse()

```python
list1.reverse()
print(list1)
```

----------------------------

```python
# 判断一个字符串是否是对称字符串  aba  www   aabb x
list1 = []
s1 = input('请输入一个字符串:')
for i in s1:
    list1.append(i)

# 反转列表
list1.reverse()
s2 = ''
for i in list1:
    s2 = s2 + i

if s1 == s2:
    print('是对称字符串')
else:
    print('不是对称字符串')
```

- sort() 从小到大对列表中的元素进行排序

```python
list1 = [23, 32, 1, 23, 54, 223]
list1.sort()
print(list1) # [1, 23, 23, 32, 54, 223]
```

- copy() 浅拷贝

```python
list1 = [1, 2, 3, 4, 5]
list2 = list1.copy()

print(f'list1: {list1}') # list1: [1, 2, 3, 4, 5]
print(f'list2: {list2}') # list2: [1, 2, 3, 4, 5]

print("-" * 50)
# 修改list1中的某个元素
list1[2] = 6
print(f'list1: {list1}') # list1: [1, 2, 6, 4, 5]
print(f'list2: {list2}') # list2: [1, 2, 3, 4, 5]
```

> list1修改元素不会影响到list2中的元素

![image-20240106153035248](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240106153035248.png)

-------------------

```python
list1 = [1, 2, [11, 22, 33], 4, 5]
list2 = list1.copy()

print(f'list1: {list1}') # list1: [1, 2, [11, 22, 33], 4, 5]
print(f'list2: {list2}') # list2: [1, 2, [11, 22, 33], 4, 5]
print("-" * 50)
# 修改list1里面小列表中的22的值，将其改成88
list1[2][1] = 88
print(f'list1: {list1}') # list1: [1, 2, [11, 88, 33], 4, 5]
print(f'list2: {list2}') # list2: [1, 2, [11, 88, 33], 4, 5]
```

![image-20240106153100002](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240106153100002.png)

- count() 查找指定值出现的次数

```python
list1 = [1,2,3,4,1,1,2,3,1,4]
res1 = list1.count(1)
print(res1)
```

> 浅拷贝（shallow copy）和深拷贝（deep copy）是在处理复杂对象（如嵌套列表、字典等）时经常用到的概念，它们之间的区别在于复制的程度和对原始对象内部子对象的影响。
>
> 1. **浅拷贝：**
>
>    - 浅拷贝创建了一个新对象，然后将原始对象的元素复制到新对象中。但对于原始对象内部的嵌套对象，浅拷贝只复制它们的引用，而不是创建新的嵌套对象。
>    - 对于不可变对象（如数字、字符串、元组等），浅拷贝和深拷贝没有本质区别。
>    - 对于可变对象（如列表、字典等），浅拷贝会复制对象本身，但不会递归复制对象内部的可变子对象。
>
>    示例：
>
>    ```python
>    import copy
>    
>    original_list = [1, [2, 3], 4]
>    shallow_copied_list = copy.copy(original_list)
>    
>    # 修改原始列表的元素
>    original_list[1][0] = 'X'
>    
>    print(original_list)           # [1, ['X', 3], 4]
>    print(shallow_copied_list)     # [1, ['X', 3], 4]
>    ```
>
>    在上面的例子中，修改原始列表的嵌套列表元素同时也影响了浅拷贝后的列表。
>
> 2. **深拷贝：**
>
>    - 深拷贝创建了一个新对象，并递归地复制原始对象及其所有嵌套的子对象。这意味着修改原始对象内部的任何对象都不会影响深拷贝后的对象，它们是完全独立的。
>    - 深拷贝通常比浅拷贝花费更多的时间和空间，因为它需要复制整个对象结构。
>
>    示例：
>
>    ```python
>    import copy
>                      
>    original_list = [1, [2, 3], 4]
>    deep_copied_list = copy.deepcopy(original_list)
>                      
>    # 修改原始列表的元素
>    original_list[1][0] = 'X'
>                      
>    print(original_list)           # [1, ['X', 3], 4]
>    print(deep_copied_list)        # [1, [2, 3], 4]
>    ```
>
>    在上面的例子中，修改原始列表的嵌套列表元素不会影响深拷贝后的列表。
>
> 总体而言，浅拷贝创建了一个新对象，但只复制原始对象及其直接子对象。深拷贝则递归地复制原始对象及其所有嵌套的子对象，使得两者在内部结构上完全独立。选择使用哪种方式取决于对特定情境的需求。







#### 公共功能



- 长度功能

```python
list1 = [11,22,33,44]
len1 = len(list1)
print(len1)
```

------------------------

> 因为是一个序列，可以直接使用for循环进行遍历

```python
for i in list1:
    print(i)
```

- 索引功能

> 列表也是有索引，可以通过索引获取对应位置上的元素
>
> 从左向右，索引从0开始，从右向左，索引从-1开始

```python
list1 = [11,22,33,44]
print(list1[1]) # 22
print(list1[-1]) # 44
print(list1[3]) # 44
print(list1[len(list1)-1]) # 44
```

----------------------

```python
list1 = [100,12.12,True,[11,22,33],'shujia']
print(list1[3][1]) # 22
```

- 切片功能

```python
#        0  1  2  3  4  5  6  7
list1 = [11,22,33,44,55,66,77,88]
#        -8 -7 -6 -5 -4 -3 -2 -1
print(list1[2:5]) # [33,44,55]
print(list1[2::])
print(list1[-6:-3])
print(list1[-3:-6:-1]) # [66, 55, 44]
```

- in  判断元素是否存在于列表中

```python
list1 = [11,22,33,44,55,66,77,88]
if 11 in list1:
	print('yes')
else:
	print('no')
```



## 3.6 元组 tuple

> 是一个可以存储有序且重复元素的序列，但是元组是不可变，意味着不允许增上改
>
> 只能做查询

#### 独有功能

- count()
- index()

#### 公共功能

- 长度功能

```python
tuple1 = (1, 2, 3, 4, 5)
print(tuple1, type(tuple1))
print(len(tuple1))
```

- 索引

```python
tuple1 = (1, 2, 3, 4, 5)
print(tuple1[3]) # 4
```

- 切片

```python
tuple1 = (1, 2, 3, 4, 5)
print(tuple1[2:4]) # (3,4)
```

- in

```python
tuple1 = (1, 2, 3, 4, 5)
if 3 in tuple1:
    print('3存在元组中')
else:
    print('不存在')
```

- for

```python
tuple1 = (1, 2, 3, 4, 5)
for i in tuple1:
    print(i)
```

##### 元组注意事项：

- 创建一个元组

```python
# 写法1：当元组中的元素是大于等于2个的时候，最后一个逗号加不加，区别不大
tuple1 = (1,2,3,4)   # 创建一个元组，里面有4个元素
tuple2 = (1,2,3,4,)  # 创建一个元组，里面有4个元素

# 写法2：如果元组中只有一个元素，这时候再想一个元组的话，必须加上一个英文逗号
a1 = (11)  # 等价于 a1 = 11  11 <class 'int'>
a2 = (11,) # 创建一个元组，里面有1个元素 (11)  (11,) <class 'tuple'>
```

------------------

- 创建空元组

```python
a1 = tuple()
a1 = ()
```

### 

## 3.7 字典 dict

#### 字典的特点:

- 元素是一个键-值对的形式存在，一个键对应一个值
- 键是唯一的
- 值可以发生重复
- 一个字典中可以出现多个键值对，python3.6之前字典中的键是无序的，python3.6之后键默认是有序的

```python
dict1 = {key1:value1,key2:value2}
```

> python中字典里的键和值可以是不一样的数据类型

```python
{'name':'小虎','age':18,'likes':['踢足球','打英雄联盟','学习'],'dog':{'dname':'小黄','age':3}}
```

> 注意：并不是所有的数据类型都可以当作键，只有可哈希的类型才能当作键
>
> 在Python中，可哈希性对于在字典（`dict`）中作为键（key）使用的对象至关重要，因为字典的键必须是可哈希的。以下是一些关于可哈希对象的特性：
>
> 1. **不可变性：** 可哈希的对象必须是不可变的，即对象的内容不能在其生命周期内发生变化。例如，整数、浮点数、元组等是不可变的，因此它们是可哈希的。
> 2. **稳定的哈希值：** 可哈希的对象的哈希值在其生命周期内应该是稳定的，即相同内容的对象应该具有相同的哈希值。
> 3. **唯一性：** 不同内容的对象应该具有不同的哈希值，以确保哈希值的唯一性。

#### 独有功能

- keys() 获取字典中所有的键，组成的一个dict_keys类型

```python
keys = dict1.keys()
# print(keys, type(keys)) # dict_keys(['key1', 'key2', 'key3']) <class 'dict_keys'>
key_list = list(keys)  # ['key1', 'key2', 'key3'] <class 'list'>
```

- get(key) 根据键获取对应的value值

```python
keys = dict1.keys()
# print(keys, type(keys))
key_list = list(keys)
# print(list1, type(list1))
for key in key_list:
    value = dict1.get(key)
    print(f'键:{key}-值:{value}')
```

> 注意，如果一个键不存在时，使用get，程序并不会报错，会返回一个None值

- values 获取所有的值

```python
dict1 = {'key1': 'aaa', 'key2': 'bbb', 'key3': 'ccc'}
# print(dict1.get('key4'))
values = list(dict1.values())
print(values, type(values))
```

- items() 获取所有的键值对

```python
dict1 = {'key1': 'aaa', 'key2': 'bbb', 'key3': 'ccc'}
# print(dict1.get('key4'))
# values = list(dict1.values())
# print(values, type(values))
key_values = list(dict1.items())
# print(key_values, type(key_values))
for i in key_values:
    key = i[0]
    value = i[1]
    print(f'键：{key},值：{value}')
```

- pop 根据键删除一个元素，返回被删除键对应的值

```python
dict1 = {'key1': 'aaa', 'key2': 'bbb', 'key3': 'ccc'}
s = dict1.pop('key2')
print(dict1)
print(s) #这个是被删除的值
```

- clear() 清空字典中所有键值对

#### 公共功能

- 长度 len获取的是字典中键值对的个数

```python
dict1 = {'key1':'aaa','key2':'bbb','key3':'ccc'}
print(len(dict1))
```

- 索引，字典中的索引是键，实际上就是通过键获取值

```python
dict1 = {'key1':'aaa','key2':'bbb','key3':'ccc'}
print(dict1['key1'])
```

- 无切片功能
- in 只能判断键是否存在字典中

```python
dict1 = {'key1': 'aaa', 'key2': 'bbb', 'key3': 'ccc'}
if 'key1' in dict1:
    print("yes")
```

for

- 遍历方式1：先获取所有的键，再根据键获取所有的值

```python
keys = dict1.keys()
# print(keys, type(keys))
key_list = list(keys)
# print(list1, type(list1))
for key in key_list:
    value = dict1.get(key)
    print(f'键:{key}-值:{value}')
```

- 遍历方式2：直接获取所有的键值对，再依次遍历每一个键值对中键和值

```python
dict1 = {'key1': 'aaa', 'key2': 'bbb', 'key3': 'ccc'}
# print(dict1.get('key4'))
# values = list(dict1.values())
# print(values, type(values))
key_values = list(dict1.items())
# print(key_values, type(key_values))
for i in key_values:
    key = i[0]
    value = i[1]
    print(f'键：{key},值：{value}')
```

## 3.8 Set集合

> 是一个无序（指的是存储和取出的顺序不一致）且唯一的序列

```python
# 语句定义格式
set1 = {12,34,11,22,33,44,11,22,33}
print(set1,type(set1))
```

#### 独有功能

- union() 并集

```python
set1 = {11, 22, 33, 44}
set2 = {22, 44, 77, 88}
set3 = set1.union(set2)
print(f'set1:{set1}')
print(f'set2:{set2}')
print(f'set3:{set3}')
```

- difference()  或者 减法-  差集

```python
set1 = {11, 22, 33, 44}
set2 = {22, 44, 77, 88}
# set3 = set1.difference(set2)
set3 = set1 - set2
print(f'set1:{set1}')
print(f'set2:{set2}')
print(f'set3:{set3}')
```

- add() 添加元素到集合中 

```python
set1 = {11,22,33,44}
set1.add(55)
```

- remove() 通过元素的值进行移除 若元素不存在，会报错

```python
set1 = {11, 22, 33, 44}
print(set1)
set1.remove(22)
print(set1)
```

- discard() 移除元素 若元素不存在，不会报错

- pop：根据set集合中的结果按照顺序弹出

```python
set1 = {11, 22, 33, 44, 55, 66, 77, 88, 99, 100, 23, 41, 23, 14, 17, 31}
print(set1)
# print(set1)
# # set1.remove(99)
# set1.discard(22)
# print(set1)
res = set1.pop()
print(res)
print(set1)
res = set1.pop()
print(res)
print(set1)
res = set1.pop()
print(res)
print(set1)
```

![image-20240106171309162](C:/Users/shujia/AppData/Roaming/Typora/typora-user-images/image-20240106171309162.png)

- intersection() 取交集

```python
set1 = {11, 22, 33, 44}
set2 = {22, 44, 77, 88}
set3 = set1.intersection(set2)
print(f'set1:{set1}')
print(f'set2:{set2}')
print(f'set3:{set3}')
```



#### 	公共功能

- 长度

```python
set1 = {12,34,11,22,33,44,11,22,33}
print(set1,type(set1)) # 显示的是去重之后的元素个数
```

- 索引

> 无索引概念

- 切片

> 无切片的概念

- in

```python
set1 = {12, 34, 11, 22, 33, 44, 11, 22, 33}
if 11 in set1:
    print("yes")
```

- for

```python
set1 = {12, 34, 11, 22, 33, 44, 11, 22, 33}
for i in set1:
    print(i)
```

### 作业练习

在控制台中输出99乘法表 （做出之后，想一想能不能使用一行代码生成）

现在有一个元组（1,3,2,4,5,1,2,3,4）,请进行去重，最终得到的也是一个元组

杨辉三角

将列表元素以指定格式输出：list1 = ['华为mate60','iphone15 pro','小米14 pro']

- 输出格式如下

```python
1.华为mate60
2.iphone15 pro
3.小米14 pro
```

### 作业讲解

- 在控制台中输出99乘法表 （做出之后，想一想能不能使用一行代码生成）

```python
# 需求：在控制台中输出5行5列的*
# \t tab键，制表符，默认是4个空白字符
# \n 换行，代表一个回车字符
# for i in range(5):
#     print('*', end='\t')
# print()
#
# for i in range(5):
#     print('*', end='\t')
# print()
#
# for i in range(5):
#     print('*', end='\t')
# print()
#
# for i in range(5):
#     print('*', end='\t')
# print()
#
# for i in range(5):
#     print('*', end='\t')
# print()

# 双重for循环
for j in range(5):  # 外层for循环控制的行数
    for i in range(5):  # 内层for循环控制的列数
        print('*', end='\t')
    print()

print("------------------------------------------------")
# 需求：打印三角形的星型
'''
*                           第1行，共1列
*   *                       第2行，共2列
*   *   *                   第3行，共3列
*   *   *   *               第4行，共4列
*   *   *   *   *           第5行，共5列
...                         第n行，共n列
'''
for i in range(1, 10):
    for j in range(i):
        print('*', end='\t')
    print()

print("=" * 50)
# 输出九九乘法表
for i in range(1, 10):
    for j in range(1, i + 1):
        print(f'{j}*{i}={i * j}', end='\t')
    print()
```

- 现在有一个元组（1,3,2,4,5,1,2,3,4）,请进行去重，最终得到的也是一个元组

```python
# 现在有一个元组（1,3,2,4,5,1,2,3,4）,请进行去重，最终得到的也是一个元组
tuple1 = (1, 3, 2, 4, 5, 1, 2, 3, 4)
# 方式1：
print(tuple1)

set1 = tuple(set(tuple1))
print(set1)

print("=" * 50)
# 方式2：创建一个新的列表，存储元素
list1 = []
# 遍历元组
for i in tuple1:
    # 判断列表中是否存在该元素
    if i not in list1:
        list1.append(i)

tuple1 = tuple(list1)
print(tuple1)
```

- 将列表元素以指定格式输出：list1 = ['华为mate60','iphone15 pro','小米14 pro']

  - 输出格式如下

  ```python
  1.华为mate60
  2.iphone15 pro
  3.小米14 pro
  ```

  ```python
  # enumerate()函数，可以在取元素的同时，将元素的索引一并取出
  list1 = ['华为mate60', 'iphone15 pro', '小米14 pro']
  for index, phone in enumerate(list1):
      print(f'{index + 1}.{phone}')
  ```

- 杨辉三角

```python
list1 = [1]
for i in range(10):
    print(list1)
    list1.append(0)
    list1 = [list1[j] + list1[j - 1] for j in range(i + 2)]
```



# 4、运算符

- 操作数：参与运算的变量或常量
- 操作符：连接变量或常量的符号
- 表达式：由操作数和操作符构成且符合python语法规范的式子

## 4.1、常量

> 指的是在程序运行过程中，其值不能发生改变的量

- 注意：在python中，其实并没有严格的常量说法，只是由一个大写的写法表示这是一个常量

## 4.2、算术运算符

![image-20240108094659503](C:/Users/shujia/AppData/Roaming/Typora/typora-user-images/image-20240108094659503.png)

- +

```python
a1 = 3
b1 = 4
print(a1+b1)
```

- -

```python
a1 = 3
b1 = 4
print(a1-b1)
```

- *

```python
a1 = 3
b1 = 4
print(a1*b1)
```

- /  有小数

```python
a1 = 3
b1 = 4
print(a1/b1)
```

- %  取余数

```python
a1 = 3
b1 = 4
print(a1%b1)
```

- **

```python
a1 = 3
b1 = 4
print(a1**b1)
```

- //  整除

```python
a1 = 3
b1 = 4
print(a1//b1)
```



## 4.3、比较（关系）运算符   

> 结果一定是True或者False

![image-20240108095153725](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240108095153725.png)

- == 比较的是数值
  - 如果比较地址值，使用is关键字
  - id()函数获取地址值进行比较
- !=  
- 大于>
- <
- 大于等于>=
- <=

## 4.4、赋值运算符

![image-20240108104123239](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240108104123239.png)

- = 赋值 将左边的值赋值给右边的变量
- python语言中没有++ --的运算

## 4.5、逻辑运算符

![image-20240108105006702](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240108105006702.png)

- and  有False则False

```python
a1 = 3
b1 = 4
print(a1 > 3 and b1 < 4)  # False and False -> False
print(a1 == 3 and b1 < 4)  # True and False -> False
print(a1 == 3 and b1 == 4)  # True and True -> True
print(a1 > 3 and b1 == 4)  # False and True -> False
```

- or 有True则Ture

```python
a1 = 3
b1 = 4
print(a1 > 3 or b1 < 4)  # False or False -> False
print(a1 == 3 or b1 < 4)  # True or False -> True
print(a1 == 3 or b1 == 4)  # True or True -> True
print(a1 > 3 or b1 == 4)  # False or True -> True
```

- not 取反

```python
print(not a1 > 3)
```

## 4.6、位运算符

![image-20240108105204686](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240108105204686.png)

- **计算机中所有的数据都是采用补码的形式计算的**

###  4.6.1、进制之间的转换

> 二进制，计算机中处理数据，存储的方式，逢2进1，由0，1构成 

- 其他进制到十进制的转换  
  - 规律：系数*进制数（原进制）^n次方之和

```python
# 十进制到十进制
十进制：12345                           十进制：12345
12345 = 10000 + 2000 + 300 + 40 + 5
      = 1*10^4 + 2^10^3 + 3*10^2 + 4*10^1 + 5*10^0
      = 10000 + 2000 + 300 + 40 + 5
      = 12345

# 规律：系数*进制数^n次方之和

二进制： 01010100   十进制：
01010100 = 1*2^6 + 1*2^4 + 1*2^2
         = 64 + 16 + 4
         = 84
```

- 十进制到其他进制的转换
  - 除基（目标进制）取余，直到商为0，余数反转

```
十进制：84         二进制：01010100
84/2 = 42 --- 0
42/2 = 21 --- 0
21/2 = 10 --- 1
10/2 = 5  --- 0
5/2  = 2  --- 1
2/2  = 1  --- 0
1/2  = 0  --- 1
```

- 其他进制之间的转换
  - 利用十进制作为桥梁进行转换
  - 二进制转八进制，十六进制   拆分组合法  01010100
    - 2进制转8进制 ：从右向左，每三位一组，高位不够，用0补齐，算每一组的十进制的值，组合  124
    - 2进制转16进制 ：从右向左，每三位一组，高位不够，用0补齐，算每一组的十进制的值，组合  54

- 针对二进制和十进制之间的转换，人们提供了一个快速转换的方法，8421码

### 4.6.2、原码，反码，补码 （二进制形式）

> 由两个部分构成：符号位（最高位），数值位

- 原码：正数的原码与其二进制相同，最高位为0，负数的原码最高位为1

```python
3的原码：
1、3的二进制：11
2、3的原码：00000011

-3的原码：
1、3的二进制：11
2、-3的原码：10000011
```

- 反码：正数的反码与原码一致，负数的反码，符号位不变，数值位按位取反

```python
3的反码：
1、3的二进制：11
2、3的原码：00000011
3、3的反码：00000011

-3的原码：
1、3的二进制：11
2、-3的原码：10000011
3、-3的反码：11111100
```

- 补码：正数的补码与原码一致，负数的补码，由反码的末位（最右边的）+1

```python
3的反码：
1、3的二进制：11
2、3的原码：00000011
3、3的反码：00000011
4、3的补码：00000011

-3的原码：
1、3的二进制：11
2、-3的原码：10000011
3、-3的反码：11111100
4、-3的补码：11111101
```

----------------------------------

```python
-3+1 = -2
我们看到的结果是底层补码计算后，转成原码，数值位再转10进制，拼接符号位的结果

-3的补码：11111101
1的补码： 00000001
----------------------
 补码：   11111110

已知补码求原码：
       符号位       数值位
补码：     1       1111110
反码：     1       1111101
原码：     1       0000010
--------------------------
 ===> -2
```

- &  有0则0

```python
a1 = 3
b1 = 4
'''
a1的二进制表现形式：

''' 
print(a1 & b1)  # 0

3的补码：00000011
4的补码：00000100
----------------
        00000000
```

- |  有1则1

```python
a1 = 3
b1 = 4
'''
a1的二进制表现形式：

''' 
print(a1 | b1)  # 7

3的补码：00000011
4的补码：00000100
----------------
        00000111
```

- ^ 相同则0 ，不同则1

```python
a1 = 3
b1 = 4
'''
a1的二进制表现形式：

''' 
print(a1 ^ b1)  #  7

3的补码：00000011
4的补码：00000100
----------------
        00000111
```

- ~  针对一个值来说，每一位上进行取反，0变成1，1变成0

```python
a1 = 3
'''
a1的二进制表现形式：

''' 
print(~a1)  #  -4

3的补码：00000011
----------------
补码：   11111100
反码：   11111011
原码：   10000100
---------------------
         -4
```

- <<  补码整体向左移动若干位，右边空出的位置使用0补齐  左移n位实际上就是*2的n次方

```python
a1 = 3 
print(a1<<2)   # 3*4=12  -->  3*2^2 = 12
3的补码：
    00000011
(00)00001100
---------------


b1 = -4
print(b1<<2)  # -4*4 = -16 --> -4*2^2= = -16
-4的原码：10000100
-4的反码：11111011
-4的补码：11111100

    11111100
(11)11110000
-------------------
补码：11110000
反码：11101111
原码：10010000
-------------------
     -16

c1 = 8
print(c1<<2)  # 32
```



- 右移>> 左边空出的位置，原本最高位是0，就用0补齐，原本最高位是1，就用1补齐  左移n位实际上就是//2的n次方

```python
print(64 >> 2)  # 16
64的补码：01000000
01000000
00010000(00)
---------------------
：16

print(-64 >> 2)  # -16
-64的原码：11000000
-64的反码：10111111
-64的补码：11000000
-----------------------
11000000
11110000(00)
-----------------------
补码：11110000
反码：11101111
原码：10010000
-----------------------
：-16
```

# 5、文件操作

## 5.1、编码(编码表)

```python
'中' -- 10010100
'国' -- 10001111


'父' -- 10010100
'亲' -- 10001111
```

- ascii码 是由一个字节表示

```python
'0' -> 十进制：48  二进制：00110000
'A' -> 十进制：65  二进制：01000001
'a' -> 十进制：97  二进制：01100001
```

- GB2312 | GBK  主要是表示一些简体中文字符  由两个字节表示一个字符

- BIG-5 ’大五码‘ 主要是表示一些台湾一些的繁体字
- unicode  万国码  是由4个字节表示一个字符，python默认就是这个unicode
- UTF-8 实际上是对unicode进行一个压缩，由三个字节表示一个字符

## 5.2、快速体验编码的过程

### 5.2.1加密 encode(encoding='编码')   

> 字符串--> 字节

```python
s1 = '今天晚上去爬大蜀山'
bytes1 = s1.encode(encoding='UTF-8')
print(bytes1)
```

### 5.2.2、解密 decode(encoding='编码')

| 字节--> 字符串

```python
s1 = '今天晚上去爬大蜀山'
s2 = bytes1.decode(encoding='UTF-8')
print(s2)
```

## 5.3、操作文件的步骤

- a. 打开文件
- b. 操作文件 （写，读）
- c. 关闭文件

### 5.3.1打开文件的模式：

- wb  覆盖以字节的形式写数据, 如果文件不存在，会自动创建
- ab  追加以字节的形式写数据, 如果文件不存在，会自动创建
- w   覆盖以以字节的形式（由参数encoding来决定）写数据, 如果文件不存在，会自动创建
- a    追加以以字节的形式（由参数encoding来决定）写数据, 如果文件不存在，会自动创建
- rb  以字节的形式读取文件
- r    读取文件，配合参数encoding，来自动解析数据

```python
# 案例1：打开文件并写内容
语句定义格式：
f = open('文件路径', mode='wb')
f.write('今天去爬大蜀山'.encode(encoding='UTF-8'))
f.close()
```

--------------------------------

>  相对路径  data/test1.txt
>
>  绝对路径（完整路径/带有盘符的路径）  E:\\projects\\PycharmProjects\\bigdata29\\day04\\data\\test1.txt

```python
f = open('E:\\projects\\PycharmProjects\\bigdata29\\day04\\data\\test1.txt', mode='wb')
f.write('今天去爬大蜀山'.encode(encoding='UTF-8'))
f.close()
```

-----------------------------

```python
f = open('E:\\projects\\PycharmProjects\\bigdata29\\day04\\data\\test1.txt', mode='ab')
f.write('今天去爬大蜀山'.encode(encoding='UTF-8'))
f.close()
```

----------------------

```python
# 建议工作的时候，写普通的文本文件使用该方式
f = open('data/test2.txt', mode='w', encoding='UTF-8')
f.write('今天去爬大蜀山')
f.close()
```

----------------------

```python
# 建议工作的时候，写普通的文本文件使用该方式
f = open('data/test2.txt', mode='a', encoding='UTF-8')
f.write('今天去爬大蜀山')
f.close()
```

----------

```python
# 建议工作的时候，写普通的文本文件使用该方式
f = open('data/test2.txt', mode='rb')
text = f.read().decode(encoding='UTF-8')
f.close()
print(text)
```

----------------

```python
# 读取文件内容，根据换行符切分得到每一行
f = open('data/test2.txt', mode='rb')
# line = f.readline().decode(encoding='UTF-8')
text = f.read().decode(encoding='UTF-8')
f.close()
line_list = text.split('\r\n')
for i in line_list:
    print(i)
```

--------

```python
# 读取文件内容，根据换行符切分得到每一行
f = open('data/test2.txt', mode='r',encoding='UTF-8')
text = f.read()
f.close()
line_list = text.split('\r\n')
for i in line_list:
    print(i)
```

### 场景案例

#### 1、用户注册，将用户注册的信息保存到文件中

```python
while True:
    name = input('请输入您的用户名:')
    if name.upper() == 'Q':
        break
    password = input('请输入您的密码:')
    email = input('请输入您的邮箱:')
    info = '{},{},{}\n'.format(name, password, email)
    f = open('data/infos.csv', mode='a', encoding='UTF-8')
    f.write(info)
    f.close()
```

-----------

```python
f = open('data/infos.csv', mode='a', encoding='UTF-8')
while True:
    name = input('请输入您的用户名:')
    if name.upper() == 'Q':
        break
    password = input('请输入您的密码:')
    email = input('请输入您的邮箱:')
    info = '{},{},{}\n'.format(name, password, email)
    f.write(info)
f.close()
```

------

```python
f = open('data/infos.csv', mode='a', encoding='UTF-8')
while True:
    name = input('请输入您的用户名:')
    if name.upper() == 'Q':
        break
    password = input('请输入您的密码:')
    email = input('请输入您的邮箱:')
    info = '{},{},{}\n'.format(name, password, email)
    f.write(info)  # 往内存中写
    f.flush()  # 将内存中所有数据强刷到磁盘中
f.close()  # close()函数内部实际上有flush的操作
```

#### 2、从网络中获取资源，写到文件中（爬虫的知识）

```python
import requests

headers = {
    'Cookie': 'uuid=c824f69f-ea1b-4d7c-9514-2a4cde2d6894; sessionid=4fea92df-ef26-4018-f128-09073aa01237; guazitrackersessioncadata=%7B%22ca_kw%22%3A%22-%22%7D; cainfo=%7B%22ca_s%22%3A%22seo_baidu%22%2C%22ca_n%22%3A%22default%22%2C%22ca_medium%22%3A%22-%22%2C%22ca_term%22%3A%22-%22%2C%22ca_content%22%3A%22-%22%2C%22ca_campaign%22%3A%22-%22%2C%22ca_kw%22%3A%22-%22%2C%22ca_i%22%3A%22-%22%2C%22scode%22%3A%22-%22%2C%22guid%22%3A%22c824f69f-ea1b-4d7c-9514-2a4cde2d6894%22%7D',
    'Origin': 'https://www.guazi.com',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Verify-Token': '0b724e6b65f7f066c52f757e2cfb9aa4'
}

res = requests.get(
    'https://mapi.guazi.com/car-source/carList/pcList?versionId=0.0.0.0&sourceFrom=wap&deviceId=c824f69f-ea1b-4d7c-9514-2a4cde2d6894&osv=Windows+10&minor=&sourceType=&ec_buy_car_list_ab=&location_city=&district_id=&tag=-1&license_date=&auto_type=&driving_type=&gearbox=&road_haul=&air_displacement=&emission=&car_color=&guobie=&bright_spot_config=&seat=&fuel_type=&order=&priceRange=0,-1&tag_types=&diff_city=&intention_options=&initialPriceRange=&monthlyPriceRange=&transfer_num=&car_year=&carid_qigangshu=&carid_jinqixingshi=&cheliangjibie=&page=1&pageSize=20&city_filter=12&city=12&guazi_city=12&qpres=&platfromSource=wap',
    headers=headers)
res1 = res.json()

car_list = res1['data']['postList']

# 打开一个文件
f = open('data/cars.txt', mode='ab')

for car in car_list:
    f.write(str(car['title']+'\n').encode('UTF-8'))

f.close()
```

#### 3、读取用户注册文件，将用户信息保存至列表

```python
list1 = []
f = open('data/infos.csv', mode='r', encoding='UTF-8')
content = f.read()
infos_list = content.split('\n')
for info in infos_list:
    if info != '':
        list1.append(info)
f.close()

print(list1)s
```



# 6、函数

## 6.1、什么是函数？

> 举例：植物大战僵尸中，豌豆射手在发射炮弹的时候，底层其实是一段代码，每发射一次，代码就会执行一次。假设发射炮弹这段代码需要写100行，如果没有函数的话，每发射一次就要写这100行代码。这样的话，程序会造成冗余。
>
> 解决方案：可以使用函数进行改进

- 将实现功能的代码，以python函数定义的格式进行编写，给这个函数起一个名字，将来需要使用该功能的时候，就可以通过函数名来进行调用实现功能。

```python
# 语句定义格式：
def 函数名(..):
	代码块

# 调用函数
函数名(..)
函数名(..)
```

-----------------

```python
# 定义
def print_info():
    print('欢迎进入温文涛婚恋介绍所')
    print(666)
    a1 = 10
    b1 = 20
    c1 = a1 + b1
    print(c1)


# 调用
print_info()
print_info()
```

- 编写函数的注意事项
  - 函数的名字，尽量使用小写英文单词，使用下划线拼接的方式   printInfo()
  - 函数不调用不执行

## 6.2、函数的使用场景

- 面向对象编程 ：指挥对象做事情（调用函数）
- 面向过程编程 ： 在此之前所有的编程都是面向过程的思想编写。

例子：

```python
print('数加作业提交系统')

if 作业为空白:
    发送警告的邮件(100行代码)
if 作业没有图片:
    发送警告的邮件(100行代码)
if 作业未交:
    发送警告的邮件(100行代码)
    
# 304行代码
```

------------

> 函数改写

```python
def 发送邮件():
    发送警告的邮件(100行代码)
    
if 作业为空白:
    发送邮件()
if 作业没有图片:
    发送邮件()
if 作业未交:
    发送邮件()
    
# 107
```

- 函数使用的好处
  - 降低代码的冗余度
  - 提高程序编写的灵活性

## 6.3、扩展知识：使用python发送qq邮件

- 前提：注册一个qq邮箱

![image-20240109094841266](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240109094841266.png)

```python
# zyxkyiufoghagije
import smtplib
from email.mime.text import MIMEText
from email.header import Header
msg_from = 'xxxx@qq.com'  # 发送方邮箱
passwd = 'xxxxxx'  # 填入发送方邮箱的授权码(填入自己的授权码，相当于邮箱密码)
msg_to = 'xxxx@qq.com'  # 收件人邮箱
# msg_to = ['','','']

subject = "欢迎信函"  # 主题
content = "欢迎大家来到兰智数加学院，祝前程似锦！"
# 生成一个MIMEText对象（还有一些其它参数）
msg = MIMEText(content)
# 放入邮件主题
msg['Subject'] = subject
# 也可以这样传参
# msg['Subject'] = Header(subject, 'utf-8')
# 放入发件人
msg['From'] = msg_from
# 放入收件人
# 通过ssl方式发送，服务器地址，端口
s = smtplib.SMTP_SSL("smtp.qq.com", 465)
# 登录到邮箱
s.login(msg_from, passwd)
# 发送邮件：发送方，收件方，要发送的消息
s.sendmail(msg_from, msg_to, msg.as_string())
print('成功')
```

## 6.4、函数参数的问题

### 6.4.1 基本用法

- 将发送邮件的功能封装成函数

```python
def xxx():
    xxx
```

```python
# 定义
# def print_info():
#     print('欢迎进入温文涛婚恋介绍所')
#     print(666)
#     a1 = 10
#     b1 = 20
#     c1 = a1 + b1
#     print(c1)
#
#
# # 调用
# print_info()
# print_info()

# 定义一个函数发送邮箱
def send_email(license_code, receiver_email, subject, info):
    # zyxkyiufoghagije
    import smtplib
    from email.mime.text import MIMEText
    from email.header import Header
    msg_from = '1165872335@qq.com'  # 发送方邮箱
    passwd = license_code  # 填入发送方邮箱的授权码(填入自己的授权码，相当于邮箱密码)
    msg_to = receiver_email  # 收件人邮箱
    # msg_to = ['','','']

    subject = subject  # 主题
    content = info
    # 生成一个MIMEText对象（还有一些其它参数）
    msg = MIMEText(content)
    # 放入邮件主题
    msg['Subject'] = subject
    # 也可以这样传参
    # msg['Subject'] = Header(subject, 'utf-8')
    # 放入发件人
    msg['From'] = msg_from
    # 放入收件人
    # 通过ssl方式发送，服务器地址，端口
    s = smtplib.SMTP_SSL("smtp.qq.com", 465)
    # 登录到邮箱
    s.login(msg_from, passwd)
    # 发送邮件：发送方，收件方，要发送的消息
    s.sendmail(msg_from, msg_to, msg.as_string())
    print('成功')


license_code = input('请输入授权码:')
receiver_email = input('请输入接收方邮箱:')
subject = input('请输入主题:')
info = input('请输入邮件内容:')

send_email(license_code, receiver_email, subject, info)

```

- 位置传参
  - 形式参数：指的是函数定义时上面的参数
  - 实际参数：调用时实际传入的值

```python
def fun1(a1,b1,c1):
    d1 = a1+b1+c1
    print(d1)

fun1(11,22,33)
```

- 关键字传参

```python
def fun1(a1,b1,c1):
    d1 = a1+b1+c1
    print(d1)

fun1(c1=11,a1=22,b1=33)
```

- 混合传参 

```python
def fun1(a1,b1,c1):
    d1 = a1+b1+c1
    print(d1)

fun1(11,22,c1=99)
```

> 注意：混合传参时，关键字传参必须是最后一个传入

### 6.4.2 定义时给默认值

```python
def fun1(a1, b1, c1=1000):
    d1 = a1 + b1 + c1
    print(d1)

# 可以调用的方式
fun1(11, 22)
fun1(11, 22, 33)  # 将默认值进行覆盖
fun1(11, b1=200, c1=300)
```

-----

- 练习：定义一个函数，函数接收2个参数，第一个参数是一个大字符串，第二个参数是一个字符，函数功能是判断该字符在大字符串中出现的次数

```python
def get_str_count(big_str,s):
	count = 0
    for i in big_str:
        if i==s:
            count+=1
    print(f'{s}字符在大字符串中共出现了{count}次。。')

get_str_count('dqwedasdqwefvwqdfsadfaswqrsadas','a')
```

-----

```python
# 定义一个函数，函数接收2个参数，第一个参数是一个大字符串，第二个参数是一个字符,默认是找a，函数功能是判断该字符在大字符串中出现的次数
def get_str_count(big_str, s='a'):
    count = 0
    for i in big_str:
        if i == s:
            count += 1
    print(f'{s}字符在大字符串中共出现了{count}次。。')

get_str_count('dqwedasdqwefvwqdfsadfaswqrsadas')
get_str_count('dqwedasdqwefvwqdfsadfaswqrsadas', 'd')
```

### 6.4.3 动态参数

#### 6.4.3.1 *

- 实际参数传入到函数里面的时候，会被一个元组所接收

> 未使用动态参数之前

```python
# 需求：定义一个函数，传入两个整数参数，求和
def sum1(a1, b1):
    if type(a1) == int and type(b1) == int:
        print(f'{a1}+{b1}={a1 + b1}')


# 需求：定义一个函数，传入三个整数参数，求和
def sum2(a1, b1, c1):
    if type(a1) == int and type(b1) == int:
        print(f'{a1}+{b1}+{c1}={a1 + b1 + c1}')


sum1(11, 22)
sum2(11, 22,33)
```

> 使用动态参数之后

```python
# 语句定义格式
def 函数名(*a1):
    # a1 = (xx,xx,xx,xx)

# 调用
函数名(xx,xx,xx,xx)
```

-------------

```python
# 需求：定义一个函数，传入若干个整数参数，求和
def sum1(*a1):  # (11,22,33,44,55)
    sum_number = 0
    for i in a1:
        if type(i)==int:
            sum_number+=i
    print(f'总和为{sum_number}')

sum1(11,22,33,44,55)
```

---------------

> 动态参数 * 调用的场景

```python
def fun1(*a1):
	# a1 = (1,2,33)
    # a1 = ('aaa',33)
    # a1 = ([11,22,33],'小虎')
    # a1 = (11, )
    # a1 = ()
    # a1 = ([11,22,33], )
    # a1 = ((11,22,33), )
    
fun1(1,2,33)
fun1('aaa',33)
fun1([11,22,33],'小虎')
fun1(11)
fun1()
fun1([11,22,33])
fun1((11,22,33))
```

#### 6.4.3.2 ** 可以传键值对

> key=value

```python
# 语句定义格式
def fun1(**a2):
    # a2 = {'key':'value'}

fun1(key=value)    
```

--------------

> 动态参数 ** 调用的场景

```python
# 语句定义格式
def fun1(**a2):
    # a2 = {'key':'value'}
    # a2 = {}
    # a2 = {'name':'xiaohu','age':18}

fun1(key=value)   
fun1()
fun1(name=xiaohu,age=18)
```

#### 6.4.3.3 混合使用 *  **

> 底层会根据传入的是单个值，还是键值对的值，来区分对*还是**进行赋值

```python
def fun1(*a1,**a2):
    # a1=(1,2)  a2={}
    # a1=() a2={'a1':11,'a2':33}
    # a1=() a2={}
    # a1=(1, ) a2={'a1':11}
    

fun1(1,2)
fun1(a1=11,a2=33)
fun1()
fun1(1,a1=11)
```

-------------------

```python
def fun2(a1,b1,*q1,**w1):
    # a1=11,b1=22,q1=(),w1={}
    # a1=11,b1=22,q1=(33,44),w1={'r1':18}

fun2(11,22)
fun2(11,22,33,44,r1=18)
```

----------

> python企业开发中，对于动态参数的命名有一个统一的潜规则

```python
def fun1(*args,**kwargs)
```

## 6.5、函数返回值的问题

> 调用完函数后，会给调用者一个结果，这个结果实际上就是函数的返回值
>
> 在python中，提供了一个关键字，可以在函数中表示返回值的意思：return

- 例子

```python
def sum1(a1,b1):
    c1 = a1+b1
    return c1

print(sum1(11,22))
res1 = sum1(11,22)
print(res1)
```

### 6.5.1 return和print()的区别

```
return: 作为函数中的语句结构，主要是用作函数执行结束的返回值
print(): 在控制台中输出
```

```python
def sum1(a1,b1):
    c1 = a1+b1
    print(c1)

sum1(11,22)
```

```python
def sum1(a1,b1):
    c1 = a1+b1
    print(c1)
    return c1

res1 = sum1(11,22)
print(res1)
```



> 返回值的注意事项：
>
> - 如果一个函数中没有写return，最后一句话，默认会有一个return None
> - 返回值的类型可以是任意的数据类型
>
> ```python
> def sum1(a1,b1):
>     c1 = a1+b1
>     print(c1)
>     # return [12,22,32,42]
>     # return '小虎真帅'
> 
> res1 = sum1(11,22)
> print(res1)
> ```
>
> - 函数内部中只能有一个return生效，并且函数执行过程中一旦遇到return，就结束了，后续代码不会执行
>
> ```python
> def fun1():
>     a1 = 3
>     b1 = 4
>     return 3 + 4  # 结束了函数
>     c1 = 5
>     print(c1)
>     return c1
> 
> 
> res1 = fun1()
> print(res1)
> ```
>
> ```python
> # 函数不会return很多次
> def fun2():
>     for i in range(10):
>         return i
> res1 = fun2()
> print(res1)
> ```
>
> 

### 6.5.2 关于返回值的相关练习

- 定义一个函数，接收任意个位置传参的参数（整数），在函数的内部将用户传入的所有参数，相加，得到结果返回给调用者

```python
def sum1(*args):  # args = ([xx,xxx,xx], )
    res = 0
    for i in args[0]:
        if type(i) == int:
            res += i
    return res


def get_list():
    list1 = []
    while True:
        number = input('请输入一个需要相加的整数:')
        if number.upper() == 'Q':
            break
        if number.isdecimal():
            list1.append(int(number))
    return list1


list2 = get_list()
res1 = sum1(list2)
print(f'所有数据之和为：{res1}')
```

- 看程序写结果

```python
def func():
    print('开始')
    for i in range(3)
    	print(i)
    print('结束')
res1 = func()
print(res1)
```

```
开始
0
1
2
结束
None
```

- 定义一个函数，接收两个参数，第一个参数：文件的路径  第二个参数：关键字。打开第一个参数的文件并读取每一行，判断这一行是否包含第二个参数的关键字，如果包含，就将这一行添加到列表中进行返回。返回值：列表

```python
def fun1(path,key_word):
    list1 = []
    with open(path,mode='r',encoding='UTF-8') as f:
    	for line in f:
            line = line.strip()
            if key_word in line:
                list1.append(line)
    return list1

list2 = fun1('a1.txt','刘备')
print(list2)
```

```python
import os

def fun1(path, key_word):
    list1 = []
    if not os.path.exists(path):
        return list1

    with open(path, mode='r', encoding='UTF-8') as f:
        for line in f:
            line = line.strip()
            if key_word in line:
                list1.append(line)
    return list1


list2 = fun1('data/sgyy.txt', '刘备')
print(list2)
for i in list2:
    print(i)
    print('-' * 100)
```

- 返回值的扩展知识

```python
def fun1():
    return 11, 22, 33


res = fun1()
print(res,type(res)) # (11, 22, 33) <class 'tuple'>
```

```python
def fun1():
    return 11, 22, 33


a1, a2, a3 = fun1()
print(f'a1:{a1}')
print(f'a2:{a2}')
print(f'a3:{a3}')
```

## 6.6、函数的种类

- 无参返回值为None

```python
def fun1():
    print(11)
```

- 有参返回值为None

```python
def fun2(a1):
    print(a1)
```

- 无参返回值不为None

```python
def fun3():
    return 11
```

- 有参返回值不为None

```python
def fun4(a1):
    return a1+10
```

## 6.7、函数的调用

- 单独调用
- 嵌套调用

```python
def fun1():
    pass

def fun2():
    print(11)
    print(12)

def fun3():
    print(100)
    fun2()
    print(200)
    fun1()
    print(300)
    
fun3()
```

```python
def fun1():
    pass


def fun2():
    print(11)
    print(12)
    return 'shujia'


def fun3():
    print(100)
    data = fun2()
    print(data)
    print(200)
    fun1()
    print(300)


fun3()
```

- python中的函数可以进行嵌套定义

```python
def fun1():
    print('数加科技')

    def fun2():
        print('今天天气不错')
    fun2()

fun1()
```

## 6.8、函数参数传递的问题

> 传递的是地址值还是数值呢？python

```python
def fun1(a1):
    print(a1)

name = 'xiaohu'
fun1(name)
# python中函数的调用参数传递的是地址值
```

---------

```python
def fun1(a1):
    a1.append(666)

list1 = [1,2,3]
fun1(list1)

print(list1)
```

![image-20240109155711433](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240109155711433.png)

----

```python
def fun1(a1):
    b1 = a1.upper()

s1 = 'shujia'
fun1(s1)

print(s1)
```

![image-20240109160108119](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240109160108119.png)

## 6.9、作用域

> 作用域：实际上就是一块共享的区域
>
> python程序中其实有两种作用域：
>
> - python的py文件中一整块是一个作用域
> - python中的函数内部是一个独立的作用域

```python
name = '小虎'
age = 18
if 1==1:
    s1 = 10
for i in range(10):
    pass

print(name,age,s1,i) # 这里的name，age，s1，i其实都同属于一个大的作用域
```

### 6.9.1 全局变量和局部变量

- 全局变量：将变量定义在函数的外部
- 局部变量：将变量定义在函数的内部

```python
# 全局变量
name = '小虎'
age = 18

def fun1():
    # 局部变量
    a1 = 3
    b1 = 4
    c1 = 'xiaohu'
    print(a1)
    print(b1)
    print(c1)

fun1()
```

- 局部作用域可以访问外部作用域的变量
- 函数与函数之间的作用域的变量是不可以互相访问的

- 在实际开发中，如果定义的变量是全局变量的话，请使用大写字母下划线拼接；如果定义的是局部变量，使用小写字母下划线拼接

```python
# 全局变量
NAME = '小虎'
AGE = 18

def fun1():
    # 局部变量
    a1 = 3
    b1 = 4
    c1 = 'xiaohu'
    print(a1)
    print(b1)
    print(c1)

fun1()
```

### 6.9.2 global 关键字

> 可以修饰局部变量，将局部变量变成全局变量

```python
# 全局变量
NAME = '小虎'
AGE = 18

def fun1():
    # 局部变量
    a1 = 3
    b1 = 4
    c1 = 'xiaohu'
    print(a1)
    print(b1)
    print(c1)

fun1()
print(a1)
```

![image-20240109165610805](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240109165610805.png)

## 6.10、函数名本身也是一个变量

```python
# 变量的使用
name = '小虎'
name2 = name
print(name)
print(name2)
```

-----

```python
def fun1():
    print('hello world')


fun2 = fun1
fun1()
fun2()
```

-----

```python
def fun1():
    print('hello world')

# 加了小括号，表示调用了改函数，将函数的返回值给变量fun2
fun2 = fun1()
fun1()
fun2()
```

> 应用场景：一次调用多个函数的时候

```python
def fun1():
    print('鹅鹅鹅')
def fun2():
    print('曲项向天歌')
def fun3():
    print('白毛浮绿水')
def fun4():
    print('红掌拨清波')

if action=='开始':
    fun1()
    fun2()
    fun3()
    fun4()
```

------

- 将函数名当作变量进行使用

```python
def fun1():
    print('鹅鹅鹅')


def fun2():
    print('曲项向天歌')


def fun3():
    print('白毛浮绿水')


def fun4():
    print('红掌拨清波')


fun_list = [fun1, fun2, fun3, fun4]

action = input('请输入开始：')
if action == '开始':
    for i in fun_list:
        i()
```

### 6.10.1 练习

- 定义3个函数，分别代表注册，登录，查看用户信息，一开始，提供一个列表给用户选择（1. 注册  2. 登录 3. 查看用户信息）

```

```



## 6.11、内置函数

> python内部也提供了大量的函数，可以让我们直接在程序中使用

![db61bb40f63980cd71cb1783678afe1](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/db61bb40f63980cd71cb1783678afe1.png)

### 6.11.1第一类函数(数学运算相关的) 5个

- abs()  求绝对值

```python
a1 = abs(-10)
print(a1)  # 10
```

- pow()   次方

```python
a1 = pow(2,3)  # 计算2的3次方
print(a1)  # 8
```

- sum()   求和

```python
list1 = [1, 2, 3, 4, 5]
res1 = sum(list1)
print(res1)
```

- divmod() 两个数相除得到一个商，一个余数

```python
a1, b1 = divmod(3, 5)
print(a1)  # 商
print(b1)  # 余数
```

- round()  四舍五入保留小数

```python
a1 = round(1.2367538,2)
print(a1)
```

### 6.11.2第二类函数（和聚合相关）

- min() 最小值

```python
a1 = min([21,3,55,62,3,1])
print(a1)
```

- max() 最大值

```python
a1 = max([21,3,55,62,3,1])
print(a1)
```

- all  判断一个序列中，是否都是True, 

```python
0
''
()
{}
[]
0.0

list1 = [1,2,3,0,5]
res1 = all(list1)
print(res1)  # False
```

- any 只要有一个是True就可以

```python
list1 = [1,2,3,0,5]
res1 = any(list1)
print(res1)  # True
```

```python
list1 = [0.0,1,[],0,()]
res1 = any(list1)
print(res1)  # True
```

### 6.11.3第三类函数（和进制相关）

```python
'0b111011'  # 二进制
'0100'  # 八进制
'100'   # 十进制
'0x100' # 十六进制
```

- 十进制、二进制

  - 十进制---> 二进制

  ```python
  a1 = bin(100)
  print(a1)
  ```

  - 二进制---> 十进制

  ```python
  a1 = int('0b1100100',2)
  print(a1)
  ```

- 十进制、八进制

  - 十进制-->八进制

  ```python
  a1 = oct(100)
  print(a1)  # 0o144
  ```

  - 八进制-->十进制

  ```python
  res1 = int('0o144',8)
  print(res1)
  ```

- 十进制、十六进制

  - 十进制-->十六进制

  ```python
  a1 = hex(100)
  print(a1) # 0x64
  ```

  - 十六进制-->十进制

  ```python
  res1 = int('0x64',16)
  print(res1)
  ```

> 作业1：将自己的IP地址，转换成二进制的形式  (1、将IP地址转2进制   2、传二进制的ip地址转点分十进制)
>
> win+R  cmd   ipconfig

### 6.11.4第四类函数（字符相关）

- ord()  获取对应的ASCII码值

```python
a1 = ord('A') 
print(a1)
```

- chr()   获取ASCII码值对应的字符

```python
a1 = chr(65)
print(a1)
```

> 作业2：生成验证码，包含数字和字母

### 6.11.5第五类函数（转型相关）

- int()
- str()

- bool()
- list()
- tuple()
- dict()
- bytes()

```python
name = '小虎'
res1 = name.encode('UTF-8')
print(res1,type(res1))  # b'\xe5\xb0\x8f\xe8\x99\x8e' <class 'bytes'>
```

```python
res2 = bytes('小虎',encoding='utf-8')
print(res2)
```

### 6.11.6第六类函数（获取属性数据相关）

- len()
- print()
- input()
- open()
- range()
- hash  计算一个值的哈希值（计算存储位置的）

```python
# 相同的数据，哈希值是一样的
print(hash('ABC'))
print(hash('ABC'))
```

- type() 查看元素的数据类型的

```python
# 数据类型是可以直接使用==进行比较
```

- callable   判断一个变量是不是一个函数，判断是否可以执行

```python
a1 = 'abc'
res1 = callable(a1)
print(res1) # False
```

```python
def fun1():
    print('hello world')
    
res1 = callable(fun1)
print(res1) # True
```

- enumerate() 获取序列中的索引以及元素值

```python
list1 = [11, 22, 33, 44, 55]
for index, value in enumerate(list1):
    print(f'{index}.{value}')
```

- sorted() 排序 产生排序后的新列表

```python
list1 = [11, 2, 14, 45, 16]
res1 = sorted(list1)
print(res1)  # [2, 11, 14, 16, 45]
print(list1) # [11, 2, 14, 45, 16]
```

-----

```python
name_list = ['小虎:1001', '丁义杰:1006', '李超超:1003', '温文涛:1002']
# print(name_list)

def get_key(e):
    return int(str(e).split(':')[1])


res1 = sorted(name_list, key=get_key)
print(res1)
```

## 6.12、函数生成器

```python
def fun1(a1):
	print(a1)
	return a1
fun1()
```

----

```python
def fun2(a1):  # [11,22,33,44]
    print('hello1')
    yield a1[0]
    print('hello2')
    yield a1[1]
    print('hello3')
    yield a1[2]
    print('hello4')
    yield a1[3]
    # 这里的代码需要再调用一次__next__()函数，但是__next__()必须要取yield后面的值，已经没有yield的了，所以报错
    # print('hello5')  


res1 = fun2([11, 22, 33, 44])
# print(res1)

a1 = res1.__next__()  # yield
print(a1)
a2 = res1.__next__()
print(a2)
a3 = res1.__next__()
print(a3)
a4 = res1.__next__()
print(a4)
a5 = res1.__next__() # StopIteration
print(a5)
```

------

```python
def fun2(a1):  # [11,22,33,44]
    print('hello1')
    yield a1[0]
    print('hello2')
    yield a1[1]
    print('hello3')
    yield a1[2]
    print('hello4')
    yield a1[3]
    # 这里的代码需要再调用一次__next__()函数，但是__next__()必须要取yield后面的值，已经没有yield的了，所以报错
    # print('hello5')  


res1 = fun2([11, 22, 33, 44])# 函数生成器可以使用for循环代替调用__next__()函数
for i in res1:
    print(i)
```

> 这个东西具体有什么用呢？
>
> 需求：在不创建列表的前提下，创建1000w个数字

```python
def fun1():
    for i in range(1,11):
        yield i
```

## 

# 7、模块

- 自定义模块  py文件
- 内置模块  time  random  ...
- 第三方模块  requests lxml ... 

## 7.1 导入模块的方式

- import xxx  直接将大的模块进行导入
- from xxx import xxx 从大的模块中导入小的功能
- as 的方式，对导入的东西的重命名

> 将来开发的时候，将功能的功能放入到一个模块中，其他的模块要想使用该功能，就必须导入

## 7.2 易错点！！！！！！！

```python
# 将来定义模块名字的时候，千万不要与内置模块或者与第三方模块重名，会导致功能用不了
random.py

import random

res = random.randint(1000, 9999)
print(res)
```

![image-20240111155934987](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240111155934987.png)

## 7.3、常用内置模块

### 7.3.1、random

```python
import random

# 获取随机的整数
res = random.randint(10, 20)  # [10,20]
print(res)

# 获取随机的小数
res2 = round(random.uniform(10, 20), 2)
print(res2)

# 从列表中随机获取一个元素
list1 = [11, 22, 33, 44, 55, 66, 77, 88]
res3 = random.choice(list1)
print(res3)

# 从列表中随机获取n个元素
list1 = [11, 22, 33, 44, 55, 66, 77, 88]
res3 = random.sample(list1,2)
print(res3)

print('-----------------------------')
# 随机打乱顺序
list1 = [11, 22, 33, 44, 55, 66, 77, 88]
random.shuffle(list1)
print(list1)
```

------------

> 使用random模块编写一个抽奖小程序

```python
# 使用列表推导式生成一个列表
users_list = [f'学生-小虎{i}' for i in range(13)]
print(users_list)

# 设置奖项以及人数
data_list = [
    ('特等奖', 1, '华为问界汽车一辆'),
    ('一等奖', 1, '10万元现金以及问界汽车10元优惠券'),
    ('二等奖', 3, '华为mate60 pro'),
    ('三等奖', 5, '华为手表')
]


def choujiang(data_list):
    # 开始抽奖
    for grade, counts, goods in data_list[::-1]:
        print(f'开始抽{grade}'.center(50, '-'))
        res_list = random.sample(users_list, counts)

        # 将中奖的人从列表中删除
        for user in res_list:
            users_list.remove(user)

        info = f'恭喜{",".join(res_list)}!! 每人获得{goods}奖品!!'
        yield info

res = choujiang(data_list)
a1 = res.__next__()
print(a1)
a1 = res.__next__()
print(a1)
a1 = res.__next__()
print(a1)
a1 = res.__next__()
print(a1)
```





### 7.3.2、hashlib库

> 主要是用于数据加密 sha256(可逆)  md5(不可逆)

```python
123456

md5(123456) = 'dsadasdqwewqcwe'
```

```python
import hashlib
info = '17354074069'

# 获取MD5加密对象
md5_objet = hashlib.md5()
# 修改数据加密编码
md5_objet.update(info.encode('UTF-8'))
# 调用方法，开始加密
res1 = md5_objet.hexdigest()
print(res1)  # 301f41f4e66dbc95168ec973e6df9747
```

> 一般情况下，我们在做md5加密算法的时候，适当进行**加盐**处理，因为可能会导致不同的数据，加密之后的结果会一样

```python
# 加密算法
# 获取MD5加密对象
md5_objet = hashlib.md5('xiaohuloveshujia'.encode('UTF-8'))
# 修改数据加密编码
md5_objet.update(info.encode('UTF-8'))
# 调用方法，开始加密
res1 = md5_objet.hexdigest()
print(res1)  # 5fe31fe1535ecaba0454d2c897866b6b
```

### 7.3.3、json库

- 本质其实是一个字符串，有一些特殊格式的字符串

- 序列化与反序列化

  - 序列化：将自己的文本数据，程序中的数据转变成网络中传输的数据

    ```python
    # 将网络中符合json格式的大字符串，转变成python中的数据类型
    import json
    
    # info = '''
    # {"name":"小虎","likes":["打篮球","踢足球","学习"]}
    # '''
    
    # {"name":"小虎","likes":["打篮球","踢足球","学习"]}
    
    # {"name":"小虎","likes":("打篮球","踢足球","学习")}
    
    data = json.loads(info)
    print(data['likes'])
    print(type(data))
    ```

  - 反序列化：将网络中传输的数据，转变成程序中的数据或者文本数据

    ```python
    import json
    dict1 = {
        'name': '小虎',
        'likes': ['打篮球', '踢足球', '学习'],
        'pets': (
            {'name': '小花', 'age': 3},
            {'name': '小黄', 'age': 2}
        )
    }
    
    data = json.dumps(dict1, ensure_ascii=False)
    print(data, type(data))
    ```

    



### 7.3.4、time库

> 时间戳相关

```python
s1 = time.time()  # 时间戳 毫秒级别  整数部分秒级别
print(s1, type(s1))
```

### 7.3.5、datetime

> 日期相关

```python
from datetime import datetime

# s1 = time.time()  # 时间戳 毫秒级别  整数部分秒级别
# print(s1, type(s1))

# xxxx年xx月xx日  xx时xx分xx秒
s1 = datetime.now()
print(s1,type(s1))  # 2024-01-12 11:11:24.986242

# 日期格式化
s2 = s1.strftime("%H:%M:%S  %Y/%m/%d")
print(s2)
```

> 常见日期字符串时间戳之间转换

![image-20240112112939757](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240112112939757.png)

```python
# 字符串-->datetime类型 strptime()
s1 = "2024-01-12"

s1 = datetime.strptime(s1, '%Y-%m-%d')  # 格式要与字符串的格式一致
print(s1, type(s1))
print('-------------------')
# datetime类型--> 字符串
s2 = datetime.now().strftime("%H:%M:%S  %Y/%m/%d")
print(s1,type(s2))
print('-------------------')
# datetime-->时间戳
s3 = datetime.now() # datetime类型
s3 = s3.timestamp()
print(s3,type(s3))
print('-------------------')
# 时间戳-->datetime类型
res = datetime.fromtimestamp(s3)
print(res)


res = res.strftime("%Y/%m/%d %H:%M:%S")
print(res)

# 时间戳-->datetime类型-->字符串
s4 = datetime.fromtimestamp(1705028697).strftime("%Y/%m/%d %H:%M:%S")
print(s4)
```

> 拼接字符串中有中文

```python
# xxxx年xx月xx日  xx时xx分xx秒
s5 = datetime.fromtimestamp(1705028697)
print(s5,type(s5))
time_str = f'{s5.year}年{s5.month}月{s5.day}日 {s5.hour}时{s5.minute}分{s5.second}秒'
print(time_str)
```

### 7.3.6、os 系统文件模块

- 路径的拼接  data/users.txt

```python
# 将路径进行拼接
s1 = os.path.join('data','users.txt')
print(s1,type(s1)) # data\users.txt <class 'str'>
```

- 上一级目录

```python
# 将路径进行拼接
s1 = os.path.join('data','info','users.txt')
print(s1,type(s1)) # data\info\users.txt <class 'str'>

# 获取父级目录
s2= os.path.dirname(s1)
print(s2)
```

- 项目开发中，通常情况下，有时候会使用绝对路径

```python
# 获取当前文件所在的绝对路径父级目录
s1 = os.path.dirname(os.path.abspath(__file__))
# s1 = os.path.abspath(__file__)   # 获取当前文件所在的绝对路径
s2 = os.path.join(s1, 'data', 'users.txt')
print(s2)
f = open(s2, 'r', encoding='UTF-8')
print(f.read())
f.close()
```

- 判断路径是否存在

```python
# 判断 s2 : E:\projects\PycharmProjects\bigdata29\day07\data\users.txt 是否存在
print(os.path.exists(s2))
```

- 创建文件夹 

```python
os.makedirs(s2)

# 注意：
1、如果要创建文件的话，就使用open的方式创建，将模式改为w或者a
2、如果要创建文件夹的话，就使用os模块，使用makedirs函数创建
```

- 判断路径是否是一个文件夹

```python
print(os.path.isdir(s2))
```

- 删除文件或者文件夹

```python
# 删除文件
# os.remove(s2) # remove无法删除文件夹

# 删除文件夹
os.rmdir(s2)
```

- 查看目录下的文件和文件夹

```python
res1 = os.walk(s1)  # 查看目录下的文件和文件夹
# a1: 表示当前的文件夹路径
# a2: 表示当前路径下的文件夹的列表
# a3: 表示当前路径下的文件的列表
for a1, a2, a3 in res1:  
    print(f'a1: {a1}, a2: {a2}, a3: {a3}')
    print('-----------------')
```



```python
20240112 -- > 
	xxxx
    xxx
   	..

20240113 -->
	xxxx
    xxx
    x
    xx
    ..
```

> 需求1：将用户注册的信息，按照天进行分区管理，分区实际上目前来说是一个一个的文件夹

```python
# 需求1：将用户注册的信息，按照天进行分区管理，分区实际上目前来说是一个一个的文件夹
import os
from datetime import datetime

BASE_PATH = os.path.dirname(os.path.abspath(__file__))

if __name__ == '__main__':
    username = input('请输入您的用户名: ')
    password = input('请输入您的密码: ')

    info = f'{username}|{password}\n'

    # 判断文件夹是否存在，不存在就创建
    # date_str = datetime.now().strftime('%Y-%m-%d')
    date_str = datetime.fromtimestamp(1705115212).strftime('%Y-%m-%d')
    # day07\register_info\2024-01-12
    # day07\register_info\2024-01-13
    folder_path = os.path.join(BASE_PATH, 'register_info', date_str)
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)

    # 拼接文件路径
    file_path = os.path.join(folder_path, 'users.txt')
    with open(file_path, mode='a',encoding='UTF-8') as f:
        f.write(info)

```

> 需求2：用户购票案例（订票，查看历史订单）

```python
# 考虑目录的创建，每个用户文件（可以根据是否有该用户的文件，来判断用户是否是老用户还是新用户）
import os
from datetime import datetime

# 指定目录结构
BASE_PATH = os.path.dirname(os.path.abspath(__file__))
# 所有用户的文件都在一个叫做ticketing_system目录下
USERS_PATH = os.path.join(BASE_PATH, 'ticketing_system')


def book(user_file_path):
    cinema = input('请输入您选择的电影院：')
    movie = input('请输入您选择的电影：')
    tickets = input('请输入您购买的票数：')
    book_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    info = '{}|{}|{}|{}\n'.format(cinema, movie, tickets, book_time)

    with open(user_file_path, mode='a', encoding='UTF-8') as f:
        f.write(info)
        f.flush()

    print('订票成功！！')


def history(user_file_path):
    if os.path.exists(user_file_path):
        print('*'*100)
        with open(user_file_path, mode='r', encoding='UTF-8') as f:
            content = f.read()
            print(content)
    else:
        print('您没有历史订单！！')


# 开始运行的第一个函数
def run():
    # 判断路径订票系统是否存在，如果不存在就创建
    if not os.path.exists(USERS_PATH):
        os.makedirs(USERS_PATH)

    # 用户执行自己的业务
    username = input('请输入您的用户名: ')
    pwd = input('请输入您的密码: ')

    # 拼接用户文件路径
    user_file_path = os.path.join(USERS_PATH, f'{username}.txt')
    # 判断用户是否是新用户还是老用户
    if os.path.exists(user_file_path):
        print('欢迎回来！！')
    else:
        print('您是新用户！！')

    # 用户选择要处理的功能：（1、订票  2、查看历史订单）
    # 创建用户选择功能字典
    dict1 = {
        '1': book,
        '2': history
    }

    while True:
        print('-'*100)
        print('1.订票    2.查看历史订单')
        print('-'*100)
        choice = input('请输入您的选择：')
        if choice.upper() == 'Q':
            print('欢迎下次使用')
            break
        if choice == '1' or choice == '2':
            # 选择对的情况下，通过字典，调用对应的函数
            fun = dict1.get(choice)
            fun(user_file_path)  # 将用户的文件路径当作实际参数传入
        else:
            print('没有您想要的选项！请重新输入！')
            continue


if __name__ == '__main__':
    run()

```

# 8、异常处理

- 什么是异常

```
程序运行过程中出现不正常的情况
```

## 8.1、异常分类

- 错误：代码语法写的有问题导致的，Pycharm会有红色的下划线进行提示
- 异常：一般只有在程序运行的时候，才会被发现，这种的异常将来我们要做处理

## 8.2、处理异常

- try...except...语句

```python
try:
    可能会出现问题的代码
except:
    如果try里面的代码出现了问题，就会运行这里的代码, 如果不出问题，就不会运行
```

------

```python
list1 = [11, 22, 33, 44]
print(list1[4])
print('hello world')  

-----------------------------------------------------
try:
    list1 = [11, 22, 33, 44]
	print(list1[4])
except:
    print('取了不该取的索引！！！！')


print('hello world')    
```



- try...except...else语句

![image-20240112170931681](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240112170931681.png)

```python
try:
    list1 = [11, 22, 33, 44]
	print(list1[4])
except:
    print('取了不该取的索引！！！！')
else: # 当try中的代码没问题的时候会执行
    print('我是else')


print('hello world')   
```



- finally子句

![image-20240112171258912](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240112171258912.png)

```python
try:
    list1 = [11, 22, 33, 44]
	print(list1[4])
except:
    print('取了不该取的索引！！！！')
else: # 当try中的代码没问题的时候会执行
    print('我是else')
finally: # 无论try中的代码是True还是False，都会执行，除非在运行finally之前，突然退出程序
    print('今天天气不错！')

print('hello world')   
```

> 作用：finally通常情况下，是用作释放资源

- 异常处理的好处
  - 让程序能够进行下去
  - 能够解决一些判断的复杂业务逻辑

> 异常案例: 将昨天的抽奖案例，加入异常

```python
import random

# 1、创建一个抽奖人名单，组成一个列表
# users = ['学生-小虎0', '学生-小虎1', '学生-小虎2', '学生-小虎3', '学生-小虎4', '学生-小虎5', '学生-小虎6', '学生-小虎7',
#          '学生-小虎8', '学生-小虎9', '学生-小虎10', '学生-小虎11', '学生-小虎12']

# 使用列表推导式生成一个列表
users_list = [f'学生-小虎{i}' for i in range(13)]
print(users_list)

# 设置奖项以及人数
data_list = [
    ('特等奖', 1, '华为问界汽车一辆'),
    ('一等奖', 1, '10万元现金以及问界汽车10元优惠券'),
    ('二等奖', 3, '华为mate60 pro'),
    ('三等奖', 5, '华为手表')
]


def choujiang(data_list):
    # 开始抽奖
    for grade, counts, goods in data_list[::-1]:
        print(f'开始抽{grade}'.center(50, '-'))
        res_list = random.sample(users_list, counts)

        # 将中奖的人从列表中删除
        for user in res_list:
            users_list.remove(user)

        info = f'恭喜{",".join(res_list)}!! 每人获得{goods}奖品!!'
        yield info


res = choujiang(data_list)

while True:
    choice = input('按下Y键进行抽奖！！  任意键退出')
    if choice.upper() == 'Y':
        try:
            a1 = res.__next__()
            print(a1)
        except:
            print('所有奖品全部抽完！！')
            break
    else:
        break

```



# 9、面向对象

## 9.1、面向对象概述

```markdown
1、面向过程开发：程序中实现的逻辑是我们一步一步参与实现的（参与者）
2、面向对象开发，是基于面向过程得来的思想，在程序中不断的创建对象，指挥对象做事情（指挥者）


举例：
	吃饭
	面向过程：自己买菜--自己洗菜--自己切菜--自己做菜--自己装盘--自己放到餐桌上
	面向对象：去饭店点菜--后厨人员将菜做好放到你的面前

面向对象三大特征：
	封装
	继承
	多态(在python中的多态是比较隐晦的)
	抽象

世间万物皆为对象
任意一个事物，都可以从两个方面去描述，属性，行为
人：                              class person:
	属性：姓名，年龄                   成员变量：name,age
	行为：吃，睡，学习                  函数：eat()  sleep() study()
```

## 9.2、面向对象开发

### 9.2.1、语法格式

```python
# 如果没有类，并且想要实现一个发送邮件的功能
def send_email(xxx):
    pass

send_email(xxx)
send_email(xxx)
-------------------------------------------------
# 面向对象的思想，创建一个类，然后根据这个类（汽车图纸）创建若干个对象（具体的汽车对象）
# 定义类
class 类名:
    # 行为（函数）
    def xxx():
        pass
    ...


# 根据类创建对象
class Person:
    def send_email(name):
        print(f'发送邮件给{name}')

p1 = Person()  # 创建的第一个对象
p1.send_email('马云')
```

-----------------

> 上述代码调用方法的时候，会报错，原因是类中的函数定义的时候，第一个参数必须要有，并且叫self
>
> self,表示当前调用该函数的对象p1.send_email('马云')  self-->p1

```python
# 根据类创建对象
class Person:
    def send_email(self, name):
        print(f'发送邮件给{name}')


p1 = Person()  # 创建的第一个对象
p1.send_email('马云')
```

### 9.2.2、类中函数的定义

#### 9.2.2.1、示例1: 创建一个对象的情况

```python
class MessageInfo:
    def send_email(self,name):  # xxx.send_email('xxx')
        print(f'发送邮件给{name}')
        
    def send_phone_message(self,name):  
        print(f'发送手机短信给{name}')

m1 = MessageInfo()
m1.send_email('a1')
m1.send_phone_message('b1')
```

#### 9.2.2.2、示例2：创建两个对象的情况

```python
class MessageInfo:
    def send_email(self,name):  # xxx.send_email('xxx')
        print(f'发送邮件给{name}')
        
    def send_phone_message(self,name):  
        print(f'发送手机短信给{name}')

# 创建第一个对象
m1 = MessageInfo()
m1.send_email('a1')
m1.send_phone_message('b1')

# 创建第二个对象
m2 = MessageInfo()
m2.send_email('q1')
m2.send_phone_message('w1')
```

> 注意：每创建一次对象，在内存中会开辟一个新的内存空间，所以不同创建出来的对象，地址是不一样的

#### 9.2.2.3、示例3：创建一个类（人），有属性和行为

```python
class Person:
    def eat(self):
        print('吃饭')

    def call(self, name):
        print(f'打电话给{name}')


p1 = Person()
p1.eat()
p1.call('xiaohu')
p1.name = '张三' # p1对象自己造了一个属性叫做name,赋值'张三'
print(p1.name)


p2 = Person()
p2.eat()
p2.call('mayun')
# p2.name = '李四'
print(p2.name)
```

> 在类中没有给出属性的时候，造出来的对象想对自己创建什么属性，就创建什么属性，但是只针对自己对象有效

#### 9.2.2.4、示例4：

```
__init__用法  对应java中的构造方法
注意：python类中的__init__函数只能写一个，今后学习的java中的构造方法可以写多个
```

```python
# 需求：通过Peron类创建的任意一个对象，都有姓名和年龄
class Person:
    # python所有类中有一个内置函数可以让我们使用__init__
	def __init__(self,name,age):
        # 定义成员变量
		self.name = name
        self.age = age
    def eat(self):
        print('吃饭')

    def call(self, name):
        print(f'打电话给{name}')
	
# 创建对象的时候，类后面的小括号其实本质上就是调用类中的__init__()函数
p1 = Person('张三',18)
p1.eat()
p1.call('xiaohu')
print(p1.name)
print(p1.age)


p2 = Person('李四',16)
p2.eat()
p2.call('mayun')
print(p2.name)
print(p2.age)
```

## 9.3、面向对象开发的应用场景

### 9.3.1、解决了多参数的问题

```python
def fun1(a1,b1,c1,d1):
    pass

def fun2(a1,b1,c1,d1):
    pass

def fun3(a1,b1,c1,d1):
    pass

fun1(11,22,33,44)

fun2(11,22,33,44)

fun3(11,22,33,44)

---------------------------------
# 类中的其他函数要想使用对象的成员变量的话，使用self关键字来调用
class Demo:
    def __init__(self, a1, b1, c1, d1):
        self.a1 = a1
        self.b1 = b1
        self.c1 = c1
        self.d1 = d1


    def fun1(self):
        print(f'a1:{self.a1},b1:{self.b1},c1:{self.c1},d1:{self.d1}')

    def fun2(self):
        pass

    def fun3(self):
        pass

d1 = Demo(11, 22, 33, 44)
d1.fun1()
```

### 9.3.2、解决了数据封装的问题

```python
需求：用户注册，将用户注册的信息组成一个格式化的数据输出
'''
users_list = [
{'name':'张三','age':18},
{'name':'张三','age':18},
{'name':'张三','age':18}
]
'''
users_list = []
while True:
    username = input('输入用户名: ')
    if username.upper() == 'Q':
        break
    age = input('输入年龄: ')
    user_dict = {}
    user_dict['name'] = username
    user_dict['age'] = int(age)
    users_list.append(user_dict)

print(users_list)
```

------

> 用面向对象的思想改进

```python
'''
users_list = [
Pseron{'张三',18},
Pseron{'李四',16},
Pseron{'王五',17},
...
]
'''
class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

    def eat(self):
        print("吃饭")

    def sleep(self):
        print("睡觉")


users_list = []
while True:
    username = input('输入用户名: ')
    if username.upper() == 'Q':
        break
    age = input('输入年龄: ')
    # 将输入的用户封装成用户对象
    p1 = Person(username,age)
    users_list.append(p1)

print(users_list)
for person in users_list:
    print(f'姓名:{person.name}, 年龄:{person.age}')
    person.eat()
    person.sleep()
    print('-------------------------')
```

---

```python
class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

    def eat(self):
        print("吃饭")

    def sleep(self):
        print("睡觉")

    def show(self):
        print(f'姓名:{self.name}, 年龄:{self.age}')

users_list = []
while True:
    username = input('输入用户名: ')
    if username.upper() == 'Q':
        break
    age = input('输入年龄: ')
    # 将输入的用户封装成用户对象
    p1 = Person(username,age)
    users_list.append(p1)

print(users_list)
for person in users_list:
    person.show()
    person.eat()
    person.sleep()
    print('-------------------------')
```

```
def __str__(self):
	return f'姓名:{self.name}, 年龄:{self.age}'
上面的show函数可以使用类中的内置函数__str__进行替换，将来打印对象的时候，默认会调用类中__str__()函数
print(person)  # person = f'姓名:{self.name}, 年龄:{self.age}'
```

## 9.4、面向对象的三大特征

> 面向对象的三大特征：
>
> - 封装：将数据封装在对象中
> - 继承：'子类继承于父类'
> - 多态：某一个事物在不同状态下的体现，python而言，默认支持多态，因为python是动态数据类型的语言。

### 9.4.1 封装

- 将数据封装在对象中

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f'姓名:{self.name}, 年龄:{self.age}'


# 创建一个学生对象
s1 = Student('张三', 18)
print(s1)
s1.age = 1000
print(s1)
```

> 上述案例中，s1对象获取成员变量age是完全可以的，从python语法出发，赋值1000是没问题的，符合变量赋值的规范
>
> 但是，从实际情况出发，没有人能够活到1000岁，年龄赋值的时候，应该**判断一下**，如果合理才应该赋值
>
> 将这个判断一下，在类中定义一个函数

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f'姓名:{self.name}, 年龄:{self.age}'

    def set_age(self, age):
        if age > 150 or age < 0:
            print('年龄不合法，默认改为18')
            self.age = 18
        else:
            self.age = age


# 创建一个学生对象
s1 = Student('张三', 18)
print(s1)
# s1.age = 1000
# print(s1)
s1.set_age(1000)
print(s1)
```

> 提供了赋值的函数，不一定要用，依旧可以使用直接获取成员变量的方式进行赋值
>
> 解决方案：让外界获取不到这个成员变量，利用封装的思想解决，将成员变量变成私有

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        # 在成员变量前面加__表示将该成员变量变成私有的了，这个变量只能在当前类中可以访问
        self.__age = age

    def __str__(self):
        return f'姓名:{self.name}, 年龄:{self.__age}'

    def set_age(self, age):
        if age > 150 or age < 0:
            print('年龄不合法，默认改为18')
            self.__age = 18
        else:
            self.__age = age


# 创建一个学生对象
s1 = Student('张三', 18)
print(s1)
# s1.__age = 1000
# print(s1)
# print(s1.__age)
s1.set_age(20)
print(s1)
```

> 将来在python中创建一个类的时候，要有以下几个东西
>
> ```
> __init__()函数  构造一个对象的作用
> 
> __str__()函数  返回成员变量值的情况
> 
> 将成员变量进行私有化，在变量的前面加__
> 
> 提供成员变量对应的set_xxx()以及get_xxx()函数
> ```

```python
class Student:
    def __init__(self, name, age):
        self.__name = name
        # 在成员变量前面加__表示将该成员变量变成私有的了，这个变量只能在当前类中可以访问
        self.__age = age

    def __str__(self):
        return f'姓名:{self.name}, 年龄:{self.__age}'

    def set_age(self, age):
        self.__age = age
    
    def get_age(self):
        return self.__age
    
    def set_name(self, name):
        self.__name = name
    
    def get_name(self):
        return self.__name
```

### 9.4.2 继承

##### 示例1：继承的写法

```python
# Student 学生类
# 属性：学号 姓名 年龄 性别 班级  行为：学习，吃饭，睡觉

# HighStudent 高中生
# 属性：学号 姓名 年龄 性别 班级  行为：学习，吃饭，睡觉，考试
# Student 学生类
# 属性：学号 姓名 年龄 性别 班级  行为：学习，吃饭，睡觉
class Student:
    def __init__(self, sid, name, age, gender, clazz):
        self.sid = sid
        self.name = name
        self.age = age
        self.gender = gender
        self.clazz = clazz

    def __str__(self):
        return f'学号：{self.sid}, 姓名：{self.name}, 年龄：{self.age}, 性别：{self.gender}, 班级：{self.clazz}'

    def study(self):
        print("学习")

    def eat(self):
        print('吃饭')

    def sleep(self):
        print('睡觉')


# HighStudent 高中生
# 属性：学号 姓名 年龄 性别 班级  行为：学习，吃饭，睡觉，考试
class HighStudent:
    def __init__(self, sid, name, age, gender, clazz):
        self.sid = sid
        self.name = name
        self.age = age
        self.gender = gender
        self.clazz = clazz

    def __str__(self):
        return f'学号：{self.sid}, 姓名：{self.name}, 年龄：{self.age}, 性别：{self.gender}, 班级：{self.clazz}'

    def study(self):
        print("学习")

    def eat(self):
        print('吃饭')

    def sleep(self):
        print('睡觉')

    def exam(self):
        print('考试')


# 创建一个学生对象
s1 = Student(1001, '张三', 18, '男', '理科一班')
print(s1)

# 创建一个学生对象
s2 = HighStudent(1002, '李四', 17, '男', '理科二班')
print(s2)
```

----------------

> 如果没有继承的话，代码的冗余度会增加

```python
class 父类:
    pass

class 子类(父类):  # 子类继承自父类
    pass
--------------------
class Father:  # 父类  超类  基类
    pass 

class Son(Father): # 子类 派生类
    pass
```

```python
# Student 学生类
# 属性：学号 姓名 年龄 性别 班级  行为：学习，吃饭，睡觉
class Student:
    def __init__(self, sid, name, age, gender, clazz):
        self.sid = sid
        self.name = name
        self.age = age
        self.gender = gender
        self.clazz = clazz

    def __str__(self):
        return f'学号：{self.sid}, 姓名：{self.name}, 年龄：{self.age}, 性别：{self.gender}, 班级：{self.clazz}'

    def study(self):
        print("学习")

    def eat(self):
        print('吃饭')

    def sleep(self):
        print('睡觉')


# HighStudent 高中生
# 属性：学号 姓名 年龄 性别 班级  行为：学习，吃饭，睡觉，考试
class HighStudent(Student):
    def exam(self):
        print('考试')


# 创建一个学生对象
s1 = Student(1001, '张三', 18, '男', '理科一班')
print(s1)

print('----------')
# 创建一个学生对象
s2 = HighStudent(1002, '李四', 17, '男', '理科二班')
print(s2)
s2.eat()
s2.study()
s2.sleep()
```

> **子类继承父类之后，子类拥有了父类中的东西，并且子类还可以定义父类没有的东西**

##### 示例2：继承的注意事项

- 父类中无法使用子类中的功能

```python
#  Student 学生类
# 属性：学号 姓名 年龄 性别 班级  行为：学习，吃饭，睡觉
class Student:
    def __init__(self, sid, name, age, gender, clazz):
        self.sid = sid
        self.name = name
        self.age = age
        self.gender = gender
        self.clazz = clazz

    def __str__(self):
        return f'学号：{self.sid}, 姓名：{self.name}, 年龄：{self.age}, 性别：{self.gender}, 班级：{self.clazz}'

    def study(self):
        print("学习")

    def eat(self):
        print('吃饭')

    def sleep(self):
        print('睡觉')


# HighStudent 高中生
# 属性：学号 姓名 年龄 性别 班级  行为：学习，吃饭，睡觉，考试
class HighStudent(Student):
    def exam(self):
        print('考试')


# 创建一个学生对象
s1 = Student(1001, '张三', 18, '男', '理科一班')
print(s1)
s1.eat()
s1.study()
s1.sleep()
s1.exam() # 报错！！ 父类中无法使用子类中的功能

print('----------')
# 创建一个学生对象
s2 = HighStudent(1002, '李四', 17, '男', '理科二班')
print(s2)
s2.eat()
s2.study()
s2.sleep()
s2.exam()
```

- 子类要想使用父类中的东西，通过super()的方式

```python
class HighStudent(Student):
    def __init__(self, sid, name, age, gender, clazz):
        super().__init__(sid, name, age, gender, clazz)  # super()代表的是父亲类

    def exam(self):
        print('考试')


# 创建一个学生对象
s1 = Student(1001, '张三', 18, '男', '理科一班')
print(s1)
print('----------')
# 创建一个学生对象
s2 = HighStudent(1002, '李四', 17, '男', '理科二班')
print(s2)
```

--------------------

```python
class HighStudent(Student):
    def __init__(self, sid, name, age, gender, clazz):
        super().__init__(sid, name, age, gender, clazz)  # super()代表的是父亲类

    def exam(self):
        print('考试')


# 创建一个学生对象
s1 = Student(1001, '张三', 18, '男', '理科一班')
print(s1)
print('----------')
# 创建一个学生对象
s2 = HighStudent(1002, '李四', 17, '男', '理科二班')
print(s2)
```

- super()的用法，一般是用作在子类中的函数内部，访问父类中的类成员

```python
# Student 学生类
# 属性：学号 姓名 年龄 性别 班级  行为：学习，吃饭，睡觉
class Student:
    # 类变量
    a1 = 200

    def __init__(self, sid, name, age, gender, clazz):
        # 成员变量
        self.sid = sid
        self.name = name
        self.age = age
        self.gender = gender
        self.clazz = clazz

    def __str__(self):
        return f'学号：{self.sid}, 姓名：{self.name}, 年龄：{self.age}, 性别：{self.gender}, 班级：{self.clazz}'

    def study(self):
        # 局部变量
        a2 = 1000
        print("学习")

    def eat(self):
        print('吃饭')

    def sleep(self):
        print('睡觉')


# HighStudent 高中生
# 属性：学号 姓名 年龄 性别 班级  行为：学习，吃饭，睡觉，考试
class HighStudent(Student):
    # a1 = 12.34
    # def __init__(self, sid, name, age, gender, clazz):
    #     super().__init__(sid, name, age, gender, clazz)  # super()代表的是父亲类

    def exam(self):
        a1 = 'hello world'
        print('考试')
        print(super().a1)  # 先在函数内部找，找不到，在类成员找，找不到再去父类类成员找，如果都找不到报错。


# 创建一个学生对象
s1 = Student(1001, '张三', 18, '男', '理科一班')
print(s1)
print('----------')
# 创建一个学生对象
s2 = HighStudent(1002, '李四', 17, '男', '理科二班')
print(s2)
print(s2.a1) # 子类可以使用父类中的类成员变量
s2.exam()
```

##### 示例3：子类可以创建父类没有的成员变量

```python
# 普通员工：工号 姓名 化名 职位 薪资
class Staff:
    def __init__(self, sid, name, new_name, job, salary):
        self.sid = sid
        self.name = name
        self.new_name = new_name
        self.job = job
        self.salary = salary

    def __str__(self):
        return f'工号：{self.sid}, 姓名：{self.name}, 化名：{self.new_name}, 职位：{self.job}, 薪资：{self.salary}'

    def work(self):
        print('工作')


# 组长：   工号 姓名 化名 职位 薪资 奖金
class Leader(Staff):
    def __init__(self, sid, name, new_name, job, salary, common):
        super().__init__(sid, name, new_name, job, salary)
        self.common = common

    def __str__(self):
        return f'工号：{self.sid}, 姓名：{self.name}, 化名：{self.new_name}, 职位：{self.job}, 薪资：{self.salary}, 奖金：{self.common}'


# 创建一个普通员工对象
s1 = Staff('sj1001', '张三', '张三丰', '大数据开发工程师', 8500)
print(s1)

# 创建一个组长对象
s2 = Leader('sj1002', '李四', '韩立', '高级大数据开发工程师', 18000, 20000)
print(s2)
```

##### 示例4：继承多个类

```python
class Demo1:
    def fun1(self):
        print('aaaa')


class Demo2:
    def fun2(self):
        print('bbbb')


class Demo3(Demo1, Demo2):
    def fun3(self):
        print('cccc')


d1 = Demo3()
d1.fun2()
```

-----------------

```python
class Demo1:
    def fun1(self):
        print('aaaa')


class Demo2:
    def fun1(self):
        print('bbbb')


class Demo3(Demo2, Demo1):  # 先找左边类Demo2中的函数
    def fun3(self):
        print('cccc')


d1 = Demo3()
d1.fun1()
```



### 9.4.3 多态

```python
python默认支持多态
```

##### 示例1：

```python
一个事物的多种状态
动物类
老虎类继承自动物类
狮子类继承自动物类

class Animal:
    pass
class Tiger(Animal):
    pass
class Lion(Animal):
    pass

s1 = Tiger()
s2 = Lion()


Animal a1 = new Tiger();
```

##### 示例2：参数类型的问题

```python
class Demo:
    def fun1(self, s1):
        print(s1.upper())


d1 = Demo()
d1.fun1('hello')
d1.fun1(100)
```

### 9.4.4 抽象

```python
# 定义一个动物类
class Animal:
    @abstractmethod
    def eat(self):
        pass


class Dog(Animal):
    @override
    def eat(self):
        print('狗吃肉')


class Cat(Animal):
    @override
    def eat(self):
        print('🐱吃🐟')


d1 = Dog()
d1.eat()

c1 = Cat()
c1.eat()
```

## 9.5、常见类中的内置函数

```
__init__()  构造对象（构造函数）
```

```
__str__()   用于输出对象的时候，调用该函数，一般用作格式化输出
```

## 9.6、类变量

```python
# 类变量在创建对象的时候会复制一份给到子类对象
class Demo:
    a1 = 100

    def fun1(self):
        print('hello world')


d1 = Demo()
print(Demo.a1)


d2 = Demo()
print(Demo.a1)
print('--------------')
d1.a1 = 200
print(Demo.a1)
print(d1.a1)
```



# 10、正则表达式

## 10.1、什么是正则表达式

- 正则表达式是独立于任何一门语言的技术，不依赖于其他语言的
- 本质上一个字符串，只不过有些符号被赋予了特殊的含义，可以让我们使用该字符串对其他的字符串进行查找，匹配，切割，替换等操作

```python
text = '博主讲的实在是太好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或者是xiaohu2023666@pronton.com谢谢博主 手机微信号也可以 17354074069'

text2 = '我的邮箱是1165872335@qq.com 谢谢博主'

需求1：查询文本中的邮箱
需求2：查询文本中的手机号
```

## 10.2、正则表达式的感受

```python
# 需求1实现：
import re

text = '博主讲的实在是太好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或者是xiaohu2023666@pronton.com谢谢博主 手机微信号也可以 17354074069'

res1 = re.findall(r'\w+@\w+\.\w+', text, re.ASCII)
print(res1)  # ['1165872335@qq.com','xiaohu2023666@pronton.com']
```

```python
# 需求2实现
import re

text = '博主讲的实在是太好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或者是xiaohu2023666@pronton.com谢谢博主 手机微信号也可以17354074069'

# res1 = re.findall(r'\w+@\w+\.\w+', text, re.ASCII)
res1 = re.findall(r'\d{11}', text)
print(res1)  # ['17354074069']
```

## 10.3、写正则表达式的流程

- 有大量的文本
- 寻找规律（需要消耗大量的时间）
- 根据过滤和正则语法编写正则表达式

## 10.4、正则表达式语法

### 10.4.1 字符相关的语法

- 固定的文本字符串本身其实就是一个正则表达式

```python
import re

text = '大大撒旦问起我xiaohu dwdwqe请问请问xiaohu666,请问xiaohuABC,我xiaohq'
res1 = re.findall('xiaohu', text)
print(res1)  # ['xiaohu', 'xiaohu', 'xiaohu']
```

- 包含字符 []  判断包含某一个

```python
import re

text = '大大撒旦问起我xiaohu dwdwqe请问请问xiaohu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
res1 = re.findall(r'xiaoh[uq]', text)
print(res1)  # ['xiaohu', 'xiaohu', 'xiaohu', 'xiaohq', 'xiaohq']
```

- 含有特殊字符 [0-9]

```python
import re

text = '大大撒旦问起我xiaohu dwdwqe请问请问xiaohu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
res1 = re.findall(r'xiaohu[0-9]', text)
print(res1)  # ['xiaohu6']
```

- 含有特殊字符 [a-z]

```python
import re

text = '大大撒旦问起我xiaohu dwdwqe请问请问xiaohu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
res1 = re.findall(r'xiaohu[a-z]', text)
print(res1)  # []
```

- 含有特殊字符 [a-z]

```python
import re

text = '大大撒旦问起我xiaohu dwdwqe请问请问xiaohu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
res1 = re.findall(r'xiaohu[A-Z]', text)
print(res1)  # ['xiaohuA']
```

```python
import re

text = '大大撒旦问起我xiaohuq dwdwqe请问请问xiaohu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
res1 = re.findall(r'xiaohu[A-z]', text)
print(res1)  # ['xiaohuq', 'xiaohuA']
```

- \d 表示数字 0-9任意一个

```python
import re

text = '博主讲的实在是太好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或者是xiaohu2023666@pronton.com谢谢博主 手机微信号也可以17354074069'
# raw string
res1 = re.findall(r'xiaohu\d', text)
print(res1) # ['xiaohu2']
```

------------

```python
import re

text = '博主讲的实在是太好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或者是xiaohu2023666@pronton.com谢谢博主 手机微信号也可以17354074069'
# raw string
res1 = re.findall(r'xiaohu\d\d\d\d', text)
print(res1) # ['xiaohu2023']
```

----------

> {n}  n表示紧跟着大括号的符号出现了n次

```python
import re

text = '博主讲的实在是太好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或者是xiaohu2023666@pronton.com谢谢博主 手机微信号也可以17354074069'
# raw string
res1 = re.findall(r'xiaohu\d{7}', text)
print(res1) # ['xiaohu2023666']
```

----

```python
import re

text = '博主讲的实在是太好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或者是xiaohu2023666@pronton.com谢谢博主 手机微信号也可以17354074069'
# raw string
res1 = re.findall(r'\d{11}', text)
print(res1) # ['17354074069']
```

---------

```python
import re

text = '博主讲的15354074069实在是太好了，通俗易懂，18354074069 已三连，求课件，我139xxx的邮箱是 1165872335@qq.com ' \
       '或者是xiaohu2023666@pronton.com谢谢博主 手机微信号也可以17354074069'
# raw string
# 183  153  173
res1 = re.findall(r'1[857]3\d{8}', text)
print(res1)  # ['17354074069']
```

> {n, } 表示匹配n个及n个以上

```python
import re

text = '博主讲的15354074069实在是太好了，通俗易懂，18354074069 已三连，求课件，我139xxx的邮箱是 1165872335@qq.com ' \
       '或者是xiaohu2023666@pronton.com谢谢博主 手机微信号也可以17354074069987654321'
# raw string
# 183  153  173
res1 = re.findall(r'1[857]3\d{8,}', text)
print(res1)  # ['17354074069']
```

> {n, m} n表示最小匹配次数  m表示最大匹配次

```python
import re

text = '博主讲的15354074069实在是太好了，通俗易懂，18354074069 已三连，求课件，我139xxx的邮箱是 1165872335@qq.com ' \
       '或者是xiaohu2023666@pronton.com谢谢博主 手机微信号也可以17354074069987654321'
# raw string
# 183  153  173
res1 = re.findall(r'1[857]3\d{8,12}', text)
print(res1)  # ['17354074069']
```

- 表示数量次数

  - ？表示出现了0次或者1次

  ```python
  import re
  
  text = '大大 xiaohu 撒旦问起我xiaohuw dwdwqe请问请问xiaohu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
  # raw string
  # 183  153  173
  res1 = re.findall(r'xiaohu\w?', text)
  print(res1)  # ['xiaohu', 'xiaohuw', 'xiaohu6', 'xiaohuA']
  ```

  

  - `+`表示出现了1次或者n次

  ```python
  import re
  
  text = '大大 xiaohu 撒旦问起我xiaohuw dwdwqe请问请问xiaohu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
  # raw string
  # 183  153  173
  res1 = re.findall(r'xiaohu\w+', text)
  print(res1)  # ['xiaohuw', 'xiaohu666', 'xiaohuABC']
  ```

  

  - *表示出现了0次或者n次

  ```python
  import re
  
  text = '大大 xiaohu 撒旦问起我xiaohuw dwdwqe请问请问xiaohu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
  # raw string
  # 183  153  173
  res1 = re.findall(r'xiaohu\w*', text)
  print(res1)  # ['xiaohu', 'xiaohuw', 'xiaohu666', 'xiaohuABC']
  ```

- \w 大小写字母 数字 下划线 汉字

```python
import re

text = '大大 xiaohu 撒旦问起我xiaohuw dwdwqe请问请问xiaohu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
# raw string
# 183  153  173
res1 = re.findall(r'xiaohu\w*', text)
print(res1)  # ['xiaohu', 'xiaohuw', 'xiaohu666', 'xiaohuABC']
```

-----------

```python
import re

text = '大大 xiao汉hu 撒旦问起我xiaoQhuw dwdwqe请问请问xiao_hu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
# raw string
# 183  153  173
res1 = re.findall(r'xiao\whu', text)
print(res1)  # ['xiao汉hu', 'xiaoQhu', 'xiao_hu']
```

- \W 除了大小写字母 数字 下划线 汉字，匹配其他字符

```python
import re

text = '大大 xiao汉hu 撒旦问起我xiao@huw dwdwqe请问请问xiao hu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
# raw string
# 183  153  173
res1 = re.findall(r'xiao\Whu', text)
print(res1)  # ['xiao@hu', 'xiao hu']
```

- `.` 表示任意字符

```python
import re

text = '大大 xiao汉hu 撒旦问起我xiao@huw dwdwqe请问请问xiao hu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
# raw string
# 183  153  173
res1 = re.findall(r'xiao.hu', text)
print(res1)  # ['xiao汉hu', 'xiao@hu', 'xiao hu']
```

-------------

> 匹配原生字符.的方式

```python
import re

text = '大大 xiao.hu 撒旦问起我xiao@huw dwdwqe请问请问xiao hu666,请问xiaohuABC,我xiaohq,请问xiaohqu'
# raw string
# 183  153  173
res1 = re.findall(r'xiao\.hu', text)
print(res1)  # ['xiao汉hu', 'xiao@hu', 'xiao hu']
```

### 10.4.2 正则表达式使用的注意事项

-  在使用数量相关语法的正则情况下，默认python使用的是贪婪匹配

```python
import re
text = '博主讲的实在是太好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或者是xiaohu2023666@pronton.com谢谢博主 手机微信号也可以17354074069'

# res1 = re.findall(r'\w+@\w+\.\w+', text, re.ASCII)
res1 = re.findall(r'xiaohu\d{5}', text)
print(res1)
```

----

```python
import re
text = '博主讲的实在是太好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或者是xiaohu2023666@pronton.com谢谢博主 手xiaohu2机微信号也可以17354074069'

# res1 = re.findall(r'\w+@\w+\.\w+', text, re.ASCII)
res1 = re.findall(r'xiaohu\d+', text)
print(res1)
```

### 10.4.3 正则进阶使用

- （）分组

```python
import re

text = '我的身份证号是：32012320001231987X，还有一个人的身份证是320123200110059879，手机号是17332012325'  # ['2000','2001']
res = re.findall(r'320123(\d{4})\w{7}[\dX]',text)
print(res)  # ['2000', '2001']
```

-----------

```python
import re

text = '我的身份证号是：32012320001231987X，还有一个人的身份证是320123200110059879，手机号是17332012325'  # ['2000','2001']
res = re.findall(r'(320123(\d{4})\w{7}[\dX])', text)
print(res)  # [('32012320001231987X', '2000'), ('320123200110059879', '2001')]
```

---------

```python
import re

text = '我的身份证号是：32012320001231987X，还有一个人的身份证是320123200110059879，手机号是17332012325'  # ['2000','2001']
res = re.findall(r'(320123(\d{4})(\w{2})(\w{2})\w{3}[\dX])', text)
print(res)  # [('32012320001231987X', '2000', '12', '31'), ('320123200110059879', '2001', '10', '05')]
```

- 或

```python
import re

text = '博主讲的实在是太1165872335@数加$.com好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或' \
       '者是xiaohu2023666@pronton.com谢谢博主 手xiaohu2机微信号也可以17354074069'
res = re.findall(r'(\w+@(数加\$|qq|pronton)\.com)',text)
print(res)  # [('博主讲的实在是太1165872335@数加$.com', '数加$'), ('1165872335@qq.com', 'qq'), ('或者是xiaohu2023666@pronton.com', 'pronton')]
```

----------------

- ^ 以xx为首的

```python
import re

text = '博主讲的实在是太1165872335@数加$.com好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或' \
       '者是xiaohu2023666@pronton.com谢谢博主 手xiaohu2机微信号也可以17354074069'
res = re.findall(r'(\w+@(数加\$|qq|pronton)\.com)',text)
print(res)  # [('博主讲的实在是太1165872335@数加$.com', '数加$'), ('1165872335@qq.com', 'qq'), ('或者是xiaohu2023666@pronton.com', 'pronton')]
```



- $以xxx结尾

```python
import re

text = '博主讲的实在是太1165872335@数加$.com好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或' \
       '者是xiaohu2023666@pronton.com谢谢博主 手xiaohu2机微信号也可以17354074069'
res = re.findall(r'([a-z0-9]+@(数加\$|qq|pronton)\.com)',text)
print(res)  # [('博主讲的实在是太1165872335@数加$.com', '数加$'), ('1165872335@qq.com', 'qq'), ('或者是xiaohu2023666@pronton.com', 'pronton')]

# text = '1165872335@qq.com'
# res = re.findall(r'^1\d+@\w+\.com$', text)
# print(res)
```

### 10.4.4 re模块的函数

- findall() 在大字符串中查找所有符合正则表达式规则的小串，返回一个符合结果的列表
- search() 从左向右匹配，智慧匹配一次

```python
import re

text = '博主讲的实在是太1165872335@qq.com好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或' \
       '者是xiaohu2023666@pronton.com谢谢博主 手xiaohu2机微信号也可以17354074069'

res = re.search(r'[a-z0-9]+@\w+\.\w+', text, re.ASCII)
print(res.group()) # '1165872335@qq.com'
```

- match() 从左向右，从第一个字符就开始匹配，如果第一个字符不符合，停止匹配，返回None

```python
import re

text = '博主讲的实在是太1165872335@qq.com好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或' \
       '者是xiaohu2023666@pronton.com谢谢博主 手xiaohu2机微信号也可以17354074069'

# res = re.search(r'[a-z0-9]+@\w+\.\w+', text, re.ASCII)
# print(res.group())

res = re.match(r'[a-z0-9]+@\w+\.\w+', text, re.ASCII)
print(res)  # None
```

-----

```python
text = '1165872335@qq.com好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或' \
       '者是xiaohu2023666@pronton.com谢谢博主 手xiaohu2机微信号也可以17354074069'

# res = re.search(r'[a-z0-9]+@\w+\.\w+', text, re.ASCII)
# print(res.group())

res = re.match(r'[a-z0-9]+@\w+\.\w+', text, re.ASCII)
print(res.group())  # '1165872335@qq.com'
```

- split()

```python
import re

text = '1165872335@qq.com好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或' \
       '者是xiaohu2023666@pronton.com谢谢博主 手xiaohu2机微信号也可以17354074069'
res = re.split(r'@qq|pronton',text)  
print(res) # ['1165872335', '.com好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335', '.com 或者是xiaohu2023666@', '.com谢谢博主 手xiaohu2机微信号也可以17354074069']
```

- 其他函数

```python
# re.fullmatch() # 匹配整个字符串是否符合正则表达式
# re.finditer()  # 返回的是一个可以迭代的对象
```

### 10.4.5 re对象模式

```python
import re

text = '1165872335@qq.com好了，通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或' \
       '者是xiaohu2023666@pronton.com谢谢博主 手xiaohu2机微信号也可以17354074069'

# 将正则表达式编译成一个对象
re_obj = re.compile(r'1\d+@\w+\.com')
res = re_obj.findall(text)
print(res)

text2 = '通俗易懂，已三连，求课件，我的邮箱是 1165872335@qq.com 或' \
       '者是xiaohu2023666@pronton.com谢谢博主 手xiaohu2机微信号也可以17354074069'

res2 = re_obj.findall(text2)
print(res2)
```

## 





# Python爬虫项目基础知识

## 一、爬虫与数据分析

### 1.1 Python中的requests库

#### Requests 库的安装

Win 平台：“以管理员身份运行” cmd，执行 pip install requests，等待安装

Requests 库的安装小测

![image-20240118171338025](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171338025.png)

#### Requests 库的 get() 方法

![image-20240118171354536](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171354536.png)

response  *n*. 响应；反应；回答
 Response 对象包含服务器返回的所有信息，也包含请求的 Request 信息

```csharp
r = requests.get( url , params=None , **kwargs )
//---url：拟获取页面的 url 链接
//---params：url 中的额外参数，字典或字节流格式，可选
//---**kwargs：12 个控制访问的参数
```

**[补充]**：参考 get 方法的文档可以看出 get 方法使用了 request 方法进行封装，也就是说 request 库一共提供 7 常用方法，除了第一个 request 方法外，其它的 6 个方法都是通过调用 request 方法实现的。其实也可以这样认为 requests 库其实只有一个方法，就是 request 方法，但是为了让大家编写程序更方便，提供了额外 6 个方法。

**Requests 库的 2 个重要对象**

![image-20240118171405196](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171405196.png)

**Response 对象的属性**：

|        属性         |                       说明                       |
| :-----------------: | :----------------------------------------------: |
|    r.status_code    | HTTP请求的返回状态, 200表示连接成功, 404表示失败 |
|       r.text        | HTTP响应内容的字符串形式，即, url对应的页面内容  |
|     r.encoding      |      从HTTP header中猜测的响应内容编码方式       |
| r.apparent_encoding |  从内容中分析出的响应内容编码方式(备选编码方式)  |
|      r.content      |             HTTP响应内容的二进制形式             |

r.status_code：只要不是200其实都是连接失败的  ！！！！

![image-20240118171414007](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171414007.png)

在使用 get 方法获取网上资源的基本流程：

![image-20240118171420242](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171420242.png)

理解 Response 的编码：

>- r.encoding：编码方式是从 http 的 heder 中的 charset 字段获得的，如果 header 中不存在 charset，则默认认为编码为 ISO-8859-1，这样的编码不能解析中文。r.text 根据 r.encoding 显示网页内容
>- r.apparent_encoding：根据 http 的内容部分，而不是头部分，去分析内容中出现文本可能的编码形式。即根据网页内容分析出的编码方式, 可以看作是 r.encoding 的备选

![image-20240118171429462](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171429462.png)

![image-20240118171439275](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171439275.png)

>为什么将 r.apparent_encoding 解析出来的编码方式赋给 r.encoding 后，网页中的中文就可以分析出来，难道 r.text 是以 r.encoding 的方式进行编码的吗？为什么头部分析出来的编码方式会与内容解析出来的不同？
>答：r.text 是以 r.encoding 的方式进行编码

#### 爬取网页的通用代码框架

在介绍爬取网页的通用代码框架之前，我们需要理解 Requests 库的异常

![image-20240118171447618](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171447618.png)

r.raise_for_status()：在方法内部判断 r.status_code 是否等于 200，不需要增加额外的 if 语句，该语句便于利用 try-except 进行异常处理，如果状态码不是200，产生异常 requests.HTTPError。

```python
import requests
def getHTMLText(url):
    try:
        r = requests.get(url)
        r.raise_for_status()
        r.encoding = r.apparent_encoding
        return r.text
    except:
        # print(r.status_code)
        return "产生异常！"
if __name__=="__main__":
    url = "http://www.baidu.com"
    print(getHTMLText(url))
```

#### HTTP 协议及 Requests 库方法

HTTP，HyperText Transfer Protocol，超文本传输协议。是一个基于 “请求与响应” 模式的、无状态的应用层协议。无状态指的是第一次请求与第二次请求之间并没有相关的关联。HTTP 协议采用 URL 作为定位网络资源的标识。

URL 格式如下：http://host[:port\][path]
       host：合法的 Internet 主机域名或 IP 地址
       port：端口号，缺省端口为 80
       path：请求资源的路径
 HTTP 实例：http://www.bit.edu.cn
        http://220,181,111,188/duty

文件的路径一样，只不过这个文件不在电脑里，在 internet 上，那每一个 URL，对应了 internet 上的一个数据资源。

HTTP 协议对资源的操作

![image-20240118171454085](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171454085.png)

**理解 PATCH 和 PUT 的区别**
 假设 URL 位置有一组数据 UserInfo，包括 UserID、UserName 等20个字段
 需求：用户修改了 UserName，其他不变。
 采用 PATCH，仅向 URL 提交 UserName 的局部更新请求。
 采用 PUT，必须将所有 20 个字段一并提交到 URL，未提交字段被删除。
 PATCH 的最主要好处：节省网络带宽（当 URL 对应的资源是很庞大资源的时候）

![image-20240118171500682](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171500682.png)

**HTTP 协议与 Requests 库**

![image-20240118171508561](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171508561.png)

**Requests 库的 head() 方法**

![image-20240118171518220](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171518220.png)

- r.headers : 以字典对象存储服务器响应头，但是这个字典比较特殊，字典键不区分大小写，若键不存在则返回 None

#### Requests 库主要方法解析

**Requests 库的 7 个主要方法**：

|        方法        |                     说明                      |
| :----------------: | :-------------------------------------------: |
| requests.request() |     构造一个请求,支撑以下各方法的基础方法     |
|   requests.get()   |    获取HTML网页的主要方法,对应于HTTP的GET     |
|  requests.head()   |   获取HTML网页头信息的方法,对应于HTTP的HEAD   |
|  requests.post()   | 向HTML网页提交POST请求的方法,对应于HTTP的POST |
|   requests.put()   |  向HTML网页提交PUT请求的方法,对应于HTTP的PUT  |
|  requests.patch()  | 向HTML网页提交PUT请求的方法,对应于HTTP的PATCH |
| requests.delete()  |   向HTML页面提交删除请求,对应于HTTP的DELETE   |



```css
requests.request(method, url, **kwargs)
```

- method：请求方式，对应get/put/post等七种
  - `r = requests. request('GET', url, **kwargs)`
  - `r = requests.request('HEAD', url, **kwargs)`
  - `r = requests.request('POST', url, **kwargs)`
  - `r = requests.request('PUT', url, **kwargs)`
  - `r = requests.request('PATCH', url, **kwargs)`
  - `r = requests.request('delete', url, **kwargs)`
  - `r = requests.request('OPTIONS', url, **kwargs)`
- OPTIONS：向服务器获取一些服务器跟客户端能够打交道的参数，并不与获取资源直接相关。
- url：拟获取页面的url链接
- **kwargs：控制访问的参数，共 13 个
  - params：字典或字节序列，作为参数增加到ur1中
  - data：字典、字节序列或文件对象，作为Request的内容
  - json：JSON格式的数据，作为Request的内容
  - headers：字典，HTTP定制头
  - cookies：字典或CookieJar，Request中的cookie
  - auth：元组，支持HTTP认证功能
  - files：字典类型，传输文件
  - timeout：设定超时时间，秒为单位
  - proxies：字典类型，设定访问代理服务器，可以增加登录认证
  - redirects：True/False，默认为 True，重定向开关
  - stream：True/False，默认为 True，获取内容立即下载开关
  - verify：True/False，默认为 True，认证 SSL 证书开关
  - cert：本地 SSL 证书路径

使用示例：

```dart
kv = {'cn': '导演', 'pcn': '娱乐明星'}
r = requests.request('GET', 'http://tieba.baidu.com/f/index/forumpark', params=kv)
r.encoding = r.apparent_encoding
print(r.url)
```

这两种方法是等价的：
 `r = requests.request("get", "http://www.baidu.com")`
 `r = requests.get("http://www.baidu.com")`



```rust
fs = {'file':open('data.x1s','rb')}
r = requests.request('pOST','http://python123.io/ws',files=fs) 
pxs = { 'http':'http://xxx:xxx'
        'https':'https://xxxx:xxx'         }
r = requests.request('GET','http://www.baidu.com',proxies=pxs) 
```

http 协议中，向某一个 url 提交资源的功能在服务器上是严格受控的，因为这存在很大的安全问题。

网络爬虫的尺寸：

|  小规模，数据量小  |  中规模，数据规模较大  | 大规模，搜索引擎 |
| :----------------: | :--------------------: | :--------------: |
|   爬取速度不敏感   |      爬取速度敏感      |   爬取速度关键   |
|    Requests 库     |       Scrapy 库        |     定制开发     |
| 爬取网页、玩转网页 | 爬取网站、爬取系列网站 |     爬取全网     |

### 1.2	python中的json库

- json数据是一种只包含双引号的字符串格式，任何对象经过json序列化后单引号也会转成双引号。

```obj
import json

dic={'name':'xiaohu'}
print(json.dumps(dic))   #{"name": "xiaohu"}

i=8
print(json.dumps(i))   # 8
print(type(json.dumps(i)))  #<class 'str'>

s='hello'
print(json.dumps(s))   #"hello"
print(type(json.dumps(s)))  #<class 'str'>

l=[12,34]
print(json.dumps(l))   #[11, 22]
```

- JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：

  | JSON类型   | Python类型    |
  | ---------- | ------------- |
  | {}         | dict          |
  | []         | list          |
  | "string"   | str           |
  | 数字       | int 或者float |
  | true/false | True/False    |
  | null       | None          |

- dumps()和loads()函数

```obj
f=open('序列化对象','w')
f.write(j)  #-------------------打开、写入两步等价于json.dump(dic,f)
f.close()
#-----------------------------反序列化<br>
import json
f=open('序列化对象')
data=json.loads(f.read())   #  打开、读两步等价于data=json.load(f)
```

- 无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads
- json.dumps()中的ensure_ascii=False

在使用json.dumps时要注意一个问题

![image-20240118171535061](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171535061.png)

输出的会是
 '中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

![image-20240118171544569](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171544569.png)

**python数据格式切换json的方法**

>json.dumps(data)            python ---->json  数据格式转换
>
>json.dump(data, filename)   python ---->json 将转换后的数据保存到filename文件中
>
>json.loads(data)           json  --->python 数据格式转换
>
>json.load(data, filename)     json  --->python  将转换后的数据保存到filename文件中

### 1.3	xpath学习之python中lxml库

#### html了解

超文本标记语言，是用来描述网页的一种语言。主要用于控制数据的显示和外观。**HTML文档一定意义上可以被称为网页**。但反过来说网页不仅仅是HTML，网页本质有三部分构成：负责内容结构的HTML，负责表现的CSS，以及负责行为的javascript。本文主要分享的是最核心的内容结构部分。

#### html结构

完整的HTML文件至少包括<HTML>标签、<HEAD>标签、<TITLE>标签和<BODY>标签，并且这些标签都是成对出现的，开头标签为<>，结束标签为</>，在这两个标签之间添加内容。通过这些标签中的相关属性可以设置页面的背景色、背景图像等。
 例如，我们打开豆瓣首页，摁下键盘上的F12键，打开浏览器自带**“开发者工具”**，可以看到一个完整的html文档结构，如下图

![image-20240118171552633](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171552633.png)

从上图可以看出，一个完整的html文档主要包含三部分：**DTD文档头，head头部信息和body正文信息**。其中DTD文档头用来告诉浏览器执行标准是什么（比如html4或是html5），head头部信息用来说明浏览器的编码方式和文档头名称，body顾名思义就是浏览器的正文部分。

#### html标签

作为开始和结束的标记，由尖括号包围的关键词，比如 <html>，标签对中的第一个标签是开始标签，第二个标签是结束标签。html中常见标签如下：

![image-20240118171601142](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171601142.png)



其中， “< ul >< li ></li ></ul >”是一种嵌套顺序，无序列表，成对出现；li的父元素必须是ul或者ol，不同之处在于ol是一种有序列列表，而ul是无序列表；

#### html属性

属性是用来修饰标签的，放在开始标签里里面，html中常见四大属性：

| 属性  |                      说明                      |
| :---: | :--------------------------------------------: |
| class | 规定元素的类名，大多数时候用于指定样式表中的类 |
|  id   | 唯一标识一个元素的属性，在html里面必须是唯一的 |
| href  |              指定超链接目标的url               |
|  src  |                 指定图像的url                  |

### 1.4xpath

#### xpath定义

是一种路径查询语言，简单的说就是利用一个路径表达式从html文档中找到我们需要的数据位置，进而将其写入到本地或者数据库中。（可以将xpath类比为sql结构化查询语言）

#### xpath常见使用方法

|  符号  |                         功能                          |
| :----: | :---------------------------------------------------: |
|   //   |         表示在整个文本中查找，是一种相对路径          |
|   /    |      表示则表示从根节点开始查找，是一种绝对路径       |
| text() |                      找出文本值                       |
|   @    | 找出标签对应的属性值，比如@href就是找出对应的href链接 |
|   .    |                     表示当前节点                      |
|   ..   |                 表示当前节点的父节点                  |

当然xpath除了上述常见用法外，还存两种比较特殊的用法：以相同的字符开头；标签套标签。

> 用法1：**以相同的字符开头：starts-with(@属性部分，属性字符相同部分**

> 用法2：**标签套标签：string(.)**

```xml
#以相同的字符开头
#比如我们想同时提取到下列html中三条文本内容的话，就需要使用starts-with方法
html1 = """
<!DOCTYPE html>
<html>
 <head lang='en'>
    <meta charest='utf-8'>
    <title></title>
 </head>
 <body>
    <div id="test-1">需要的内容1</div>
    <div id="test-2">需要的内容2</div>
    <div id="testfault">需要的内容3</div>
 </body>
</html>
"""
    
#爬取代码
from lxml import etree
selector = etree.HTML(html1)
content  = selector.xpath('//div[starts-with(@id,"test")]/text()')
for each in content:
    print each
```

还有一种是标签套标签形式，参考如下例子

```xml
html2 = """
<!DOCTYPE html>
<html>
 <head lang='en'>
    <meta charest='utf-8'>
    <title></title>
 </head>
 <body>
    <div id="test3">
    我左青龙,
        <span id='tiger'>
            右白虎
            <ul>上朱雀,
                <li>下玄武,</li>
            </ul>
        </span>
        龙头在胸口
    </div>
 </body>
</html>
"""
#如果我们想爬取的内容是html文档中的所有文本的话，需要使用string方法进行提取
selector2 = etree.HTML(html2)
content2  = selector2.xpath('//div[@id="test3"]')[0] #列表，只有一个元素
info = content2.xpath('string(.)')
content3 = info.replace('\n','').replace(' ','')
print content3
```

#### xpath的谓语结构

所谓"谓语条件"，就是对路径表达式的附加条件。所有的条件，都写在方括号"[]"中，表示对节点进行进一步的筛选。例如：

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<bookstore>
  <book>
    <title lang="eng">Harry Potter</title>
    <price>29.99</price>
  </book>
  <book>
    <title lang="eng">Learning XML</title>
    <price>39.95</price>
  </book>
     <book>
    <title lang="eng">Harry Potter</title>
    <price>29.99</price>
  </book>
  <book>
    <title lang="eng">Learning XML</title>
    <price>39.95</price>
  </book>
     <book>
    <title lang="eng">Harry Potter</title>
    <price>29.99</price>
  </book>
  <book>
    <title lang="eng">Learning XML</title>
    <price>39.95</price>
  </book>
</bookstore>
```

下面从几个简单的例子让大家体会一下

- /bookstore/book[1] ：表示选择bookstore的第一个book子元素。
- /bookstore/book[last()] ：表示选择bookstore的最后一个book子元素。
- /bookstore/book[last()-1] ：表示选择bookstore的倒数第二个book子元素。
- /bookstore/book[position()<3] ：表示选择bookstore的前两个book子元素。
- //title[@lang] ：表示选择所有具有lang属性的title节点。
- //title[@lang='eng'] ：表示选择所有lang属性的值等于"eng"的title节点。

```
<tr>
  <td valign="top">
    <input type="radio" name="payment" value="1" checked="" iscod="0">
  </td>
  <td valign="top">
    <strong>数加科技</strong>
  </td>
</tr>
```

```
//strong[text()="数加科技"]/../../td[1]/input
```

| 函数        | 说明                           | 举例                                                         |
| ----------- | ------------------------------ | ------------------------------------------------------------ |
| contains    | 选取属性或者文本包含某些字符   | **//div[contains(@id, 'data')]** 选取 id 属性包含 data 的 div 元素  **//div[contains(string(), '支付宝')]** 选取内部文本包含“支付宝”的 div 元素 |
| starts-with | 选取属性或者文本以某些字符开头 | **//div[starts-with(@id, 'data')]** 选取 id 属性以 data 开头的 div 元素  **//div[starts-with(string(), '银联')]** 选取内部文本以“银联”开头的 div 元素 |
| ends-with   | 选取属性或者文本以某些字符开头 | **//div[ends-with(@id, 'require')]** 选取 id 属性以 require 结尾的 div 元素  **//div[ends-with(string(), '支付')]** 选取内部文本以“支付”结尾的 div 元素 |



### 1.5  表格操作openpyxl

用于读取和写入 **Excel 2010** *xlsx*/*xlsm*/*xltx*/*xltm* 文件。通过 `pip install openpyxl` 命令下载 [openpyxl](https://links.jianshu.com/go?to=https%3A%2F%2Fpypi.org%2Fproject%2Fopenpyxl%2F) 库。

#### 演示代码

通过下面的演示代码，可以快速创建一个名为 *sample.xlsx* 的表格文件：

```python
from openpyxl import Workbook
import datetime

# 创建一个工作簿
wb = Workbook()
# 获取活动工作表
ws = wb.active
# 数据可以直接分配到单元格
ws['A1'] = 42
# 行也可以追加
ws.append([1, 2, 3])
# Python类型将自动转换
ws['A2'] = datetime.datetime.now()
# 保存文件
wb.save("sample.xlsx")
```

![image-20240118171613207](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171613207.png)

#### 创建工作簿

不需要提前在文件系统上创建文件，直接就可以使用 `openpyxl` 开始创建表格。先导入 `Workbook` 类，再使用 `Workbook.active` 方法获取一个工作表：

```python
from openpyxl import Workbook
wb = Workbook()
ws = wb.active
```

默认情况下 `Workbook.active(value)` 方法中的 `value` 为 **0**，即使用此方法获得第一个工作表，我们可以修改此值。也可以使用 `Workbook.create_sheet()` 方法创建新的工作表：

```python
# 在末尾插入（默认）
ws1 = wb.create_sheet("Mysheet")
# 插入第一个位置
ws2 = wb.create_sheet("Mysheet", 0)
# 倒数第二个位置插入
ws3 = wb.create_sheet("Mysheet", -1)
```

我们可以随时通过 `Worksheet.title` 属性更改工作表名称：

```python
ws.title = "New Title"
```

给工作表命名后，就可以将其作为工作簿的键值，以指向对应的工作表，并可以使用 `Workbook.sheetname` 属性查看工作簿中所有工作表的名称，亦可以遍历工作表：

```python
ws3 = wb["New Title"]

print(wb.sheetnames)  # ['Sheet2', 'New Title', 'Sheet1']

for sheet in wb:
    print(sheet.title)
```

我们可以复制某个工作簿，创建一个副本。该行为仅复制单元格（值、样式、超链接、注释）和某些工作表属性（尺寸、格式、属性），如果工作簿以 *read-only* 或 *write-only* 只读模式打开，则不能复制工作表：

```python
source = wb.active
target = wb.copy_worksheet(source)
```

#### 操作数据

单元格可以直接作为工作表中的键值进行访问，例如返回 *A4* 处的单元格，如果不存在则创建一个单元格，可以直接分配值：

```python
c = ws['A4']
ws['A4'] = 4
```

#### 一个单元格

通过 `Worksheet.cell()` 方法可以使用 **行** 和 **列** 定位要访问的单元格：

```python
d = ws.cell(row=4, column=2, value=10)
```

#### 多个单元格

我们可以通过切片访问单元格范围，行或列的范围可以用类似方法获得：

```python
cell_range = ws['A1':'C2']
colC = ws['C']
col_range = ws['C:D']
row10 = ws[10]
row_range = ws[5:10]
```

也可以使用 `Worksheet.iter_rows()` 或 `Worksheet.iter_cols()` 方法获取行、列，但是由于性能原因，这两个方法在 *只读* 模式下不可用：

```python
for row in ws.iter_rows(min_row=1, max_col=3, max_row=2):
    for cell in row:
        print(cell)
# <Cell Sheet1.A1>
# <Cell Sheet1.B1>
# <Cell Sheet1.C1>
# <Cell Sheet1.A2>
# <Cell Sheet1.B2>
# <Cell Sheet1.C2>
for col in ws.iter_cols(min_row=1, max_col=3, max_row=2):
    for cell in col:
        print(cell)
# <Cell Sheet1.A1>
# <Cell Sheet1.A2>
# <Cell Sheet1.B1>
# <Cell Sheet1.B2>
# <Cell Sheet1.C1>
# <Cell Sheet1.C2>
```

如果需要遍历所有行或列，则可以使用 `Worksheet.rows` 或 `Worksheet.columns` 属性，但是同样在 *只读* 模式下不可用：

```python
ws = wb.active
ws['C9'] = 'hello world'
tuple(ws.rows)
# ((<Cell Sheet.A1>, <Cell Sheet.B1>, <Cell Sheet.C1>),
# (<Cell Sheet.A2>, <Cell Sheet.B2>, <Cell Sheet.C2>),
# (<Cell Sheet.A3>, <Cell Sheet.B3>, <Cell Sheet.C3>),
# (<Cell Sheet.A4>, <Cell Sheet.B4>, <Cell Sheet.C4>),
# (<Cell Sheet.A5>, <Cell Sheet.B5>, <Cell Sheet.C5>),
# (<Cell Sheet.A6>, <Cell Sheet.B6>, <Cell Sheet.C6>),
# (<Cell Sheet.A7>, <Cell Sheet.B7>, <Cell Sheet.C7>),
# (<Cell Sheet.A8>, <Cell Sheet.B8>, <Cell Sheet.C8>),
# (<Cell Sheet.A9>, <Cell Sheet.B9>, <Cell Sheet.C9>))
tuple(ws.columns)
# ((<Cell Sheet.A1>,
# <Cell Sheet.A2>,
# <Cell Sheet.A3>,
# <Cell Sheet.A4>,
# <Cell Sheet.A5>,
# <Cell Sheet.A6>,
# ...
# <Cell Sheet.C9>))
```

#### 仅值

如果只需要工作表中的值，则可以使用 `Worksheet.columns` 属性，这会遍历工作表中的所有行，但仅返回单元格的值：

```python
for row in ws.values:
    for value in row:
        print(value)
```

通过 `Worksheet.iter_rows()` 并 `Worksheet.iter_cols()` 可以获取 `values_only` 参数，只返回单元格的值：

```python
for row in ws.iter_rows(min_row=1, max_col=3, max_row=2, values_only=True):
    print(row)
# (None, None, None)
# (None, None, None)
```

如果我们只需要工作表的 *最大行数* 和 *最大列数*，可以使用 `max_row` 和 `max_column` 属性获取，例如一个4行15列的工作表：

```python
print(ws.max_row)  # 4
print(ws.max_column)  # 15
```

#### 数据存储

有了 `Cell` 就可以为其分配一个值：

```python
c.value = 'hello, world'
print(c.value)  # 'hello, world'
d.value = 3.14
print(d.value)  # 3.14
```

#### 保存到文件

保存工作簿的最简单、安全的方法是使用对象的 `Workbook.save()` 方法：

```python
wb = Workbook()
wb.save('balances.xlsx')
```

如果文件已经存在，此操作将覆盖现有文件，不会抛出异常或警告。

#### 另存为流

如果要将文件保存到流中，例如在使用Web应用程序（*Pyramid*、*Flask*、*Django*）时，只需使用 `NamedTemporaryFile()` 方法即可：

```python
from tempfile import NamedTemporaryFile
from openpyxl import Workbook
wb = Workbook()
with NamedTemporaryFile() as tmp:
    wb.save(tmp.name)
    tmp.seek(0)
    stream = tmp.read()
```

我们也可以指定属性 `template=True`，将工作簿另存为模板：

```python
wb = load_workbook('document.xlsx')
wb.template = True
wb.save('document_template.xltx')
```

或将 `template` 属性设置为 `False`（默认），以另存为文档：

```python
wb = load_workbook('document_template.xltx')
wb.template = False
wb.save('document.xlsx', as_template=False)
```

#### 从文件加载

可以通过 `openpyxl.load_workbook()` 打开现有的工作簿：

```python
from openpyxl import load_workbook
wb2 = load_workbook('test.xlsx')
print(wb2.sheetnames)  # ['Sheet2', 'New Title', 'Sheet1']
```

### 1.5 python中的时间库time

```dart
import time
store_date = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(int(time.time())))
print("今天是 beijingriqi_%s,%s" % (store_date, 'asda'))
```

```csharp
[output]:
今天是 beijingriqi_2022-04-17 23:30:43,asda
```

## 二、可视化

### 2.1 matplotlib模块学习

> 快速安装

```bash
pip install matplotlib
```

#### 2.2.1 折线图

```python
import matplotlib.pyplot as plt
import random

x=range(10) # 定义x轴的数据 列表的数据类型
y=[random.uniform(15,35) for i in x] # 定义y轴的数据  # 列表的数据类型


plt.plot(x, y) # 绘制图像
plt.savefig('a1.png') # 保存图像 在当前目录保存名为test.png的图片，必须在show方法前否则图片就是空白
# plt.show() # 展示图像

```

![image-20240118171629356](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171629356.png)

##### a. 设置画布大小：

> 我们使用`plt.figure()`函数来设置画布大小，其参数如下：
>
> - figsize : 设置画布的大小，单位英寸 长，宽
> - dpi : 设置清晰度

```python
import matplotlib.pyplot as plt
import random

x=range(10) # 定义x轴的数据
y=[random.uniform(15,35) for i in x] # 定义y轴的数据

plt.figure(figsize=(20,8),dpi=80) # 设置画布大小与清晰度

plt.plot(x, y) # 绘制图像
plt.show() # 展示图像
```

![image-20240118171637095](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171637095.png)

##### b. 自定义x轴、y轴刻度

> `xticks`,`yticks`使用自定义刻度的函数，它有两个参数：
>
> - ticks：要显示x轴的刻度
> - labels：给对应的x刻度设置一个标签，并且覆盖之前的刻度，与传入ticks的列表长度要相等。

>  x轴每隔2两个数显示

```python
import matplotlib.pyplot as plt
import random

x=range(10) # 定义x轴的数据
y=[random.uniform(15,35) for i in x] # 定义y轴的数据

plt.figure(figsize=(20,8),dpi=80) # 设置画布大小与清晰度

plt.xticks(x[::1]) # 定义显示的x轴步长为1

plt.plot(x, y) # 绘制图像
plt.show() # 展示图像
```

![image-20240118171644583](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171644583.png)

##### c. x轴显示中文

> matplotlib默认字体是不支持中文的需要更改，有多种方法，现在只提供一种

```python
import matplotlib.pyplot as plt
import random

x=range(10) # 定义x轴的数据
y=[random.uniform(15,35) for i in x] # 定义y轴的数据

plt.figure(figsize=(20,8),dpi=80) # 设置画布大小与清晰度

plt.xticks(x[::2],["1月","2月","3月","4月","5月"]) # 第二个参数可以指定显示字符串，不过传入xticks的这两个参数长度要相等

plt.plot(x, y) # 绘制图像
plt.show() # 展示图像
```

![image-20240118171652537](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171652537.png)

> 修改matplotlib默认字体，使它支持显示中文
>
> 方法一：

```python
import matplotlib.pyplot as plt
import random

plt.rcParams['font.sans-serif']=['SimHei']  # 用来正常显示中文标签

x=range(10) # 定义x轴的数据
y=[random.uniform(15,35) for i in x] # 定义y轴的数据

plt.figure(figsize=(20,8),dpi=80) # 设置画布大小与清晰度

plt.xticks(x[::2],["1月","2月","3月","4月","5月"]) # 第二个参数可以指定显示字符串，不过传入xticks的这两个参数长度要相等

plt.plot(x, y) # 绘制图像
plt.show() # 展示图像
```

> 方法二：

```python
修改全局字体样式，需要使用 matplotlib 模块的 rcParams

from matplotlib import rcParams

rcParams['font.family'] = 'SimHei' # 黑体
```

> 常用字体

```
宋体：SimSun
黑体：SimHei
微软雅黑：Microsoft YaHei
微软正黑体：Microsoft JhengHei
新宋体：NSimSun
新细明体：PMingLiU
细明体：MingLiU
标楷体：DFKai-SB
仿宋：FangSong
楷体：KaiTi
隶书：LiSu
幼圆：YouYuan
华文细黑：STXihei
华文楷体：STKaiti
华文宋体：STSong
华文中宋：STZhongsong
华文仿宋：STFangsong
方正舒体：FZShuTi
方正姚体：FZYaoti
华文彩云：STCaiyun
华文琥珀：STHupo
华文隶书：STLiti
华文行楷：STXingkai
华文新魏：STXinwei
```

##### d. 轴标签和标题

> `xlabel`、`ylabel`使用修改x,y轴标签
>
> `title`可修改标题

```python
import matplotlib.pyplot as plt
import random

plt.rcParams['font.sans-serif']=['SimHei']  # 用来正常显示中文标签

x=range(10) # 定义x轴的数据
y=[random.uniform(15,35) for i in x] # 定义y轴的数据

plt.figure(figsize=(20,8),dpi=80) # 设置画布大小与清晰度

plt.xticks(x[::2],["1月","2月","3月","4月","5月"]) # 第二个参数可以指定显示字符串，不过传入xticks的这两个参数长度要相等

plt.xlabel("时间变化") # 修改标签
plt.ylabel("温度变化")

plt.title("我是标题") # 修改标题

plt.plot(x, y) # 绘制图像
plt.show() # 展示图像
```

![image-20240118171701090](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171701090.png)

##### e. 添加网格线

> `grid`方法来设置图表中的网格线

```python
import matplotlib.pyplot as plt
import random

plt.rcParams['font.sans-serif']=['SimHei']  # 用来正常显示中文标签

x=range(60) # 定义x轴的数据
y=[random.uniform(15,18) for i in x] # 定义y轴的数据

plt.figure(figsize=(20,8),dpi=80) # 设置画布大小与清晰度

plt.plot(x, y) # 绘制图像

plt.xticks(x[::5],["{}分钟".format(i) for i in x][::5]) # 第二个参数可以指定显示字符串，不过传入xticks的这两个参数长度要相等
plt.yticks(range(0,40,5)) # 自定义y轴刻度
plt.xlabel("时间变化") # 修改标签
plt.ylabel("温度变化")

plt.title("我是标题") # 修改标题

# 增加网格显示，0.5表示透明度为50%
plt.grid(linestyle="--",alpha=0.5)


plt.show() # 展示图像
```

![image-20240118171710232](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171710232.png)

##### f. 同一图中同时绘制多条折线

> 只是数据多准备一份罢了，基本什么区别
> 例外再添加上图例`legend`，可读性更好

```python
import matplotlib.pyplot as plt
import random

plt.rcParams['font.sans-serif']=['SimHei']  # 用来正常显示中文标签

x=range(60) # 定义x轴的数据
y_1=[random.uniform(15,18) for i in x] # 定义y轴的数据
y_2=[random.uniform(1,3) for i in x] # 定义y轴的数据

plt.figure(figsize=(20,8),dpi=80) # 设置画布大小与清晰度

plt.plot(x, y_1,label="上海") # 绘制图像
plt.plot(x, y_2,label="北京") # 绘制图像

plt.xticks(x[::5],["{}分钟".format(i) for i in x][::5]) # 第二个参数可以指定显示字符串，不过传入xticks的这两个参数长度要相等
plt.yticks(range(0,40,5)) # 自定义y轴刻度

plt.xlabel("时间变化") # 修改标签
plt.ylabel("温度变化")

plt.title("我是标题") # 修改标题

# 增加网格显示，0.5表示透明度为50%
plt.grid(linestyle="--",alpha=0.5)



plt.legend() #绘制图例

plt.show() # 展示图像
```

![image-20240118171718829](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171718829.png)

##### g. 同时绘制两个图

```python
import matplotlib.pyplot as plt
import random

plt.rcParams['font.sans-serif']=['SimHei']  # 用来正常显示中文标签
plt.rcParams['axes.unicode_minus'] = False  # 用来正常显示负号

# x,y轴的数据
x=range(60)
y_shanghai=[random.uniform(15,18) for i in x]
# 另一个城市
y_beijing=[random.uniform(1,3) for i in x]

'''
fig 表示的是要绘制的一个画布，
ax 表示的是在fig这个画布的对象上，具体要绘制的对象子图。
'''
fig, ax = plt.subplots(1,2,figsize=(20,8),dpi=80) # 把画布分成一行两列

ax[0].plot(x,y_shanghai,'b--',label='上海') 
ax[1].plot(x,y_beijing,'r',label='北京')

# 图例，必须在plot后面 简单显示图例
ax[0].legend()
ax[1].legend()
# 修改x y刻度
x_label=["11点{}分".format(i) for i in range(60)]
ax[0].set_xticks(x[::5],x_label[::5])
ax[0].set_yticks(range(0,40,5))

ax[1].set_xticks(x[::5],x_label[::5])
ax[1].set_yticks(range(0,40,5))
# 增加网格显示
ax[0].grid(linestyle="--",alpha=0.5)

ax[1].grid(linestyle="--",alpha=0.5)

# 添加描述信息
ax[0].set_xlabel('时间变化')
ax[0].set_ylabel('温度变化')
ax[0].set_title('上海城市11点到12点每分钟的温度变化状况1')

ax[1].set_xlabel('时间变化')
ax[1].set_ylabel('温度变化')
ax[1].set_title('北京城市11点到12点每分钟的温度变化状况2')
plt.show()
```

![image-20240118171725665](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171725665.png)

##### h. 绘制数学函数图像

```python
import matplotlib.pyplot as plt
import numpy as np; 

x=np.linspace(-10,10,1000000)
y=x**2

plt.figure(figsize=(8,8),dpi=80)
plt.grid(linestyle='--',alpha=0.5)
plt.plot(x,x**2) 
plt.show()
```

![image-20240118171741397](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171741397.png)

##### i. 设置字体大小

> 在前面的例子中感觉显示的字体太小了，看的不舒服，现在来设置一下。
> 通过`plt.rcParams['font.size']=18`来指定字体的大小

```python
import matplotlib.pyplot as plt
import random

plt.rcParams['font.sans-serif']=['SimHei']  # 用来正常显示中文标签
plt.rcParams['font.size']=18  # 设置字体大小
x=range(60) # 定义x轴的数据
y=[random.uniform(15,18) for i in x] # 定义y轴的数据

plt.figure(figsize=(20,8),dpi=80) # 设置画布大小与清晰度

plt.plot(x, y) # 绘制图像

plt.xticks(x[::5],["{}分钟".format(i) for i in x][::5]) # 第二个参数可以指定显示字符串，不过传入xticks的这两个参数长度要相等
plt.yticks(range(0,40,5)) # 自定义y轴刻度
plt.xlabel("时间变化") # 修改标签
plt.ylabel("温度变化")

plt.title("我是标题") # 修改标题

# 增加网格显示，0.5表示透明度为50%
plt.grid(linestyle="--",alpha=0.5)


plt.show() # 展示图像
```

![image-20240118171753445](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171753445.png)

#### 2.2.2 散点图绘制

> 主要使用`scatter`方法来绘制散点图，参数如下：
> 参数说明：
>
> - x，y：长度相同的数组，也就是我们即将绘制散点图的数据点，输入数据。
> - s：点的大小，默认 20，也可以是个数组，数组每个参数为对应点的大小。
> - c：点的颜色，默认蓝色 'b'，也可以是个 RGB 或 RGBA 二维行数组。
> - marker：点的样式，默认小圆圈 'o'。
> - cmap：Colormap，默认 None，标量或者是一个 colormap 的名字，只有 c 是一个浮点数数组的时才使用。如果没有申明就是 image.cmap。
> - norm：Normalize，默认 None，数据亮度在 0-1 之间，只有 c 是一个浮点数的数组的时才使用。
> - vmin，vmax：：亮度设置，在 norm 参数存在时会忽略。
> - alpha：：透明度设置，0-1 之间，默认 None，即不透明。
> - linewidths：：标记点的长度。
> - edgecolors：：颜色或颜色序列，默认为 'face'，可选值有 'face', 'none', None。
> - plotnonfinite：：布尔值，设置是否使用非限定的 c ( inf, -inf 或 nan) 绘制点。
> - **kwargs：：其他参数。

```python
import matplotlib.pyplot as plt
import numpy as np
plt.rcParams['font.size'] = 18
x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
y = np.array([1, 4, 9, 16, 7, 11, 23, 18])
sizes = np.array([20,50,100,200,500,1000,60,90])
plt.figure(figsize=(8,8),dpi=80)
plt.scatter(x,y,s=sizes) # 绘制散点图
plt.show()

# 注意：散点图的数据是一维矩阵 并非是列表数据类型
```

![image-20240118171805569](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171805569.png)

#### 2.2.3 柱状图

> 主要使用 `bar() `方法来绘制柱形图。
> bar() 方法语法格式如下：
>
> - x：浮点型数组，柱形图的 x 轴数据。
> - height：浮点型数组，柱形图的高度。
> - width：浮点型数组，柱形图的宽度。
> - bottom：浮点型数组，底座的 y 坐标，默认 0。
> - align：柱形图与 x 坐标的对齐方式，'center' 以 x 位置为中心，这是默认值。 'edge'：将柱形图的左边缘与 x 位置对齐。要对齐右边缘的条形，可以传递负数的宽度值及 align='edge'。
> - **kwargs：：其他参数。

```python
import matplotlib.pyplot as plt
import numpy as np
plt.rcParams['font.sans-serif']=['SimHei']  # 用来正常显示中文标签
movie_names = ['雷神3：诸神黄昏','正义联盟','东方快车谋杀案','寻梦环游记','全球风暴', '降魔传','追捕','七十七天','密战','狂兽','其它']
tickets = [73853,57767,22354,15969,14839,8725,8716,8318,7916,6764,52222]
x = range(len(movie_names))

plt.figure(figsize=(20,8),dpi=80)
plt.bar(x,tickets,color=['b','g','r','c','m','y','k'])
plt.xticks(x,movie_names)
plt.title('电影票房收入对比')
plt.grid(linestyle='--',alpha=0.5)
plt.show()
```

![image-20240118171821841](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171821841.png)

##### a. 多组柱状图

```python
import matplotlib.pyplot as plt
import numpy as np


plt.rcParams['font.sans-serif']=['SimHei']  # 用来正常显示中文标签
plt.rcParams['axes.unicode_minus'] = False  # 用来正常显示负号

movie_name = ['雷神3:诸神黄昏','正义联盟','寻梦环游记']
first_day = [10587.6,10062.5,1275.7]
first_weekend=[36224.9,34479.6,11830]

plt.figure(figsize=(20,8),dpi=80)

x=range(len(movie_name))
plt.bar(x,first_day,width=0.2,label='首日票房') # 绘制第一组柱状图
plt.bar([i+0.2 for i in x],first_weekend,width=0.2,label='首周票房') # 绘制第二组柱状图

plt.legend() # 绘制图例

plt.xticks([i+0.1 for i in x],movie_name) # 修改x轴刻度

plt.show()
```

![image-20240118171829046](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171829046.png)

##### b. 垂直水平方向的柱状图

> 垂直方向的柱状图可以使用`barh()` 方法来设置：

```python
import matplotlib.pyplot as plt

x = ["Runoob-1", "Runoob-2", "Runoob-3", "C-RUNOOB"]
y = [12, 22, 6, 18]
plt.figure(figsize=(20,8),dpi=80)
plt.barh(x,y)
plt.show()
```

![image-20240118171836316](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171836316.png)

#### 2.2.4 直方图

> 使用`hist()`方法来绘制直方图

```python
import matplotlib.pyplot as plt

plt.rcParams['font.sans-serif']=['SimHei']  # 用来正常显示中文标签
plt.rcParams['axes.unicode_minus'] = False  # 用来正常显示负号import matplotlib.pyplot as plt

# 电影时长分布状况
time = [131,  98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, 142, 127, 130, 124, 101, 110, 116, 117, 110, 128, 128, 115,  99, 136, 126, 134,  95, 138, 117, 111,78, 132, 124, 113, 150, 110, 117,  86,  95, 144, 105, 126, 130,126, 130, 126, 116, 123, 106, 112, 138, 123,  86, 101,  99, 136,123, 117, 119, 105, 137, 123, 128, 125, 104, 109, 134, 125, 127,105, 120, 107, 129, 116, 108, 132, 103, 136, 118, 102, 120, 114,105, 115, 132, 145, 119, 121, 112, 139, 125, 138, 109, 132, 134,156, 106, 117, 127, 144, 139, 139, 119, 140,  83, 110, 102,123,107, 143, 115, 136, 118, 139, 123, 112, 118, 125, 109, 119, 133,112, 114, 122, 109, 106, 123, 116, 131, 127, 115, 118, 112, 135,115, 146, 137, 116, 103, 144,  83, 123, 111, 110, 111, 100, 154,136, 100, 118, 119, 133, 134, 106, 129, 126, 110, 111, 109, 141,120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126,114, 140, 103, 130, 141, 117, 106, 114, 121, 114, 133, 137,  92,121, 112, 146,  97, 137, 105,  98, 117, 112,  81,  97, 139, 113,134, 106, 144, 110, 137, 137, 111, 104, 117, 100, 111, 101, 110,105, 129, 137, 112, 120, 113, 133, 112,  83,  94, 146, 133, 101,131, 116, 111,  84, 137, 115, 122, 106, 144, 109, 123, 116, 111,111, 133, 150]
plt.figure(figsize=(20,8),dpi=80)

distince = 2 # 每组的间距
plt.hist(time,(max(time)-min(time))//distince)
plt.xticks(range(min(time),max(time)+2,distince))

plt.grid(linestyle='--',alpha=0.5)
plt.xlabel('电影时长大小')
plt.ylabel('电影的数据量')
plt.title("电影时长分布")
plt.show()
```

![image-20240118171844291](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171844291.png)

#### 2.2.5 饼图

> 使用 pyplot 中的 `pie()` 方法来绘制饼图。
> 参数说明：
>
> - x：浮点型数组，表示每个扇形的面积。
> - explode：数组，表示各个扇形之间的间隔，默认值为0。
> - labels：列表，各个扇形的标签，默认值为 None。
> - colors：数组，表示各个扇形的颜色，默认值为 None。
> - autopct：设置饼图内各个扇形百分比显示格式，%d%% 整数百分比，%0.1f 一位小数， %0.1f%% 一位小数百分比， %0.2f%% 两位小数百分比。
> - labeldistance：标签标记的绘制位置，相对于半径的比例，默认值为 1.1，如 <1则绘制在饼图内侧。
> - pctdistance：：类似于 labeldistance，指定 autopct 的位置刻度，默认值为 0.6。
> - shadow：：布尔值 True 或 False，设置饼图的阴影，默认为 False，不设置阴影。
> - radius：：设置饼图的半径，默认为 1。
> - startangle：：起始绘制饼图的角度，默认为从 x 轴正方向逆时针画起，如设定 =90 则从 y 轴正方向画起。
> - counterclock：布尔值，设置指针方向，默认为 True，即逆时针，False 为顺时针。
> - wedgeprops ：字典类型，默认值 None。参数字典传递给 wedge 对象用来画一个饼图。例如：wedgeprops={'linewidth':5} 设置 wedge 线宽为5。
> - textprops ：字典类型，默认值为：None。传递给 text 对象的字典参数，用于设置标签（labels）和比例文字的格式。
> - center ：浮点类型的列表，默认值：(0,0)。用于设置图标中心位置。
>   frame ：布尔类型，默认值：False。如果是 True，绘制带有表的轴框架。
>   rotatelabels ：布尔类型，默认为 False。如果为 True，旋转每个 label 到指定的角度。

```python
import matplotlib.pyplot as plt


plt.rcParams['font.sans-serif']=['SimHei']  # 用来正常显示中文标签
plt.rcParams['axes.unicode_minus'] = False  # 用来正常显示负号


movie_name = ['雷神3:诸神黄昏','正义联盟','东方快车谋杀案','寻梦环游记','全球风暴','降魔传','追捕','七十七天','密战','狂兽','其它']
place_count = [60605,54546,45819,28243,13270,9945,7679,6799,6101,4621,20105]
plt.figure(figsize=(20,8),dpi=80)
plt.pie(place_count,labels=movie_name,autopct='%1.2f%%')
plt.legend()
plt.axis('equal') # 确保饼图能化成一个圆
plt.show()
```

![image-20240118171851989](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171851989.png)

### 2.2 seaborn模块学习

> 下载模块

```shell
pip install seaborn
```

> 引入模块

```python
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
```

> 读取数据

```python
tips = pd.read_csv('tips.csv')
tips.head()
```

![image-20240118171900251](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171900251.png)

#### 2.2.1 relplot()函数

> seaborn.relplot()
> 这个函数功能非常强大，可以用来表示多个变量之间的关联关系。默认情况下是绘制散点图，也可以绘制线性图，具体绘制什么图形是通过kind参数来决定的。实际上以下两个函数就是relplot的特例：
> 散点类型：scatterplot -> relplot(kind="scatter")
> 线性类型：lineplot -> relplot(kind="line")

```
参数：

        x, y    vectors or keys in data

        指定x轴和y轴上位置的变量

        hue    vector or key in data

        将生成具有不同颜色的元素的分组变量。可以是按类别的（categorical），也可以是数字的，不过在后一种情况下，颜色映射的行为会有所不同。

        size    vector or key in data

        将生成不同大小元素的分组变量。可以是按类别的（categorical），也可以是数字的，在后一种情况下，大小映射的行为会有所不同。

        style   vector or key in data

        将生成具有不同样式的元素的分组变量。可以具有数字数据类型，但将始终被视为按类别的（categorical）。

        data    pandas.DataFrame, numpy.ndarray, mapping, or sequence

        输入数据结构。要么是可以分配给命名变量的向量的长形式集合，要么是将进行内部整形的宽形式数据集。

        row, col    vectors or keys in data

        定义要在不同面上绘制的子集的变量。

        col_wrap   int

        以该宽度“包裹”列变量，使列面跨越多行。与行方面不兼容。

        row_order, col_order   lists of strings

        按顺序组织网格中的行和/或列，否则将从数据对象推断顺序。

        palette   string, list, dict, or matplotlib.colors.Colormap

        映射色调时选择要使用的颜色的方法。字符串值传递给color_palete（）。List或dict值表示按类别的映射，而colormap对象表示数字映射。

        hue_order   vector of strings

        指定色调语义分类级别的处理和打印顺序。

        hue_norm    tuple or matplotlib.colors.Normalize

        以数据单位设置归一化范围的一对值，或将从数据单位映射到[0，1]区间的对象。用法意味着数字映射。

        sizes  list, dict, or tuple

        确定使用大小时如何选择大小的对象。它始终可以是大小值列表或大小变量到大小的dict映射级别。当大小为数字时，它也可以是一个元组，指定要使用的最小和最大大小，以便在此范围内规范化其他值。

        size_order   list

        指定大小变量级别的出现顺序，否则将根据数据确定。大小变量为数字时不相关。

        size_norm   tuple or Normalize object

        当尺寸变量为数字时，以数据单位进行归一化，以缩放打印对象。

        style_order  list

        指定样式变量级别的外观顺序，否则将根据数据确定。当样式变量为数字时不相关。

        dashes  boolean, list, or dictionary

        用于确定如何为样式变量的不同级别绘制线。设置为True将使用默认的破折号代码，或者可以将破折号代码列表或样式变量的字典映射级别传递给破折号代码。设置为False将对所有子集使用实线。破折号在matplotlib中指定：一个（段、间隙）长度的元组，或一个用于绘制实线的空字符串。

        markers  boolean, list, or dictionary

        确定如何为样式变量的不同级别绘制标记。设置为True将使用默认标记，或者可以将标记列表或将样式变量的字典映射级别传递给标记。设置为False将绘制无标记线。标记在matplotlib中指定。

        legend    “auto”, “brief”, “full”, or False

        如何绘制图例。如果“简短”，数字色调和大小变量将用均匀分布的值样本表示。如果“已满”，每组将在图例中获得一个条目。如果为“自动”，则根据级别数在简短表示或完整表示之间进行选择。如果为False，则不添加图例数据，也不绘制图例。

        kind  string

        Kind of plot to draw（这是一种要绘制的图）, corresponding to a seaborn relational plot. Options are {scatter and line}.

        height   scalar

        每个面的高度（英寸）

        aspect   scalar

       每个面的纵横比，因此纵横比*高度（aspect*height）表示每个面的宽度

        facet_kws  dict

        要传递到FacetGrid的其他关键字参数的字典.

        units  vector or key in data

        识别采样单位的分组变量。使用时，将为每个单元绘制一条具有适当语义的单独线，但不会添加图例条目。当不需要精确身份时，用于显示实验重复的分布。

        kwargs  key, value pairings

        其他关键字参数传递给底层plotting函数。

        Returns
```



##### 散点型

> 需求1：分析每周每天花销总额与小费的关系

```python
sns.relplot(x='total_bill',y='tip',data=tips).savefig('pngs/a1.png')
```

![image-20240118171909263](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171909263.png)

> 可以发现：消费越高，小费越高；小费集中在1-5之间



> 需求2：按天分析每天花销总额与小费的关系（分类 hue='day'）

```python
sns.relplot(x='total_bill',y='tip',data=data,hue='day').savefig('pngs/a1.png')
```

![image-20240118171916183](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171916183.png)

> 可以发现：星期六花销最高，对应的小费也越高



> 需求3：按午餐和晚餐分类并按天分析每天花销总额与小费的关系（col= 'time'）

```python
sns.relplot(x='total_bill',y='tip',data = data,hue='day',col='time').savefig('pngs/a1.png')
```

![image-20240118171923001](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171923001.png)



> 需求4：按性别分析午餐和晚餐，哪个性别付的小费最多（row='sex'）

```python
sns.relplot(x='total_bill',y='tip',data = data,hue='day',col='time',row='sex').savefig('pngs/a1.png')
```

![image-20240118171935877](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171935877.png)



##### 折线型

> 案例1：

```python
sns.relplot(x='total_bill',y='tip',data=data,kind='line').savefig('pngs/a1.png')
```

![image-20240118171944124](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171944124.png)



> 案例2：

```python
sns.relplot(x='total_bill',y='tip',data=data,kind='line',hue='day').savefig('pngs/a1.png')
```

![image-20240118171950370](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171950370.png)



> 案例3：

```python
sns.relplot(x='total_bill',y='tip',data=data,kind='line',hue='day',col='time').savefig('pngs/a1.png')
```

![image-20240118171957272](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118171957272.png)



> 案例4：

```python
sns.relplot(x='total_bill',y='tip',data=data,kind='line',hue='day',col='time',row='sex').savefig('pngs/a1.png')
```

![image-20240118172013711](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172013711.png)



> 案例5：

```python
sns.relplot(x="timepoint", y="signal", data=fmri, kind="line", errorbar=('ci', 60), hue="region", col="event",
            style="region").savefig('pngs/a1.png')
```

![image-20230105234308429](C:\Users\ASUS\Desktop\md笔记\爬虫项目之疫情数据可视化.assets\image-20230105234308429.png)



> 案例6：

```python
sns.relplot(x="timepoint",y="signal",data=fmri,kind="line",errorbar=('ci', 60),hue="region",col="event").savefig('pngs/a1.png')
```

![image-20240118172020864](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172020864.png)



> 案例七：

```python
sns.relplot(x="timepoint",y="signal",data=fmri,kind="line",errorbar=None,hue="region",col="event",style="region").savefig('pngs/a1.png')
```

![image-20240118172030195](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172030195.png)

#### 2.2.2 分类型绘图

> 分类统计图，则是根据分类，统计每个分类下的数据的个数或者比例。有以下几种方式：
> 条形图：barplot() (with kind="bar")
> 柱状图：countplot() (with kind="count")
> 点线图：pointplot() (with kind="point")

##### 条形图

> seaborn中的条形图具有统计功能，可以统计出比例，平均数，也可以按照你想要的统计函数来统计。

```python
sns.catplot(x='day',y='total_bill',data = data).savefig('pngs/a1.png')
```

![image-20240118172037852](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172037852.png)



```kotlin
sns.catplot(x='day',y='total_bill',data = data,hue='time').savefig('pngs/a1.png')
```

![image-20240118172044322](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172044322.png)



```python
sns.catplot(x='day',y='total_bill',data = data,hue='time',row = 'sex').savefig('pngs/a1.png')
```

![image-20240118172054172](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172054172.png)



```python
sns.catplot(x='day',y='total_bill',data = data,kind='bar').savefig('pngs/a1.png')
```

![image-20240118172102638](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172102638.png)



```python
sns.catplot(x='day',y='total_bill',data = data,kind='bar',estimator = sum).savefig('pngs/a1.png')
```

![image-20240118172110152](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172110152.png)



```python
sns.catplot(x='day',y='total_bill',data = data,kind='bar',estimator = sum,hue='time').savefig('pngs/a1.png')
```

![image-20240118172118200](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172118200.png)



```python
sns.catplot(x='day',y='total_bill',data = data,kind='bar',estimator = sum,hue='time',row='sex').savefig('pngs/a1.png')
```

![image-20240118172128621](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172128621.png)



#### 2.2.3 泰坦尼克号案例学习

> 需求1：分析男女获救比例

```python
data1 = pd.read_csv('titanic.csv')
sns.catplot(x='sex',y='survived',data=data1,kind='bar').savefig('pngs/a1.png')
```

![image-20240118172137365](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172137365.png)



> 需求2：按舱位分析，男女获救比例

```python
sns.catplot(x='sex',y='survived',data=data1,kind='bar',hue='class').savefig('pngs/a1.png')
```

![image-20240118172145105](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172145105.png)

> 可以发现：女性获救比例高于男性，说明人类在灾难面前，往往考虑更多的弱势群体。三等舱获救比例高于一二等舱，说明阶层越高获得的特权就越高

#### 2.2.4 箱体型绘图

```python
sns.boxplot(x='day',y='tip',data=data)
```

![image-20240118172153299](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172153299.png)

> 可以发现：以星期天为例，小费平均值为3，最高值将近7，最低值低于1，全天无异常值。



#### 2.2.5 分布型绘图

> sns.distplot()，bins柱子分布个数

> 需求1：泰坦尼克号，所有乘客年龄分布状况

```python
sns.distplot(data1['age'],bins=20)
```

![image-20240118172201301](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172201301.png)



> 需求2：二变量分布图

![](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172209388.png)

```python
sns.jointplot(x='total_bill',y='tip',data=data,kind='hex')
```

![image-20240118172235455](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172235455.png)



```python
'''
参数如下：
height图形大小设置
ratio主图和副图之间的比例
space 副图与主图之间的距离
'''

sns.jointplot(x='total_bill',y='tip',data=data,kind='hex',gridsize=15,height=10,ratio=3,space=0,marginal_kws={"rug":True,"kde":True},color="red")
```

![image-20240118172243222](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172243222.png)



##### 四变量两两关系分布图

```python
sns.pairplot(data)
```

![image-20240118172258576](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240118172258576.png)

### 2.3 pyecharts模块学习





# python爬虫之selenium自动化学习

## 一、selenium 概述

### 1.1 什么是selenium

```
Selenium是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Mozilla Firefox，Safari，Google Chrome，Opera，Edge等。这个工具的主要功能包括：测试与浏览器的兼容性——测试应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。支持自动录制动作和自动生成.Net、Java、Perl等不同语言的测试脚本。
```

### 1.2 selenium功能

```
1、框架底层使用JavaScript模拟真实用户对浏览器进行操作。测试脚本执行时，浏览器自动按照脚本代码做出点击，输入，打开，验证等操作，就像真实用户所做的一样，从终端用户的角度测试应用程序。
2、使浏览器兼容性测试自动化成为可能，尽管在不同的浏览器上依然有细微的差别。
3、使用简单，可使用Java，Python等多种语言编写用例脚本。
```

### 1.3 selenium的特点

```
1、可根据指令操控浏览器
2、只是工具，必须与第三方浏览器结合使用
```

## 二、selenium安装与环境配置(不要最新)

```python
pip install selenium==3.0.2
```

![image-20230106221941597](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106221941597.png)

> 选择使用的组合，以下三种方式安装一组即可: 

![image-20240119092541216](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240119092541216.png)

> - selenium + PhantomJS
> - selenium + chromedriver + Chrome
> - selenium + geckodriver + Firefox

> 火狐浏览器或者谷歌浏览器需要额外下载浏览器驱动器（注意版本号，教学使用谷歌浏览器）

```
chrome需要安装浏览器驱动器：chromedriver
Firefox需要安装浏览器驱动器：geckodriver
```

> 下载地址

> chromedriver：https://registry.npmmirror.com/binary.html?path=chrome-for-testing/
> geckodriver：https://github.com/mozilla/geckodrive/releases
> PhantomJS：https://phantomjs.org/downloqd.html

> 在设置中查看自己谷歌浏览器版本

![image-20230106213820546](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106213820546.png)

> 选择一个和自己浏览器版本比较近的

![image-20230106214021990](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106214021990.png)

![image-20230106214039765](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106214039765.png)

> 把解压后文件拷贝到python安装目录的Scripts目录下

![image-20230106215335095](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106215335095.png)

> 测试

```python
# 导入selenium的webdriver接口
from selenium import webdriver
# 1.创建浏览器对象 - 此时浏览器打开
browser = webdriver.Chrome()
# 2.输入百度地址并确认
browser.get('http://www.baidu.com/')
# 3.关闭浏览器
# browser.quit()
```

![image-20230106222048883](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106222048883.png)

## 三、selenium + Chrome组合使用

> 打开Chrome浏览器，并打开百度首页

```python
# 导入selenium的webdriver接口
from selenium import webdriver

# 1.创建浏览器对象 - 此时浏览器打开
browser = webdriver.Chrome()
# 2.输入百度地址并确认
browser.get('http://www.baidu.com/')
# 3.关闭浏览器
browser.quit()
```

> 输入关键字搜索，查看结果页

![image-20230106222455196](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106222455196.png)

```python
from selenium import webdriver

# 1、创建浏览器对象 - 打开浏览器
driver = webdriver.Chrome()
# 2、打开百度首页
driver.get('http://www.baidu.com/')
# 3、找到搜索框节点，并发送搜索关键字(写xpath语法)
driver.find_element_by_xpath('//*[@id="kw"]').send_keys('兰智数加')
# 4、找到 百度一下 按钮，并点击
driver.find_element_by_xpath('//*[@id="su"]').click()
```

> find_element_by_xpath函数可以直接通过xpath语法匹配页面内容

![image-20230106222625637](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106222625637.png)

## 四、Selenium常用函数

### 4.1 浏览器对象

> 浏览器对象browser常用方法及属性
> browser.get()：地址栏输入url地址并确认
> browser.quit()：关闭浏览器
> browser.close()：关闭当前页
> browser.gmaximize_window()：浏览器窗口最大化
> browser.page_source：HTML结构源码。（即前端的源码）
> browser.page_source.find(‘字符串’)：从源码中查找指定字符串，返回源码大概的位置。如果没有就返回-1，常用于判断最后一页

```
# 假设说网页非最后一页的“下一页”的源代码为class='pn-next'
# 网页最后一页的“下一页”的源代码为class='pn-next disabled'
browser.page_source.find('pn-next disabled') == -1		# 说明不是最后一页
```

### 4.2 定位节点

> 元素查找 - 返回值为节点对象或节点对象的列表

| 定位一个元素                         | 定位多个元素                          | 含义                  |
| ------------------------------------ | ------------------------------------- | --------------------- |
| find_element_by_id()                 | find_elements_by_id()                 | 通过元素id定位        |
| find_element_by_name()               | find_elements_by_name()               | 通过元素name定位      |
| find_element_by_class_name()         | find_elements_by_class_name()         | 通过类名进行定位      |
| find_element_by_xpath()              | find_elements_by_xpath()              | 通过xpath表达式定位   |
| find_element_by_link_text()          | find_elements_by_link_text()          | 通过完整超链接定位    |
| find_element_by_partical_link_text() | find_elements_by_partical_link_text() | 通过部分链接定位      |
| find_element_by_tag_name()           | find_elements_by_tag_name()           | 通过标签定位          |
| find_element_by_css_selector()       | find_elements_by_css_selector()       | 通过css选择器进行定位 |

> 假设源代码如下：

```python
<!--假设页面源代码如下：-->
<html>
  <head>
  <body link="#0000cc">
    <a id="result_logo" href="/" onmousedown="return c({'fm':'tab','tab':'logo'})">
    <form id="form" class="fm" name="f" action="/s">
      <span class="soutu-btn"></span>
        <input id="kw" class="s_ipt" name="wd" value="" maxlength="255" autocomplete="off">
...
```

> 查找元素

```python
# 通过id定位
driver.find_element_by_id("kw")

# 通过name定位
driver.find_element_by_name("wd")

# 通过class name定位
driver.find_element_by_class_name("fm")

# 通过tag name定位
driver.find_element_by_tag_name("input")

# 通过xpath定位，xpath定位有N种写法，这里列几个常用写法
driver.find_element_by_xpath("//input[@id='kw']")
driver.find_element_by_xpath("//input[@name='wd']")
driver.find_element_by_xpath("//input[@class='s_ipt']")
driver.find_element_by_xpath("/html/body/form/span/input")
driver.find_element_by_xpath("//span[@class='soutu-btn']/input")
driver.find_element_by_xpath("//form[@id='form']/span/input")
driver.find_element_by_xpath("//input[@id='kw'and @name='wd']")

--------------------------------------------------------------------------
# 假设页面上有一组文本链接：
<a class="mnav" href="http://news.baidu.com" name="tj_trnews">新闻</a>
<a class="mnav" href="http://www.hao123.com" name="tj_trhao123">hao123</a>
--------------------------------------------------------------------------
# 通过link text定位
driver.find_element_by_link_text("新闻")
driver.find_element_by_link_text("hao123")

# 通过partial link text定位
driver.find_element_by_partial_link_text("新")
driver.find_element_by_partial_link_text("hao")
driver.find_element_by_partial_link_text("123")
```

### 4.3 节点对象方法

> - 节点对象常用属性及方法
>   - node.send_keys()：向文本框发送内容
>   - node.click()：点击
>   - node.clear()：清空文本
>   - **node.get_attribute(‘属性名’)：获取节点属性值**
>   - node.text：获取节点文本内容（包含子节点和后代节点）

## 五、自动化爬虫案例

#### 1、爬取猫眼榜单数据（https://www.maoyan.com/board/4）

![image-20230106224308001](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106224308001.png)

> 爬取思路：
>
> ​	1. 打开浏览器输入top100主页地址
>
> 2. 使用selenium的xpath找到电影信息节点对象列表
>
> 3. 依次遍历每个元素，并依次提取每个电影信息
>
> 4. 可利用find_element_by_link_text()判断是否为最后1页

> 不难发现数据在<dd>标签中  driver.find_elements_by_xpath()

```python
import time
import pandas as pd

from selenium import webdriver


def get_one_page_data(driver, id_list, movie_list, star_list, movie_time_list, score_list):
    time.sleep(1.5)  # 让页面中元素加载完毕
    # 定位电影榜单的dd标签
    # //div[@id="app"]/div/div/div[1]/dl/dd
    dd_list = driver.find_elements_by_xpath('//div[@id="app"]/div/div/div[1]/dl/dd')
    for dd in dd_list:
        infos_list = str(dd.text).split('\n')
        print(infos_list)
        print('-----------------------------')
        # ['4', '绿皮书', '主演：维果·莫腾森,马赫沙拉·阿里,琳达·卡德里尼', '上映时间：2019-03-01', '9.5']
        id_list.append(infos_list[0])
        movie_list.append(infos_list[1])
        star_list.append(infos_list[2])
        movie_time_list.append(infos_list[3])
        score_list.append(infos_list[4])
        print('----------------')


def quit_driver(driver):
    # 睡眠n秒
    time.sleep(5)

    # 关闭整个浏览器
    driver.quit()


if __name__ == '__main__':
    # 打开浏览器
    driver = webdriver.Chrome()
    # 打开一个链接url  https://www.maoyan.com/board/4
    driver.get('https://www.maoyan.com/board/4')
    # 留时间给用户操作
    time.sleep(5)  # 这里的操作一般是用户做验证，登录，滑动验证，验证码等操作，将来可以在这里使用机器学习

    # 创建5ge列表
    # ['4', '绿皮书', '主演：维果·莫腾森,马赫沙拉·阿里,琳达·卡德里尼', '上映时间：2019-03-01', '9.5']
    id_list = []  # 排名
    movie_list = []  # 电影名
    star_list = []  # 主演
    movie_time_list = []  # 上映时间
    score_list = []  # 评分

    page_num = 1

    # 第一次爬取
    print(f'=============================正在爬取第{page_num}页=================================')
    get_one_page_data(driver, id_list, movie_list, star_list, movie_time_list, score_list)

    # 使用while循环，循环判断最后一个li是不是下一页
    while True:
        li = driver.find_element_by_xpath('//div[@id="app"]/div/div/div[last()]/ul/li[last()]')
        li_text = str(li.text)
        if li_text == '下一页':
            page_num += 1
            li.click()
            print(f'=============================正在爬取第{page_num}页=================================')
            get_one_page_data(driver, id_list, movie_list, star_list, movie_time_list, score_list)
        else:
            print('结束爬取！正在保存到csv表中...')
            break
    quit_driver(driver)

    # 封装成字典
    '''
    id_list = []  # 排名
    movie_list = []  # 电影名
    star_list = []  # 主演
    movie_time_list = []  # 上映时间
    score_list = []  # 评分
    '''
    dict1 = {
        '排名': id_list,
        '电影名': movie_list,
        '主演': star_list,
        '上映时间': movie_time_list,
        '评分': score_list
    }

    # 转成DataFrame对象
    df1 = pd.DataFrame(dict1)
    # 保存到表中
    df1.to_csv('data/猫眼电影榜单Top100.csv', index=False)

```



![image-20230106224647339](C:\Users\ASUS\Desktop\md笔记\python爬虫之selenium自动化学习.assets\image-20230106224647339.png)

> 爬取一页数据

![image-20230106230810794](C:\Users\ASUS\Desktop\md笔记\python爬虫之selenium自动化学习.assets\image-20230106230810794.png)

> 爬取多页数据

> 使用自动化控制点击下一页 driver.find_element_by_link_text('下一页').click()

![image-20230106231035741](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106231035741.png)

> 代码编写：

```python
from selenium import webdriver
import time
import pandas as pd


def get_one_page_data(ranks, names, stars, times, scores):
    dd_list = driver.find_elements_by_xpath('//div[@id="app"]/div/div/div/dl/dd')
    # print(dd_list)
    for dd in dd_list:
        # print(dd.text)
        # print("===================")
        # 将每一个文本信息以换行符进行分割
        info = str(dd.text).split('\n')
        ranks.append(info[0].strip())
        names.append(info[1].strip())
        stars.append(info[2].strip())
        times.append(info[3].strip())
        scores.append(info[4].strip())


if __name__ == '__main__':
    # 1、创建一个浏览器驱动器对象
    driver = webdriver.Chrome()

    # 2、传入url进行访问
    driver.get(
        url='https://www.maoyan.com/board/4?timeStamp=1673074280655&channelId=40011&index=3&signKey=02e997e8ac42c73d47ae9d6a38a54ca3&sVersion=1&webdriver=false')

    time.sleep(10)

    # 创建5个列表
    ranks = []
    names = []
    stars = []
    times = []
    scores = []

    while True:
        get_one_page_data(ranks, names, stars, times, scores)
        # 每获取一页数据后，需要进行点击下一页
        # 通过观察后发现，最后一页是没有下一页的超链接的
        b1 = driver.find_element_by_xpath('//div[@id="app"]/div/div/div[2]/ul/li[last()]/a')
        if b1.text == '下一页':
            b1.click()
        else:
            print("============================正在获取下一页====================================")
            break

info_dict = {
    '排名': ranks,
    '电影名称': names,
    '主演': stars,
    '上映时间': times,
    '评分': scores
}

df1 = pd.DataFrame(info_dict)
df1.to_csv('猫眼电影榜单数据.csv', index=False)
print("所有榜单数据获取完毕！！！正在关闭浏览器。。。。")
time.sleep(2)

driver.quit()

```



![image-20230106231258854](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106231258854.png)

### 2、Selenium 高级操作（隐藏浏览器界面）

```python
options = webdriver.ChromeOptions()
options.add_argument('--headless')
# 1、创建浏览器对象 - 打开浏览器
# driver = webdriver.Chrome()
driver = webdriver.Chrome(chrome_options=options)
```

### 3、selenium执行JS脚本（解决一个问题滚动更新的问题）

> 浏览器对象执行JS脚本函数

```
browser.execute_script()
```

```python
# 把滚动条拉到底部
from selenium import webdriver


# 1、创建浏览器对象 - 打开浏览器
driver = webdriver.Chrome()

driver.execute_script(
	'window.scrollTo(0,document.body.scrollHeight)'
)
```

### 4、爬取京东商品练习

#### 目标地址

​	由于各种原因不便写出地址，各位随便找个网页就可以

#### 抓取目标

> 1. 抓取爬虫书籍的所有商品信息
> 2. 商品名称、商品价格、评价数量、商品商家

#### 爬取思路

> 1. 打开网站，到商品搜索页
> 2. 匹配所有商品节点对象列表
> 3. 把节点对象的文本内容取出来，查看规律，是否有更好的处理办法
> 4. 提取完1页后，判断如果不是最后1页，则点击下一页

![image-20240119150319351](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240119150319351.png)

#### 实现步骤

> 首页搜索框：//input[@id="key"]
>
> 首页搜索按钮：//button[@aria-label="搜索"]

![image-20230106234251470](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106234251470.png)

> 商品信息节点对象列表：//div[@id="J_goodsList"]/ul/li

> 代码编写：

```python
from selenium import webdriver
import time
import pandas as pd


def get_one_page_data(prices, names, rates, shops):
    # 将页面拉到最底部
    driver.execute_script(
        'window.scrollTo(0,document.body.scrollHeight)'
    )

    time.sleep(1)

    # 使用xpath匹配商品数据列表
    li_list = driver.find_elements_by_xpath('//div[@id="J_goodsList"]/ul/li')

    for li in li_list:
        # print(li.text)
        # print("==========================")
        info = str(li.text).split("\n")
        prices.append(info[0])
        names.append(info[1])
        rates.append(info[2])
        shops.append(info[3])


if __name__ == '__main__':
    '''
    使用自动化京东商品数据爬取
    '''

    url = "https://www.jd.com/?cu=true&utm_source=baidu-pinzhuan&utm_medium=cpc&utm_campaign=t_288551095_baidupinzhuan&utm_term=0f3d30c8dba7459bb52f2eb5eba8ac7d_0_7465f07a5166458bbf5610189e4140f9"

    # 创建浏览器驱动器对象
    driver = webdriver.Chrome()
    # driver.maximize_window()  # 页面最大化

    # 打开京东首页
    driver.get(url=url)

    search_name = input("请输入你要爬取的关键词：")

    # 定位到输入框
    driver.find_element_by_xpath('//input[@id="key"]').send_keys(search_name)
    driver.find_element_by_xpath('//div[@id="search"]/div/div[2]/button').click()

    # 创建4个空列表创建4种数据
    prices = []
    names = []
    rates = []
    shops = []

    print("==========================自动化爬取开始！==================================")
    num = 1
    # 留一点给页面进行对数据的加载
    time.sleep(2)
    while True:
        print(f"=====================正在爬取第{num}页=====================")
        get_one_page_data(prices, names, rates, shops)
        # 通过观察网页后发现，如果下一页链接还能够点击的话，class的属性值是pn-next，否则是pn-next disabled
        if driver.page_source.find('pn-next disabled') == -1:  # 当结果不是-1的时候，说明还不是最后一页
            driver.find_element_by_xpath('//div[@id="J_bottomPage"]/span/a[last()]').click()  # 点击下一页
            num += 1
        else:
            print("==========================自动化爬取结束！=================================")
            print(f"{num}页数据全部获取完毕！！！正在保存到{search_name}关键词数据.csv文件种....")
            break

    # 将4个列表数据转成字典格式
    info_dict = {
        '商品名称': names,
        '商品价格': prices,
        '店铺': shops,
        '评论条数': rates
    }

    # 将字典转成DF数据类型
    df1 = pd.DataFrame(info_dict)

    # 将DF数据保存到csv文件种
    df1.to_csv(f'{search_name}关键词数据.csv', index=False)
    print("数据保存完毕！！正在关闭浏览器......")
    time.sleep(2)

    driver.quit()

```

> 运行结果：

![image-20230106235455790](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106235455790.png)	

> 但是输出的格式不好看，所以只能找他们的xpath进行获取数据

> 每个商品的具体信息xpath: 
>
> ![image-20230106234447358](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230106234447358.png)
>
> 名称：.//div[@class="p-price"]/strong
> 	价格：.//div[@class="p-name p-name-type-2"]/a/em
> 	评论：.//div[@class="p-commit"]/strong
> 	商家：.//div[@class="p-shop"]/span

> 代码编写：

```

```



![image-20230107000427317](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230107000427317.png)

### 5、selenium键盘操作

> Selenium中的Key模块为我们提供了模拟键盘按键的方法，那就是send_keys()方法。它不仅可以模拟键盘输入，也可以模拟键盘的操作。

> 常用的键盘操作如下：

|        模拟键盘按键        |          说明           |
| :------------------------: | :---------------------: |
| send_keys(Keys.BACK_SPACE) | 输入删除键（BackSpace） |
|   send_keys(Keys.SPACE)    |    输入空格键(Space)    |
|    send_keys(Keys.TAB)     |     输入制表键(Tab)     |
|   send_keys(Keys.ESCAPE)   |    输入回退键（Esc）    |
|   send_keys(Keys.ENTER)    |   输入回车键（Enter）   |

> 组合键的使用

|         模拟键盘按键         |      说明      |
| :--------------------------: | :------------: |
| send_keys(Keys.CONTROL, ‘a’) | 全选（Ctrl+A） |
| send_keys(Keys.CONTROL, ‘c’) | 复制（Ctrl+C） |
| send_keys(Keys.CONTROL, ‘x’) | 剪切（Ctrl+X） |
| send_keys(Keys.CONTROL, ‘v’) | 粘贴（Ctrl+V） |
|    send_keys(Keys.F1…Fn)     |   键盘 F1…Fn   |

### 6、selenium鼠标操作

> 在 WebDriver 中， 将这些关于鼠标操作的方法封装在 ActionChains 类提供。

|          方法          |                             说明                             |
| :--------------------: | :----------------------------------------------------------: |
|  ActionChains(driver)  |                     构造ActionChains对象                     |
|    context_click()     |                       执行鼠标悬停操作                       |
| move_to_element(above) |                             右击                             |
|     double_click()     |                             双击                             |
|    drag_and_drop()     |                             拖动                             |
| move_to_element(above) |                       执行鼠标悬停操作                       |
|    context_click()     |       用于模拟鼠标右键操作， 在调用时需要指定元素定位        |
|       perform()        | 执行所有 ActionChains 中存储的行为，可以理解成是对整个操作的提交动作 |

#### 使用流程

> - 导入鼠标事件类：`from selenium.webdriver import ActionChains`
> - 实例化鼠标对象：`ActionChains(browser)`
> - 指定鼠标行为：`move_to_element(node)`
> - 执行鼠标行为：`perform()`

```python
from selenium.webdriver import ActionChains

ActionChains(browser).move_to_element(node).perform()
```

```python
driver.maximize_window()  # 页面最大化

# 2.定位到要悬停的元素
element = driver.find_element_by_xpath('//*[@id="s-usersetting-top"]')

# 3.对定位到的元素执行鼠标悬停操作
ActionChains(driver).move_to_element(to_element=element).perform()
```

> 代码编写：

```python
from selenium.webdriver import ActionChains
from selenium import webdriver
import time


driver = webdriver.Chrome()
driver.maximize_window()

driver.get(url='https://www.baidu.com/')

# 2.定位到要悬停的元素
element = driver.find_element_by_xpath('//*[@id="s-usersetting-top"]')

# 3.对定位到的元素执行鼠标悬停操作
ActionChains(driver).move_to_element(to_element=element).perform()

time.sleep(1)

driver.find_element_by_link_text('高级搜索').click()

time.sleep(5)

driver.quit()
```

### 7、selenium frame（登录问题）

> 一般遇到这样的问题，都是需要先进行登录的问题，我们发现网页中居然还嵌套一个网页，我们必须的先选择内部的网页才能进行其他操作

#### 处理方式

> - 切换到要处理的frame
> - 在frame中定位页面元素并进行操作
> - 返回当前处理的Frame的上一级页面或主页面

#### 常用函数

> - 切换到frame：browser.switch_to.frame(frame节点对象)
> - 返回上一级：browser.switch_to.parent_frame()
> - 返回主页面：browser.switch_to.default_content()

#### 使用步骤

> - 默认支持id和name属性值查找：switch_to.frame(id|name)
> - 先找到frame节点：frame_node = browser.find_element_by_xxx
> - 再切换到frame：browser.switch_to.frame(iframe_node)

#### QQ邮箱案例

> 我们发现首页中的登录页面也是一个HTML页面

![image-20230107003442096](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20230107003442096.png)

> 从网页源码中可以看到，html中包含了html，此时用driver.find_element_by_xxx()查找元素，找的实际上是外层html中的元素。所以我们需切换到iframe中，才能找到里层的html元素。

##### 使用自动化登录qq邮箱

> 实现思路：
>
> - 打开登录页
> - 切换frame
> - 找到用户名、密码节点并发送QQ号和密码到文本框
> - 找到登录按钮并点击

> 代码编写: 

```

```

### 8、控制浏览器操作的一些方法

|               方法                |          说明          |
| :-------------------------------: | :--------------------: |
|  webdriver.**set_window_size()**  |    设置浏览器的大小    |
|       webdriver.**back()**        |     控制浏览器后退     |
|      webdriver.**forward()**      |     控制浏览器前进     |
|      webdriver.**refresh()**      |      刷新当前页面      |
|       webdriver.**clear()**       |        清除文本        |
|  webdriver.**send_keys(value)**   |      模拟按键输入      |
|       webdriver.**click()**       |        单击元素        |
|      webdriver.**submit()**       |      用于提交表单      |
| webdriver.**get_attribute(name)** |     获取元素属性值     |
|   webdriver.**is_displayed()**    | 设置该元素是否用户可见 |
|        webdriver.**size**         |     返回元素的尺寸     |
|        webdriver.**text**         |     获取元素的文本     |

```python
from selenium import webdriver
from time import sleep

# 1.创建Chrome浏览器对象，这会在电脑上在打开一个浏览器窗口
driver = webdriver.Chrome()

# 2.通过浏览器向服务器发送URL请求
driver.get("https://www.baidu.com/")

sleep(3)

# 3.刷新浏览器
driver.refresh()

# 4.设置浏览器的大小
driver.set_window_size(1400, 800)

# 5.设置链接内容
element = driver.find_element_by_link_text("新闻")
element.click()

element = driver.find_element_by_link_text("韩国踩踏事故")
element.click()

```

#### 获取断言信息

> 不管是在做功能测试还是自动化测试，最后一步需要拿实际结果与预期进行比较。这个比较的称之为断言。通过我们获取title 、URL和text等信息进行断言。

| 属性        | 说明                   |
| ----------- | ---------------------- |
| title       | 用于获得当前页面的标题 |
| current_url | 用户获得当前页面的URL  |
| text        | 获取搜索条目的文本信息 |

```
from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get("https://www.baidu.com")

print('Before search================')

# 打印当前页面title
title = driver.title
print(title)						# 百度一下，你就知道

# 打印当前页面URL
now_url = driver.current_url
print(now_url)						# https://www.baidu.com/

driver.find_element_by_id("kw").send_keys("selenium")
driver.find_element_by_id("su").click()
sleep(1)

print('After search================')

# 再次打印当前页面title
title = driver.title
print(title)						# selenium_百度搜索

# 打印当前页面URL
now_url = driver.current_url
print(now_url)						# https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=selenium&rsv_pq=a1d51b980000e36e&rsv_t=a715IZaMpLd1w92I4LNUi7gKuOdlAz5McsHe%2FSLQeBZD44OUIPnjY%2B7pODM&rqlang=cn&rsv_enter=0&rsv_sug3=8&inputT=758&rsv_sug4=759

# 获取结果数目
user = driver.find_element_by_class_name('nums').text
print(user)							# 百度为您找到相关结果约7,170,000个

#关闭所有窗口
driver.quit()

```





# 数学分析工具 Numpy

## 1.1、下载

```python
pip install numpy 
```

## 1.2、numpy库的使用

### 1.2.1 矩阵的创建

```python
list1 = [[11, 22, 33], [44, 55, 66], [77, 88, 99]]
# 将python中的列表数据类型转变成numpy中ndarray类型
res1 = np.array(list1)  # array()函数创建
print(res1)
```

### 1.2.2 矩阵数据类型中的属性

- ndim 获取维度数

```python
import numpy as np

list1 = [[11, 22, 33], [44, 55, 66], [77, 88, 99]]
# 将python中的列表数据类型转变成numpy中ndarray类型
array1 = np.array(list1)  # array()函数创建
print(array1, type(array1))

# 矩阵有哪些属性
# 获取矩阵中的维度
print(f'矩阵的维度是：{np.ndim(array1)}')  # 2
```

- shape()  获取矩阵的行数和列数

```python
print(np.shape(array1))  # 返回的是(行数，列数)
```

- size() 获取元素的个数

```python
print(np.size(array1))
```

### 1.2.3 矩阵的运算

- 相乘  A.dot(B)  

```python
list1 = [[1, 2, 3], [1, 0, 1], [1, 2, 2]]
list2 = [[2, 2, 3, 1], [1, 1, 0, 1], [1, 1, 1, 1]]

array1 = np.array(list1)
array2 = np.array(list2)
print(array1)
print(array2)

print('-------------------------')
# 两个矩阵相乘 A*B
print(array1.dot(array2))
```

- 求矩阵中的最大值或者最小值

```python
'''
[[7 7 6 6]
 [3 3 4 2]
 [6 6 5 5]]
 
 [7 7 6 6 3 3 4 2 6 6 5 5]
'''
print(f'矩阵中的最大值元素的索引: {np.argmax(array3)}')  # 0
print(f'矩阵中的最小值元素的索引: {np.argmin(array3)}')  # 7
```

- 平均值

```python
'''
[[7 7 6 6]
 [3 3 4 2]
 [6 6 5 5]]
'''
print(f'矩阵元素的平均值为：{np.mean(array3)}')  # 5.0
```

- 中位数

```python
print(f'矩阵元素的中位数为：{np.median(array3)}')  # 5.5
```

- 依次累加

```python
print(np.cumsum(array3))  # [ 7 14 20 26 29 32 36 38 44 50 55 60]
```

- 取非0元素坐标

```python
list1 = [[1, 0, 0], [1, 0, 1], [1, 1, 0]]
array4 = np.array(list1)
print(array4)
res = np.nonzero(array4)
# 返回的是非0的元素的坐标，第一个结果是行索引，第二个结果是列索引
print(res)  # (array([0, 1, 1, 2, 2], dtype=int64), array([0, 0, 2, 0, 1], dtype=int64))
```

- 转型 astype()

```python
print(array5.dtype)  # int32
array5 = array5.astype('float')
print(array5)
print(array5.dtype) # float64

'''
[[11. 22. 33. 44.]
 [12. 32. 42. 52.]]
'''
```





### 1.2.4 numpy矩阵中的索引

```python
print('-----------------------------------')
print(array4[1][1])  # 0
print('-------------------')
list2 = [[11, 22, 33, 44], [12, 32, 42, 52]]
array5 = np.array(list2)
print(array5)
print('-------------------')
'''
[[33 44]
 [42 52]]
'''
print(array5[:, 2:])
```



# 2、Pandas模块学习与使用

> `Pandas`是一个开源的，BSD许可的库，为Python (opens new window)编程语言提供高性能，易于使用的数据结构和数据分析工具。从 Numpy 和 Matplotlib 的基础上构建而来，享有数据分析“三剑客之一”的盛名（NumPy、Matplotlib、Pandas）。

## 2.1、Pandas概述

> Pandas 这个名字来源于面板数据（Panel Data）与数据分析（data analysis）这两个名词的组合。在经济学中，Panel Data 是一个关于多维数据集的术语。
>
> **Pandas** 是Python的核心数据分析支持库，提供了快速、灵活、明确的数据结构，旨在简单、直观地处理关系型、标记型数据。Pandas 的目标是成为 Python 数据分析实践与实战的必备高级工具，其长远目标是成为**最强大、最灵活、可以支持任何语言的开源数据分析工具**。经过多年不懈的努力，Pandas 离这个目标已经越来越近了。
>
> Pandas 适用于处理以下类型的数据：

- 与 SQL 或 Excel 表类似的，含异构列的表格数据;
- 有序和无序（非固定频率）的时间序列数据;
- 带行列标签的矩阵数据，包括同构或异构型数据;
- 任意其它形式的观测、统计数据集, 数据转入 Pandas 数据结构时不必事先标记。

> Pandas 的主要数据结构是 Series（一维数据）与 DataFrame （二维数据），这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。对于 R 用户，DataFrame 提供了比 R 语言 data.frame 更丰富的功能。Pandas 基于 NumPy 开发，可以与其它第三方科学计算支持库完美集成。
>
> Pandas 就像一把万能瑞士军刀，下面仅列出了它的部分优势 ：

- 处理浮点与非浮点数据里的**缺失数据**，表示为 `NaN`；
- 大小可变：**插入或删除** DataFrame 等多维对象的列；
- 自动、显式**数据对齐**：显式地将对象与一组标签对齐，也可以忽略标签，在 Series、DataFrame 计算时自动与数据对齐；
- 强大、灵活的**分组**（group by）功能：**拆分-应用-组合**数据集，聚合、转换数据；
- 把 Python 和 NumPy 数据结构里不规则、不同索引的数据**轻松**地转换为 DataFrame 对象；
- 基于智能标签，对大型数据集进行**切片**、**花式索引**、**子集分解**等操作；
- 直观地**合并（merge）**、**连接（join）**数据集；
- 灵活地**重塑（reshape）**、**透视（pivot）**数据集；
- **轴**支持结构化标签：一个刻度支持多个标签；
- 成熟的 IO 工具：读取**文本文件**（CSV 等支持分隔符的文件）、Excel 文件、数据库等来源的数据，利用超快的 **HDF5** 格式保存 / 加载数据；
- **时间序列**：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序列功能。

> 这些功能主要是为了解决其它编程语言、科研环境的痛点。处理数据一般分为几个阶段：数据整理与清洗、数据分析与建模、数据可视化与制表，Pandas 是处理数据的理想工具。
>
> 其它说明：

- Pandas 速度**很快**。Pandas 的很多底层算法都用 Cython优化过。然而，为了保持通用性，必然要牺牲一些性能，如果专注某一功能，完全可以开发出比 Pandas 更快的专用工具。
- Pandas 是 statsmodels的依赖项，因此，Pandas 也是 Python 中统计计算生态系统的重要组成部分。
- Pandas 已广泛应用于金融领域。



## 2.2、Pandas安装

> 注意：Python核心团队计划在2020年1月1日停止支持Python 2.7。按照NumPy的计划，2018年12月31日之前的所有Pandas版本都仍支持Python 2（译者注：之后的版本将不再支持）。
>
> **2018年12月31日**之前的最终版本将是支持Python 2的最后一个版本。已发布的软件包将继续在PyPI和conda上提供。
>
> - 从 **2019年1月1日** 开始，所有版本都只支持Python 3。

> 从PyPI安装

```bash
$ pip install Pandas
```

![image-20230102214155061](https://gitee.com/xiaohuya1/image_test/raw/master/img/202401151958894.png)

> 用于解析HTML的可选依赖项
>
> 要使用顶级read_html() (opens new window)函数，需要以下一种库组合：

```
警告

如果安装BeautifulSoup4 (opens new window)，必须安装lxml (opens new window)或html5lib (opens new window)或两个都安装。
read_html() (opens new window)不能只安装 BeautifulSoup4 (opens new window)。
强烈建议您阅读 HTML表解析之坑 (opens new window)。 
它解释了有关上述三个库的安装和使用的问题。
```

## 2.3、Pandas内置数据结构

> pandas在 ndarray 数组（NumPy 中的数组）的基础上构建出了两种不同的数据结构，分别是 Series（一维数据结构）DataFrame（二维数据结构）

- Series 是带标签的一维数组，这里的标签可以理解为索引，但这个索引并不局限于整数，它也可以是字符类型，比如 a、b、c 等；
- DataFrame 是一种表格型数据结构，它既有行标签，又有列标签。

| 维数 | 名称      | 描述                               |
| ---- | --------- | ---------------------------------- |
| 1    | Series    | 带标签的一维同构数组               |
| 2    | DataFrame | 带标签的，大小可变的，二维异构表格 |

### 2.3.1、pandas数据结构之 Series

> Series 结构，也称 Series 序列，是 Pandas 常用的数据结构之一，它是一种类似于一维数组的结构，由一组数据值（value）和一组标签（索引）组成，其中标签与数据值之间是一一对应的关系。
>
> Series 可以保存任何数据类型，比如整数、字符串、浮点数、Python 对象等，它的标签默认为整数，从 0 开始依次递增。
>
> ![image-20240115200856543](https://gitee.com/xiaohuya1/image_test/raw/master/img/202401152008581.png)

#### 2.3.1.1、创建Series数据对象

> Pandas 使用 Series() 函数来创建 Series 对象，通过这个对象可以调用相应的方法和属性，从而达到处理数据的目的.

```python
# 语句定义格式
import pandas as pd
s=pd.Series( data, index, dtype, copy)
```

- 参数描述

| 参数名称  |                             描述                             |
| :-------: | :----------------------------------------------------------: |
| **data**  |      **输入的数据，可以是列表、常量、ndarray 数组等。**      |
| **index** | **索引值必须是惟一的，如果没有传递索引，则默认为 np.arrange(n)。** |
| **dtype** |   **dtype表示数据类型，如果没有提供，则会自动判断得出。**    |
| **copy**  |           **表示对 data 进行拷贝，默认为 False。**           |

> 注：也可以使用数组、字典、标量值或者 Python 对象来创建 Series 对象。

##### 2.3.1.1.1、创建一个空的Series对象

```python
import pandas as pd
#输出数据为空
s = pd.Series([], dtype='float64')
print(s)
```

##### 2.3.1.1.2、使用矩阵ndarray创建Series对象

> ndarray 是 NumPy 中的数组类型，当 data 是 ndarry 时，传递的索引必须具有与数组相同的长度。假如没有给 index 参数传参，在默认情况下，索引值将使用是 range(n) 生成，其中 n 代表数组长度

```python
import pandas as pd
import numpy as np
data = np.array(['a','b','c','d'])
s = pd.Series(data)
print (s)
```

> ![image-20240116093920244](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240116093920244.png)
>
> 没有传递任何索引，所以索引默认从 0 开始分配 ，其索引范围为 0 到`len(data)-1`，即 0 到 3。这种设置方式被称为“隐式索引”
>
> 显示索引

```python
import pandas as pd
import numpy as np
data = np.array(['a','b','c','d'])
#自定义索引标签（即显示索引）
s = pd.Series(data,index=[1001,1002,1003,1004])
print(s)
```

![image-20240116094057836](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240116094057836.png)

##### 2.3.1.1.3、python字典dict创建Series对象

- 没有传递索引时

```python
import pandas as pd
import numpy as np
dict1 = {'sj001': '小虎', 'sj002': '小杰', 'sj003': '小阳', 'sj004': '小超'}
pd2 = pd.Series(dict1)
print(pd2,type(pd2))
```

![image-20240116094352663](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240116094352663.png)

- 用`index`参数传递索引时

```python
import pandas as pd
import numpy as np
# 取索引
dict1 = {'sj001': '小虎', 'sj002': '小杰', 'sj003': '小阳', 'sj004': '小超'}
# 如果一开始有索引，index的作用是取对应的索引，如果索引没有的话，值对应NaN
pd2 = pd.Series(dict1, index=['sj001', 'sj003', 'sj005'])
print(pd2, type(pd2))
```

![image-20240116094809720](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240116094809720.png)

> 小总结：
>
> - 如果一开始没有索引，index的作用是加索引，如果超出值的个数，报错
> - 如果一开始有索引，index的作用是取对应的索引，如果索引没有的话，值对应NaN

##### 2.3.1.1.4、标量固定值创建

- 注意：如果是标量，如果没给索引值，就只有一个

```python
import pandas as pd
import numpy as np
pd3 = pd.Series(100, index=[1001,1002,1003,1004])
print(pd3,type(pd3))
```

![image-20240116094942195](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240116094942195.png)

#### 2.3.1.2、Series数据的使用

> 两种使用方式：
>
> - 位置索引访问
> - 索引标签访问

##### 2.3.1.2.1、位置索引访问

> 这种访问方式与 ndarray 和 list 相同，使用元素自身的下标进行访问。索引计数从 0 开始，这表示第一个元素存储在第 0 个索引位置上，以此类推，就可以获得 Series 序列中的每个元素。

```python
import pandas as pd
s = pd.Series([1,2,3,4,5],index = ['a','b','c','d','e'])
print(s[0])  #位置下标
```

> 注意：**如果索引不是默认的话，需要我们使用定义的索引来获取，如果数据是列表这样的本身就有索引的数据的话，可以通过0-n的方式获取**

- 通过切片的方式访问 Series 序列中的数据

```python
import pandas as pd
s = pd.Series([1,2,3,4,5],index = ['a','b','c','d','e'])
print(s[:3])  # 不包括结束索引的值
```

- 获取最后三个元素

```python
import pandas as pd
s = pd.Series([1,2,3,4,5],index = ['a','b','c','d','e'])
print(s[-3:])
```

##### 2.3.1.2.2、索引标签访问（常用）

> Series 类似于固定大小的 dict，把 index 中的索引标签当做 key，而把 Series 序列中的元素值当做 value，然后通过 index 索引标签来访问或者修改元素值。

- 使用索标签访问单个元素值

> 如果不存在会报错 KeyError: 'f'

```python
import pandas as pd
s = pd.Series([6,7,8,9,10],index = ['a','b','c','d','e'])
print(s['a'])
```

- 使用索引标签访问多个元素值

```python
import pandas as pd
s = pd.Series([6,7,8,9,10],index = ['a','b','c','d','e'])
print(s[['a','c','d']])
```

#### 2.3.1.3、Series常用属性

|  **名称**  |                       **属性**                       |
| :--------: | :--------------------------------------------------: |
|  **axes**  |         **以列表的形式返回所有行索引标签。**         |
| **dtype**  |               **返回对象的数据类型。**               |
|  **ndim**  |               **返回输入数据的维数。**               |
|  **size**  |             **返回输入数据的元素数量。**             |
| **values** |       **以 ndarray 的形式返回 Series 对象。**        |
| **index**  | **返回一个RangeIndex对象，用来描述索引的取值范围。** |
| **empty**  |            **返回一个空的 Series 对象。**            |

- 随机创建一个Series数据

```python
import pandas as pd
import numpy as np
array2 = np.array([11, 22, 33, 44, 55])
pd3 = pd.Series(array2, index=[1001, 1002, 1003, 1004, 1005])
# print(pd3,type(pd3))
```

- ##### axes

```python
import pandas as pd
import numpy as np
s = pd.Series(np.random.randn(5))
print ("所有行索引标签:")
print(s.axes)
```

- ##### dtype

```python
import pandas as pd
import numpy as np
s = pd.Series(np.random.randn(5))
print ("数据类型:")
print(s.dtype)
```

- ##### empty

> 返回一个布尔值，用于判断数据对象是否为空

```python
import pandas as pd
import numpy as np
s = pd.Series(np.random.randn(5))
print("是否为空对象?")
print (s.empty)
```

- ##### ndim

> 查看序列的维数。因为Series 是一维数据结构，因此它始终返回 1。

```python
import pandas as pd
import numpy as np
s = pd.Series(np.random.randn(5))
print (s)
print (s.ndim)
```

- ##### size 返回 Series 对象的大小(长度)

```python
import pandas as pd
import numpy as np
s = pd.Series(np.random.randn(3))
print (s)
#series的长度大小
print(s.size)
```

- ##### values

> 以数组的形式返回 Series 对象中的数据。

```python
import pandas as pd
import numpy as np
s = pd.Series(np.random.randn(6))
print(s)
print("输出series中数据")
print(s.values)  # 返回的是一维的矩阵
```

- ##### index

> 用来查看 Series 中索引的取值范围

```python
#显示索引
import pandas as pd
s=pd.Series([1,2,5,8],index=['a','b','c','d'])
print(s.index)
#隐式索引
s1=pd.Series([1,2,5,8])
print(s1.index)
```

#### 2.3.1.4、Series常用函数

- ##### head()  默认显示前5条

```python
import pandas as pd
import numpy as np
s = pd.Series(np.random.randn(8))
print (s)
#返回前三行数据
print (s.head(3))
```

- ##### tail() 取后几条  默认取后5条

```python
import pandas as pd
import numpy as np
s = pd.Series(np.random.randn(4))
#原series
print(s)
#输出后两行数据
print (s.tail(2))
```

- ##### isnull() 和notnull()

  - isnull()：如果为值不存在或者缺失，则返回 True。
  - notnull()：如果值不存在或者缺失，则返回 False。

```python
import pandas as pd
#None代表缺失数据
s=pd.Series([1,2,5,None])
print(pd.isnull(s))  #是空值返回True
print(pd.notnull(s)) #空值返回False
```

### 2.3.2、pandas数据结构之DataFrame

> DataFrame 一个表格型的数据结构，既有行标签（index），又有列标签（columns），它也被称异构数据表，所谓异构，指的是表格中每列的数据类型可以不同，比如可以是字符串、整型或者浮点型等。

![image-20240115212200577](https://gitee.com/xiaohuya1/image_test/raw/master/img/202401152122638.png)

> 表格中展示了某个数据团队个人信息和绩效成绩的相关数据。数据以行和列形式来表示，其中每一列表示一个属性，而每一行表示一个条目的信息。

| Column | Type    |
| ------ | ------- |
| name   | String  |
| age    | integer |
| gender | String  |
| clazz  | String  |
| score  | Float   |

> **DataFrame 的每一行数据都可以看成一个 Series 结构，只不过，DataFrame 为这些行中每个数据值增加了一个列标签。因此 DataFrame 其实是从 Series 的基础上演变而来。**

- DataFrame 自带行标签索引，默认为“隐式索引”即从 0 开始依次递增，行标签与 DataFrame 中的数据项一一对应。上述表格的行标签从 0 到 3

#### 2.3.2.1、DataFrame特点（6点）

- DataFrame 每一列的标签值允许使用不同的数据类型；
- DataFrame 是表格型的数据结构，具有行和列；
- DataFrame 中的每个数据值都可以被修改。
- DataFrame 结构的行数、列数允许增加或者删除；
- DataFrame 有两个方向的标签轴，分别是行标签和列标签；
- DataFrame 可以对行和列执行算术运算。

#### 2.3.2.2、创建DataFrame对象

```python
import pandas as pd
pd.DataFrame( data, index, columns, dtype, copy)
```

> 参数说明

| 参数名称 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| data     | 输入的数据，可以是 ndarray，series，list，dict，标量以及一个 DataFrame。 |
| index    | 行标签，如果没有传递 index 值，则默认行标签是 np.arange(n)，n 代表 data 的元素个数。 |
| columns  | 列标签，如果没有传递 columns 值，则默认列标签是 np.arange(n)。 |
| dtype    | dtype表示每一列的数据类型。                                  |
| copy     | 默认为 False，表示复制数据 data。                            |

##### 2.3.2.2.1 创建空的DataFrame对象

```python
import pandas as pd
df = pd.DataFrame()
print(df)
```

##### 2.3.2.2.2 列表创建DataFame对象

- ##### 使用单一列表列表来创建一个 DataFrame

  ```python
  import pandas as pd
  data = [1,2,3,4,5]
  df = pd.DataFrame(data)
  print(df)
  ```

- ##### 使用嵌套列表创建 DataFrame 

  ```python
  import pandas as pd
  list2 = [['小白', 18, '男'], ['小黑', 17, '男'], ['小红', 17, '女']]
  df3 = pd.DataFrame(list2)
  print(df3, type(df3))
  # 嵌套列表列表中的每一个小列表，表示的是每一行
  ```

  ![image-20240116141237396](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240116141237396.png)

- ##### 指定数值元素的数据类型为 float

  ```python
  import pandas as pd
  data = [['xiaohu',18],['xiaoge',17],['fengfeng',15]]
  df = pd.DataFrame(data,columns=['Name','Age'],dtype=float) # 虽然被弃用 但是目前3.7.9也可以用 建议不加dtype=float，但是要在赋值的时候，确定数据类型
  print(df)
  ```

- ##### 字典嵌套列表创建（常用的）

  > data 字典中，键对应的值的元素长度必须相同（也就是列表长度相同）。如果传递了索引，那么索引的长度应该等于数组的长度；如果没有传递索引，那么默认情况下，索引将是 range(n)，其中 n 代表数组长度。

  ```python
  {
      k1:[],
      k2:[],
      k3:[]
  }
  
       k1 k2 k3
    0  x  x  x
    1  x  x  x
  import pandas as pd
  data = {'Name':['xiaohu', 'xiaoge', 'fengfeng', 'tongge'],'Age':[18,17,15,16]}
  df = pd.DataFrame(data)
  print(df)
  ```

- ##### 加自定义的行标签

  ```python
  import pandas as pd
  data = {'Name':['xiaohu', 'xiaoge', 'fengfeng', 'tongge'],'Age':[18,17,15,16]}
  df = pd.DataFrame(data, index=['1001','1002','1003','1004'])
  print(df)
  ```

- ##### 列表嵌套字典创建DataFrame对象

  > 列表嵌套字典可以作为输入数据传递给 DataFrame 构造函数。默认情况下，字典的键被用作列名。

  ```python
  import pandas as pd
  data = [{'a': 1, 'b': 2},{'a': 5, 'b': 10, 'c': 20}]
  df = pd.DataFrame(data)
  print(df)
  
  ```

  ![image-20240116142419132](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240116142419132.png)

  > ##### 注意： 如果其中某个元素值缺失，也就是字典的 key 无法找到对应的 value，将使用 NaN 代替。

- ##### 使用列表嵌套字典以及行、列索引表创建一个 DataFrame 对象。

  ```python
  import pandas as pd
  data = [{'a': 1, 'b': 2},{'a': 5, 'b': 10, 'c': 20}]
  df1 = pd.DataFrame(data, index=['first', 'second'], columns=['a', 'b'])
  df2 = pd.DataFrame(data, index=['first', 'second'], columns=['a', 'b1'])
  print(df1)
  print(df2)
  ```

  > b1 在字典键中不存在，所以对应值为 NaN。

- ##### Series创建DataFrame对象

  > 传递一个字典形式的 Series，从而创建一个 DataFrame 对象，其输出结果的行索引是所有 index 的合集。

  ```python
  import pandas as pd
  d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),
     'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}
  df = pd.DataFrame(d)
  print(df)
  ```

#### 2.3.2.3、DataFrame使用与操作

##### 2.3.2.3.1  列索引操作DataFrame

> DataFrame 可以使用列索（columns index）引来完成数据的选取、添加和删除操作

- ##### 列索引选取数据列

  ```python
  import pandas as pd
  d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),
     'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}
  df = pd.DataFrame(d)
  print(df['one'])
  ```

- ##### 列索引添加数据列

  ```python
  import pandas as pd
  d = {'Name' : pd.Series(['xiaohu1', 'xiaohu2', 'xiaohu3','xiaohu4'], index=['a', 'b', 'c','d']),
     'math' : pd.Series([89, 92, 91], index=['a', 'b', 'c'])}
  df = pd.DataFrame(d)
  #使用df['列']=值，插入新的数据列
  df['english']=pd.Series([67,78,79,99],index=['a','b','c','d'])
  print(df)
  
  #将已经存在的数据列做相加运算
  df['zongfen']=df['math']+df['english']   # NaN与任意一个值相加，结果依旧是NaN
  print(df)
  ```

- ##### 使用 insert() 方法插入新的列

  ```python
  import pandas as pd
  info=[['xiaohu',18],['xiaoge',19],['fengfeng',17]]
  df=pd.DataFrame(info,columns=['name','age'])
  print(df)
  #注意是column参数
  #数值1代表插入到columns列表的索引位置
  df.insert(1,column='score',value=[91,90,75])
  print(df)
  ```

- ##### 列索引删除数据列

  > 通过 del 和 pop() 都能够删除 DataFrame 中的数据**列**。

  ```python
  import pandas as pd
  d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),
     'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd']),
     'three' : pd.Series([10,20,30], index=['a','b','c'])}
  df = pd.DataFrame(d)
  print(df)
  
  #使用del删除
  del df['one']
  print(df)
  
  #使用pop方法删除
  df.pop('two')   # 将删除的列封装成Series对象进行返回
  print (df)
  ```

##### 2.3.2.3.2 行索引操作DataFrame

- ##### 标签索引选取

  > 可以将行标签传递给 loc 函数 

  ```python
  import pandas as pd
  d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),
     'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}
  df = pd.DataFrame(d)
  print(df.loc['b'])
  ```

  > **注意：返回的是.Series类型**

- ##### 整数索引选取

  > 通过将数据行所在的索引位置传递给 iloc 函数，也可以实现数据行选取

  ```python
  import pandas as pd
  d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),
     'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}
  df = pd.DataFrame(d)
  print (df.iloc[2])
  ```

- ##### 切片操作多行选取

  > 您也可以使用切片的方式同时选取多行。

  ```python
  import pandas as pd
  d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),
     'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}
  df = pd.DataFrame(d)
  #左闭右开
  print(df[2:4])
  ```

- ##### 添加数据行

  > 使用 append() 函数，可以将新的数据行添加到 DataFrame 中，该函数会在行末追加数据行。

  ```python
  import pandas as pd
  df = pd.DataFrame([[1, 2], [3, 4]], columns = ['a','b'])
  df2 = pd.DataFrame([[5, 6], [7, 8]], columns = ['a','b'])
  #在行末追加新数据行
  df = df.append(df2)
  print(df)
  ```

![image-20240116145135414](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240116145135414.png)

- ##### 删除数据行

  > 您可以使用行索引标签，从 DataFrame 中删除某一行数据。如果索引标签存在重复，那么它们将被一起删除。

  ```python
  import pandas as pd
  df = pd.DataFrame([[1, 2], [3, 4]], columns = ['a','b'])
  df2 = pd.DataFrame([[5, 6], [7, 8]], columns = ['a','b'])
  df = df.append(df2)
  print(df)
  #注意此处调用了drop()方法
  df = df.drop(0)  # 根据索引值删除
  print (df)
  ```

#### 2.3.2.4、常用属性和方法汇总

> DataFrame 的属性和方法，与 Series 相差无几

|  名称   |                      属性 方法描述                       |
| :-----: | :------------------------------------------------------: |
|    T    |                       行和列转置。                       |
|  axes   |       返回一个仅以行轴标签和列轴标签为成员的列表。       |
| dtypes  |                 返回每列数据的数据类型。                 |
|  empty  | DataFrame中没有数据或者任意坐标轴的长度为0，则返回True。 |
|  ndim   |                轴的数量，也指数组的维数。                |
|  shape  |          返回一个元组，表示了 DataFrame 维度。           |
|  size   |                 DataFrame中的元素数量。                  |
| values  |        使用 numpy 数组表示 DataFrame 中的元素值。        |
| head()  |                    返回前 n 行数据。                     |
| tail()  |                    返回后 n 行数据。                     |
| shift() |                将行或列移动指定的步幅长度                |

> 数据创建

```python
import pandas as pd
import numpy as np
d = {'Name':pd.Series(['python编程大全','hadoop基础',"hive进阶",'spark基础','flink进阶','mysql从入门到成神','java之路']),
   'years':pd.Series([5,6,15,28,3,19,23]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
#构建DataFrame
df = pd.DataFrame(d)
#输出series
print(df)
```

- T 转置

  > 返回 DataFrame 的转置，也就是把行和列进行交换。

  ```python
  import pandas as pd
  import numpy as np
  d = {'Name':pd.Series(['python编程大全','hadoop基础',"hive进阶",'spark基础','flink进阶','mysql从入门到成神','java之路']),
     'years':pd.Series([5,6,15,28,3,19,23]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
  #构建DataFrame
  df = pd.DataFrame(d)
  #输出series
  print(df.T)
  ```

- #####  axes

  > 返回一个行标签、列标签组成的列表

  ```python
  import pandas as pd
  import numpy as np
  d = {'Name':pd.Series(['python编程大全','hadoop基础',"hive进阶",'spark基础','flink进阶','mysql从入门到成神','java之路']),
     'years':pd.Series([5,6,15,28,3,19,23]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
  #构建DataFrame
  df = pd.DataFrame(d)
  #输出series
  print(df.axes)
  ```

- ##### dtypes

  ```python
  import pandas as pd
  import numpy as np
  d = {'Name':pd.Series(['python编程大全','hadoop基础',"hive进阶",'spark基础','flink进阶','mysql从入门到成神','java之路']),
     'years':pd.Series([5,6,15,28,3,19,23]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
  #构建DataFrame
  df = pd.DataFrame(d)
  #输出行、列标签
  print(df.dtypes)
  ```

- ##### empty

  > 返回一个布尔值，判断输出的数据对象是否为空，若为 True 表示对象为空

  ```python
  import pandas as pd
  import numpy as np
  d = {'Name':pd.Series(['python编程大全','hadoop基础',"hive进阶",'spark基础','flink进阶','mysql从入门到成神','java之路']),
     'years':pd.Series([5,6,15,28,3,19,23]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
  #构建DataFrame
  df = pd.DataFrame(d)
  #判断输入数据是否为空
  print(df.empty)
  ```

- ##### ndim

  > 返回数据对象的维数。DataFrame 是一个二维数据结构

  ```python
  import pandas as pd
  import numpy as np
  d = {'Name':pd.Series(['python编程大全','hadoop基础',"hive进阶",'spark基础','flink进阶','mysql从入门到成神','java之路']),
     'years':pd.Series([5,6,15,28,3,19,23]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
  #构建DataFrame
  df = pd.DataFrame(d)
  #DataFrame的维度
  print(df.ndim)
  ```

- ##### shape

  > 返回一个代表 DataFrame 维度的元组。返回值元组 (a,b)，其中 a 表示行数，b 表示列数

  ```python
  import pandas as pd
  import numpy as np
  d = {'Name':pd.Series(['python编程大全','hadoop基础',"hive进阶",'spark基础','flink进阶','mysql从入门到成神','java之路']),
     'years':pd.Series([5,6,15,28,3,19,23]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
  #构建DataFrame
  df = pd.DataFrame(d)
  #DataFrame的形状
  print(df.shape)
  ```

- ##### size

  ```python
  import pandas as pd
  import numpy as np
  d = {'Name':pd.Series(['python编程大全','hadoop基础',"hive进阶",'spark基础','flink进阶','mysql从入门到成神','java之路']),
     'years':pd.Series([5,6,15,28,3,19,23]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
  #构建DataFrame
  df = pd.DataFrame(d)
  #DataFrame的中元素个数
  print(df.size)
  ```

- ##### values

  ```python
  import pandas as pd
  import numpy as np
  d = {'Name':pd.Series(['python编程大全','hadoop基础',"hive进阶",'spark基础','flink进阶','mysql从入门到成神','java之路']),
     'years':pd.Series([5,6,15,28,3,19,23]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
  #构建DataFrame
  df = pd.DataFrame(d)
  #DataFrame的数据
  print(df.values)
  ```

- ##### head()和tail()查看数据  默认还是取5条

  ```python
  import pandas as pd
  import numpy as np
  d = {'Name':pd.Series(['python编程大全','hadoop基础',"hive进阶",'spark基础','flink进阶','mysql从入门到成神','java之路']),
     'years':pd.Series([5,6,15,28,3,19,23]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
  #构建DataFrame
  df = pd.DataFrame(d)
  #获取前3行数据
  print(df.head(3))
  #获取后2行数据
  print(df.tail(2))
  ```

- ##### shift()移动行或列

  > 语法格式：
  >
  > ```python
  > DataFrame.shift(periods=1, freq=None, axis=0)
  > ```

  | 参数名称       | 说明                                                         |
  | -------------- | ------------------------------------------------------------ |
  | peroids        | 类型为int，表示移动的幅度，可以是正数，也可以是负数，默认值为1。 |
  | freq           | 日期偏移量，默认值为None，适用于时间序。取值为符合时间规则的字符串。 |
  | axis           | 如果是 0 或者 “index” 表示上下移动，如果是 1 或者 “columns” 则会左右移动。 |
  | **fill_value** | 该参数用来填充缺失值。                                       |

  - peroids

  ```python
  import pandas as pd 
  info= pd.DataFrame({'a_data': [40, 28, 39, 32, 18], 
  'b_data': [20, 37, 41, 35, 45], 
  'c_data': [22, 17, 11, 25, 15]}) 
  #移动幅度为3
  info.shift(periods=3)  
  ```

  - fill_value 参数填充 DataFrame 中的缺失值

  ```python
  import pandas as pd 
  info= pd.DataFrame({'a_data': [40, 28, 39, 32, 18], 
  'b_data': [20, 37, 41, 35, 45], 
  'c_data': [22, 17, 11, 25, 15]}) 
  #移动幅度为3
  print(info.shift(periods=3))
  #将缺失值和原数值替换为52
  info.shift(periods=3,axis=1,fill_value= 52)  
  print('---------------')
  info2 = info.shift(periods=3)
  info3 = info2.fillna('丢啦')  # 只填充NaN值
  print(info3)
  ```

## 2.4、Pandas数学分析（描述性统计）

> 常用函数如下：

| 函数名称  |                           描述说明                           |
| :-------: | :----------------------------------------------------------: |
|  count()  |                    统计某个非空值的数量。                    |
|   sum()   |                             求和                             |
|  mean()   |                            求均值                            |
| median()  |                           求中位数                           |
|  mode()   |                            求众数                            |
|   std()   |                           求标准差                           |
|   min()   |                           求最小值                           |
|   max()   |                           求最大值                           |
|   abs()   |                           求绝对值                           |
|  prod()   |                      求所有数值的乘积。                      |
| cumsum()  |     计算累计和，axis=0，按照行累加；axis=1，按照列累加。     |
| cumprod() |     计算累计积，axis=0，按照行累积；axis=1，按照列累积。     |
|  corr()   | 计算数列或变量之间的相关系数，取值-1到1，值越大表示关联性越强。 |

> 在 DataFrame 中，使用聚合类方法时需要指定轴(axis)参数。

#### 常用函数

- 对行操作，默认使用 axis=0 或者使用 “index”
- 对列操作，默认使用 axis=1 或者使用 “columns”

![image-20240115221244181](https://gitee.com/xiaohuya1/image_test/raw/master/img/202401152212282.png)

> axis=0 表示按垂直方向进行计算，而 axis=1 则表示按水平方向。

> 数据创建

```python
import pandas as pd
import numpy as np
#创建字典型series结构
d = {'Name':pd.Series(['小虎','小杰','小龙','小明','小赵','小李','小陈',
   '老李','老王','小唐','老覃','小阳']),
   'Age':pd.Series([25,26,25,23,18,29,18,14,19,20,24,21]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])
}
df = pd.DataFrame(d)
print(df)
```

- ##### sum()求和

  > 在默认情况下，返回 axis=0 的所有值的和

  ```python
  import pandas as pd
  import numpy as np
  #创建字典型series结构
  d = {'Name':pd.Series(['小虎','小杰','小龙','小明','小赵','小李','小陈',
     '老李','老王','小唐','老覃','小阳']),
     'Age':pd.Series([25,26,25,23,18,29,18,14,19,20,24,21]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])
  }
  df = pd.DataFrame(d)
  #默认axis=0或者使用sum("index")
  print(df.sum())
  
  #也可使用sum("columns")或sum(1)
  print(df.sum(axis=1))
  ```

- ##### mean()求均值

  ```python
  import pandas as pd
  import numpy as np
  #创建字典型series结构
  d = {'Name':pd.Series(['小虎','小杰','小龙','小明','小赵','小李','小陈',
     '老李','老王','小唐','老覃','小阳']),
     'Age':pd.Series([25,26,25,23,18,29,18,14,19,20,24,21]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])
  }
  df = pd.DataFrame(d)
  print(df.mean())
  ```

- ##### std()求标准差

  ```python
  import pandas as pd
  import numpy as np
  #创建字典型series结构
  d = {'Name':pd.Series(['小虎','小杰','小龙','小明','小赵','小李','小陈',
     '老李','老王','小唐','老覃','小阳']),
     'Age':pd.Series([25,26,25,23,18,29,18,14,19,20,24,21]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])
  }
  df = pd.DataFrame(d)
  print(df.std())
  ```

  > **注意，平均数相同的两组数据，标准差未必相同。**

- ##### describe() 函数显示与 DataFrame 数据列相关的统计信息摘要。

  ```python
  import pandas as pd
  import numpy as np
  #创建字典型series结构
  d = {'Name':pd.Series(['小虎','小杰','小龙','小明','小赵','小李','小陈',
     '老李','老王','小唐','老覃','小阳']),
     'Age':pd.Series([25,26,25,23,18,29,18,14,19,20,24,21]),
     'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])
  }
  df = pd.DataFrame(d)
  #求出数据的所有描述信息
  print(df.describe())
  ```

## 2.5、Pandas csv读写文件

> xxx.csv  列之间的默认分隔符是英文逗号
>
> xxx.xlsx 记事本打开是看不懂的

#### read_csv()读文件

```python
# 基本语法如下，pd为导入Pandas模块的别名：
pd.read_csv(filepath_or_buffer: Union[str, pathlib.Path, IO[~AnyStr]],
            sep=',', delimiter=None, header='infer', names=None, index_col=None,
            usecols=None, squeeze=False, prefix=None, mangle_dupe_cols=True,
            dtype=None, engine=None, converters=None, true_values=None,
            false_values=None, skipinitialspace=False, skiprows=None,
            skipfooter=0, nrows=None, na_values=None, keep_default_na=True,
            na_filter=True, verbose=False, skip_blank_lines=True,
            parse_dates=False, infer_datetime_format=False,
            keep_date_col=False, date_parser=None, dayfirst=False,
            cache_dates=True, iterator=False, chunksize=None,
            compression='infer', thousands=None, decimal: str = '.',
            lineterminator=None, quotechar='"', quoting=0,
            doublequote=True, escapechar=None, comment=None,
            encoding=None, dialect=None, error_bad_lines=True,
            warn_bad_lines=True, delim_whitespace=False,
            low_memory=True, memory_map=False, float_precision=None)
```

> 一般情况下，会将读取到的数据返回一个DataFrame，当然按照参数的要求会返回指定的类型。

##### 参数说明

###### 传参路径

> filepath_or_buffer为第一个参数，没有默认值，也不能为空，根据Python的语法，第一个参数传参时可以不写参数名。可以传文件路径：

```python
# 支持文件路径或者文件缓冲对象
# 本地相对路径
pd.read_csv('data/demo1.csv') # 注意目录层级
pd.read_csv('demo1.csv') # 如果文件与代码文件在同一目录下
pd.read_csv('data/my/my.data') # CSV文件的扩展名不一定是.csv
# 本地绝对路径
pd.read_csv('C:\\Users\\xiaohu\\Desktop\\demo1.csv')
# 使用URL
pd.read_csv('https://www.xiaohu.com/file/data/dataset/demo1.csv')
```

> 可以传数据字符串，即CSV中的数据字符以字符串形式直接传入：

```python
from io import StringIO
data = ('col1,col2,col3\n'
        'a,b,1\n'
        'a,b,2\n'
        'c,d,3')
 
pd.read_csv(StringIO(data))
pd.read_csv(StringIO(data), dtype=object)
```

###### 分隔符

```python
# sep参数是字符型的，代表每行数据内容的分隔符号，默认是逗号，另外常见的还有制表符（\t）、空格等，根据数据的实际情况传值。
# 数据分隔符默认是逗号，可以指定为其他符号
pd.read_csv(data, sep='\t') # 制表符分隔tab
pd.read_table(data) # read_table 默认是制表符分隔tab
pd.read_csv(data, sep='|') # 制表符分隔tab
pd.read_csv(data,sep="(?<!a)\|(?!1)", engine='python') # 使用正则表达式
```

```python
data = pd.read_csv("C:\\Users\\xiaohu\\Desktop\\demo1.csv", encoding="gbk", sep=",|:|;", engine="python", header=0)
print(data)
```

![image-20240115222805800](https://gitee.com/xiaohuya1/image_test/raw/master/img/202401152228864.png)

###### index_col

> 这个参数是用来决定读进来的数据哪一列做索引的。
>
> 这个参数的缺省值是False，就是什么都不做的意思。
>
> 咱们来指定第一列看看，第一列在Python里被标做1：(从0开始)

```python
data = pd.read_csv("C:\\Users\\xiaohu\\Desktop\\demo1.csv", encoding="gbk", index_col=1)
```

![image-20240115222818232](https://gitee.com/xiaohuya1/image_test/raw/master/img/202401152228290.png)

###### usecols

> 这个参数可以指定你从文件中读取哪几列。比如这样：

```python
data = pd.read_csv("C:\\Users\\xiaohu\\Desktop\\demo1.csv", encoding="gbk", usecols=[2,3])
```

![image-20240115222830029](https://gitee.com/xiaohuya1/image_test/raw/master/img/202401152228079.png)

###### nrows

> 指定读取记录多少行。

```python
data = pd.read_csv("C:\\Users\\xiaohu\\Desktop\\demo1.csv", encoding="gbk", nrows=10)
```

![image-20240115222845116](https://gitee.com/xiaohuya1/image_test/raw/master/img/202401152228174.png)

#### to_csv()写文件

> 将Dataframe保存位一个csv文件

```python
df.to_csv("a.csv")
```

![image-20240115222852998](https://gitee.com/xiaohuya1/image_test/raw/master/img/202401152228044.png)

> 写CSV的函数to_csv()参数很多，选几个比较重要的给大家说一下。

##### 参数说明

###### index

> 缺省index=True，就是上面看到的a到d是索引号。如果你不加这个参数，写文件时会连带索引号一起写入。

```python
df.to_csv("a.csv", index=False)
```

![image-20240115222900825](https://gitee.com/xiaohuya1/image_test/raw/master/img/202401152229869.png)

###### columns

> 按指定的列写入文件，我在下面只写入文件1列，有意去掉了读操作。

```python
df.to_csv("a.csv", index=False,columns=['two'])
```

![image-20240115222909397](https://gitee.com/xiaohuya1/image_test/raw/master/img/202401152229440.png)

###### encoding

> encoding主要是为了兼容Python2的一些中文操作。
>
> 大家知道由于计算机的发展历史，中文以及中文语系（包括日文、韩文等）并没有西方字母排列的那么规范。导致我们在不同的系统环境、不同的编程语言下都有可能会生成编码不一样的中文文件来。
>
> 这样的文件打印出来没差别，但作为电子文件保留下来，若干年后的人在打开时，会由于不知道中文用的是哪套编码而出现乱码。乱码不仅仅是简体和繁体中文的问题。
>
> 建议在写文件时最好加入encoding参数，并制定编码为“utf-8”，这也是目前全球应用最广泛的编码规则。

###### sep

> 这是分隔符参数，缺省列与列之间用逗号分隔。不过有很多单位由于历史数据采用的分隔符多种多样，为了适应这种情况，你可以用这个参数指定分隔符。

```python
df.to_csv("a.csv", sep='\t')
```

![image-20240115222918518](https://gitee.com/xiaohuya1/image_test/raw/master/img/202401152229560.png)

# 3、matplotlib

## 3.1 柱状图

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

mpl.rcParams["font.family"] = "FangSong"  # 设置字体

mpl.rcParams["axes.unicode_minus"] = False  # 正常显示负号

print(np.random.rand(10,4), type(np.random.rand(10,4)))

list1 = [
    [99, 98, 97, 95, 89],
    [89, 98, 76, 90, 88],
    [76, 90, 98, 89, 89],
    [99, 98, 97, 95, 89],
    [96, 88, 93, 92, 99],
    [94, 92, 98, 93, 81],
    [92, 91, 91, 98, 81]
]
array1 = np.array(list1)
df = pd.DataFrame(array1, index=['第1次测试','第2次测试','第3次测试','第4次测试','第5次测试','第6次测试','第7次测试'], columns=['第一组','第二组','第三组','第四组','第五组'])
# 或使用df.plot(kind="bar")
df.plot.bar()
# plt.bar(['第1次测试','第2次测试','第3次测试','第4次测试','第5次测试','第6次测试','第7次测试'], [11,22,33,44,55,66,77])
plt.xticks(rotation=360)
plt.show()
```

![image-20240116165812690](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240116165812690.png)

- 横向的

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

mpl.rcParams["font.family"] = "FangSong"  # 设置字体
mpl.rcParams["axes.unicode_minus"] = False  # 正常显示负号

print(np.random.rand(10,4), type(np.random.rand(10,4)))

list1 = [
    [99, 98, 97, 95, 89],
    [89, 98, 76, 90, 88],
    [76, 90, 98, 89, 89],
    [99, 98, 97, 95, 89],
    [96, 88, 93, 92, 99],
    [94, 92, 98, 93, 81],
    [92, 91, 91, 98, 81]
]
array1 = np.array(list1)

df2 = pd.DataFrame(array1, index=['第1次测试','第2次测试','第3次测试','第4次测试','第5次测试','第6次测试','第7次测试'],columns=['第一组','第二组','第三组','第四组','第五组'])
print(df2)
df2.plot.barh(stacked=True)
plt.xticks(rotation=360)
plt.show()
```

## 3.2 散点图(机器学习的聚类)

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
# 创建一个DataFrame
data = {'x': [1, 2, 3, 4, 5], 'y': [2, 4, 6, 8, 10]}
df = pd.DataFrame(data)
# 绘制散点图
df.plot(kind='scatter', x='x', y='y')
# 显示图形
plt.show()
```

![image-20240116170741550](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240116170741550.png)

## 3.3 饼状图

```python
import matplotlib as mpl
mpl.rcParams["font.family"] = "FangSong"  # 设置字体
mpl.rcParams["axes.unicode_minus"] = False  # 正常显示负号
data1 = pd.Series({'中专': 0.2515, '大专': 0.3724, '本科': 0.3336, '硕士': 0.0368, '其他': 0.0057})
# 将序列的名称设置为空字符，否则绘制的饼图左边会出现None这样的字眼
data1.name = ''
# 控制饼图为正圆
plt.axes(aspect='equal')
# plot方法对序列进行绘图
data1.plot(kind='pie',  # 选择图形类型
           autopct='%.1f%%',  # 饼图中添加数值标签
           radius=1,  # 设置饼图的半径
           startangle=180,  # 设置饼图的初始角度
           counterclock=False,  # 将饼图的顺序设置为顺时针方向
           title='失信用户的受教育水平分布',  # 为饼图添加标题
           wedgeprops={'linewidth': 1.5, 'edgecolor': 'green'},  # 设置饼图内外边界的属性值
           textprops={'fontsize': 10, 'color': 'black'}  # 设置文本标签的属性值
           )
# 显示图形
plt.show()
```

![image-20240116171110358](https://gitee.com/xiaohuya1/image29_demo1/raw/master/img/image-20240116171110358.png)

















