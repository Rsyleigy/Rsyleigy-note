# 实验1-1：Scala前世今生

## 实验概述

熟悉Scala，了解Scala和Java之前的关系，并准备好Scala的学习工具。

## 实验环境

- AtStudy 实训平台
- IDEA2017

## 实验流程

![image.png](https://cdn.atstudy.com/lab/manual/16760061935582484.png)

## 实验目标

学习完成本实验后，您将能够

- 了解Scala
- 了解Scala和Java之间的关系
- 掌握Scala的开发环境配置

## 实验任务

### 任务一、Scala渊源

#### **【任务目标】**

了解Scala的前世今生

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20210824110318276.png?fileid=3270835009202713967)

视频-1、Scala渊源

##### 1.1 Scala概述

![image-20230131172153591](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131172153591.png)

Scala（斯嘎拉）这个名字来源于"Scalable Language(可伸缩的语言)"，它是一门基于JVM的多范式编程语言，通俗的说： **Scala是一种运行在JVM上的函数式的面向对象语言**。之所以这样命名，是因为它的设计目标是：随着用户的需求一起成长，Scala可被广泛应用于各种编程任务，从编写小型的脚本到构建巨型系统，它都能胜任。正因如此，Scala得以提供一些出众的特性，例如：**它集成了面向对象编程和面向函数式编程的各种特性，以及更高层的并发模型**。

总而言之, Scala融汇了许多前所未有的特性，而同时又运行于JVM之上，随着开发者对Scala的兴趣日增，以及越来越多的工具支持，无疑Scala语言将成为你手上一门必不可少的工具。

- `基于JVM解释：Scala的运行环境和Java类似, 也是依赖JVM的`
- `多范式解释：Scala支持多种编程风格`

##### 1.2 Scala发展历史

**Scala之父是：Martin·Odersky(马丁·奥德斯基)** 是编译器及编程的狂热爱好者，长时间的编程之后，希望发明一种语言，能够让写程序这样的基础工作变得高效、简单。所以当接触到JAVA语言后，对JAVA这门便携式、运行在网络、且存在垃圾回收的语言产生了极大的兴趣，所以决定将函数式编程语言的特点融合到JAVA中，由此发明了两种语言（Pizza&Scala） Pizza和Scala极大地推动了Java编程语言的发展。

- jdk5.0的泛型、for循环增强、自动类型转换等，都是从Pizza引入的新特性。
- jdk8.0 的类型推断、Lambda表达式就是从scala引入的特性。

且现在主流JVM的javac编译器就是马丁·奥德斯基编写出来的，Jdk5.0&Jdk8.0的编辑器就是马丁·奥德斯基写的，因此马丁·奥德斯基 一个人的战斗力抵得上一个Java开发团队。

可以说Scala是为了扩展丰富Java语言的特性而诞生的。

![1574652913536](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/1574652913536.png)

##### 1.3 Scala和Java关系

Scala语言来源于java，scala以java的虚拟机（JVM）为运行环境，scala源码(.scala)会编译成.class文件。

###### 1.3.1 程序的执行流程对比

**Java程序编译执行流程**

![1556551819121](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/1556551819121.png)

**Scala程序编译执行流程**

![1556551904384](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/1556551904384.png)

###### 1.3.2 代码对比

**需求:**

定义一个用户类, 属性为：姓名和年龄，然后在测试类中创建对象并测试

**Java代码**

```
//定义用户类
public class User{
    private String name;		//姓名
    private int age;			//年龄
    
    //空参和全参构造
    public User(){}
    
    public User(String name, int age){
        this.name = name;
        this.age = age;
    }
    
    //getXxx()和setXxx()方法
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}

//测试类
public class UserDemo {
     public static void main(String[] args) {
        User s1 = new User("张三", 23);	//创建User类型的对象s1, 并赋值
        System.out.println(s1);		      //打印对象, 查看结果.
    }
}复制代码
```

**Scala代码**

```
case class User(var name:String, var age:Int)	//定义一个User类
val s1 = User("张三", 23)						   //创建User类型的对象s1, 并赋值
println(s1)										 //打印对象, 查看结果.复制代码
```

##### 1.4 Scala语言特点

Scala是一门以Java虚拟机（JVM）为运行环境并将面向对象和函数式编程的最佳特性结合在一起的静态类型编程语言（静态语言需要提前编译的如：Java、c、c++等，动态语言如：js）。

- Scala是一门多范式的编程语言，Scala支持面向对象和函数式编程。（多范式，就是多种编程方法的意思。有面向过程、面向对象、泛型、函数式四种程序设计方法。）
- Scala源代码（.scala）会被编译成Java字节码（.class），然后运行于JVM之上，并可以调用现有的Java类库，实现两种语言的无缝对接。
- Scala单作为一门语言来看，非常的简洁高效**。**
- Scala在设计时，马丁·奥德斯基是参考了Java的设计思想，可以说Scala是源于Java，同时马丁·奥德斯基也加入了自己的思想，将函数式编程语言的特点融合到JAVA中。

### 任务二、Scala“屠龙刀”

#### **【任务目标】**

学习Scala，首先需要掌握Scala开发工具的使用。选择一款好的开发工具，对于我们的写程序如宝刀在手、天下独有。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20210824110318276.png?fileid=3270835009201993850)

视频-2、Scala屠龙刀

##### 2.1 Scala解释器

scala解释器是用来编译和执行scala代码的，一般用来学习scala基本语法，scala解释器像linux命令一样，执行一条代码，马上就可以让我们看到执行结果，用来测试比较方便。

我们接下来学习：

- 启动scala解释器
- 在scala解释器中执行scala代码
- 退出scala解释器

------

（1）启动scala解释器

要启动scala解释器，只需要以下几步：

- 打开一个终端窗口
- `source`命令环境变量生效
- 输入`scala`即可

![image-20230131220219791](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131220219791.png)

------

（2）执行scala代码

在scala的命令提示窗口中输入`println("Hello World")`，回车执行。

![image-20230131220347670](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131220347670.png)

------

（3）退出解释器

**方式一: 点击右上角的"×"**

![image-20230131220518256](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131220518256.png)

**方式二: 输入`:quit`退出 **

![image-20230131220614551](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131220614551.png)

##### 2.2 IDEA 创建Scala程序

IntelliJ IDEA主要用于支持Java、Scala、Groovy 等语言的开发工具，同时具备支持目前主流的技术和框架，擅长于企业应用、移动应用和Web应用的开发，在业界被公认为最好的java开发工具，尤其在智能代码助手、代码自动提示、各类版本工具(git、svn等)、JUnit整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。

这里主要是要求大家掌握IDEA如何创建Scala程序。

（1）打开 IDEA->点击左侧的 Flie->选择 New->选择 Project…

![image-20230131163107893](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131163107893.png)

（2）创建一个 Maven 工程，并点击 next

![image-20230131163144366](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131163144366.png)

（3）GroupId 输入 `com.atstudy`->ArtifactId 输入 scala->点击 next->点击 Finish

> 注意：工程存储路径一定不要有中文和空格。

![image-20230131163256892](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131163256892.png)

（4）指定项目工作目录空间

![image-20230131163340578](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131163340578.png)

（5）默认下，Maven 不支持 Scala 的开发，需要引入 Scala 框架。

在 scala001项目上，点击右键-> Add Framework Support... ->选择 Scala->点击 OK

![image-20230131164517201](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131164517201.png)

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20210823165604377-1675174068949.png)**注意：**

> 如果是第一次引入框架，Use libary 看不到，需要选择你的 Scala 安装目录，然后工具就会自动识别，就会显示 user libary。

（6）创建项目的源文件目录

右键点击 main 目录->New->点击 Diretory -> 写个名字（比如 scala）。

右键点击 scala 目录->Mark Directory as->选择 Sources root，观察文件夹颜色发生变化。

![image-20230131164715482](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131164715482.png)

（7）在 scala 包下，创建包 `com.atstudy.chapter01` 包名和 Hello 类名，

右键点击 scala 目录->New->Package->输入 `com.atstudy.chapter01`->点击 OK。

右键点击 `com.atstudy.chapter01`->New->Scala Class->Kind 项选择 Object->Name 项输入Hello。

![image-20230131164903052](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131164903052.png)

（8）编写输出 Hello Scala 案例

在类中中输入 main，然后回车可以快速生成 main 方法；

在 main 方法中输入 println("hello scala")

![image-20230131165117467](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131165117467.png)

运行后，观察控制台打印输出：

hello scala

hello scala

> 说明：Java 中部分代码也是可以在 Scala 中运行。

##### 2.3 **关联** **Scala** **源码**

在使用 Scala 过程中，为了搞清楚 Scala 底层的机制，需要查看源码，下面看看如何关联和查看 Scala 的源码包。

（1）查看源码

例如查看 Array 源码。按住 ctrl 键->点击 Array->右上角出现 Attach Soures…

![image-20230131223511386](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131223511386.png)

![image-20230131223543558](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131223543558.png)

（2）关联源码

- 将我们的源码包 scala-2.12.11-source.zip 拷贝到 /opt/module/scala-2.12.11/lib/ 文件夹下
- 点击 Attach Sources…->选择 /opt/module/scala-2.12.11/lib/scala-2.12.11-source.zip，这个文件，确定Choose Roots。

![image-20230131224007174](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131224007174.png)

之后就自动打开了Array的源码

![image-20230131224143077](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20230131224143077.png)

### 任务三、案例：做最好的自己

#### **【任务目标】**

实现Scala的第一个程序，测试Scala和Java之间可以无缝互调(`即: Scala兼容Java，可以访问庞大的Java类库`)。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20210824110318276.png?fileid=3270835009202165848)

视频-3、案例：做最好的自己

##### 3.1 任务需求

提示用户录入他/她最想对自己说的一句话，然后将这句话打印到控制台上。

##### 3.2 实现过程

（1）思路分析

1. 因为涉及到键盘录入了，所以先导包。
2. 提示用户录入他 / 她最想对自己说的一句话。
3. 接收用户录入的内容，并打印。

（2）参考代码

```
//1. 导入Java中的Scanner类.						   		引入Java类库
import java.util.Scanner

object Hello {
  def main(args: Array[String]): Unit = {
    //2. 提示用户录入他/她最想对自己说的一句话.			   Scala代码
    println("请录入一句您最想对自己说的一句话: ")

    //3. 打印用户录入的内容.								 Scala代码 + Java类库
    //不忘初心, 方得始终, 做最好的自己!
    println("我最想对自己说: " + new Scanner(System.in).nextLine())
  }
}复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_1/image-20210823165920540.png)**小彩蛋**

其实Scala中也有自己独有的`接收用户键盘录入数据`的功能，远比上边的写法要简单的多、要优雅的多。这种写法在后续章节我们会学习到，预知后事如何，且听下回分晓。





# 实验1-2：Scala基础入门

## 实验概述

掌握基础语法，这是我熟悉任何一门编程语言的基础，当然Scala的这些基础语法和其他编程语言也基本类似。

## 实验环境

- AtStudy 实训平台
- Scala2

## 实验流程

![image.png](https://cdn.atstudy.com/lab/manual/16760062546766443.png)

## 实验目标

学习完成本实验后，您将能够

- 掌握变量和常量的基本使用技巧
- 掌握Scala中的各种数据类型
- 掌握运算符的使用

## 实验任务

### 任务一、变量和常量

#### **【任务目标】**

掌握变量，字符串的定义和使用

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_2/image-20210824110318276.png?fileid=3270835009203363409)

视频-1、变量和常量

##### 1.1 输出语句和分号

###### 1.1.1 输出语句

**方式一: 换行输出**

```
格式:  println(里边写你要打印到控制台的数据);复制代码
```

**方式二: 不换行输出**

```
格式: print(里边写你要打印到控制台的数据);复制代码
```

> 注意: `不管是println(), 还是print()语句, 都可以同时打印多个值。格式为: println(值1, 值2, 值3...)`

###### 1.1.2 分号

Scala语句中，单行代码最后的分号可写可不写。如果是多行代码写在一行，则中间的分号不能省略，最后一条代码的分号可省略不写。

示例:

```
println("Hello, Scala!")			//最后的分号可写可不写

//如果多行代码写在一行, 则前边语句的分号必须写, 最后一条语句的分号可以省略不写
println("Hello"); println("Scala")	复制代码
```

##### 1.2 变量和常量

###### 1.2.1 常量

常量指的是: 在程序的运行过程中, 其值不能发生改变的量.

（1）分类

- 字面值常量(常用的有以下几种)
  - 整型常量
  - 浮点型常量
  - 字符常量
  - 字符串常量
  - 布尔常量
  - 空常量
- 自定义常量

（2）代码演示

```
//整型常量
println(10)
//浮点型常量
println(10.3)
//字符常量, 值要用单引号括起来
println('a')
//字符串常量, 值要用双引号括起来
println("abc")
//布尔常量, 值只有true和false
println(true)
//空常量
println(null)复制代码
```

###### 1.2.2 变量

变量，指的就是在程序的执行过程中，其值可以发生改变的量。

定义格式如下:

（1）语法格式

Java变量定义

```
int a = 0;复制代码
```

在scala中，可以使用`val`或者`var`来定义变量，语法格式如下:

```
val/var 变量名[:变量类型] = 初始值复制代码
```

其中

- `val`定义的是不可重新赋值的变量，也就是**自定义常量**。
- `var`定义的是可重新赋值的变量。

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_2/image-20210823165604377.png)**注意**

> scala中定义变量时，类型写在变量名后面

（2）实例操作

**需求：**定义一个变量保存一个人的名字"tom"

**步骤**

1. 打开scala解释器
2. 定义一个字符串类型的变量用来保存名字

**参考代码**

```
scala> val name:String = "tom"
name: String = tom复制代码
```

（3）val和var变量的区别

**示例**

给名字变量进行重新赋值为Jim，观察其运行结果

**参考代码**

```
scala> name = "Jim"
<console>:12: error: reassignment to val
       name = "Jim"复制代码
```

**示例**

使用`var`重新定义变量来保存名字"tom"，并尝试重新赋值为Jim，观察其运行结果

**参考代码**

```
scala> var name:String = "tom"
name: String = tom

scala> name = "Jim"
name: String = Jim复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_2/image-20210823165604377.png)**注意**

> 优先使用`val`定义变量，如果变量需要被重新赋值，才使用`var`

（4）使用类型推断来定义变量

scala的语法要比Java简洁，我们可以使用一种更简洁的方式来定义变量。

**示例**

使用更简洁的语法定义一个变量保存一个人的名字"tom"

**参考代码**

```
scala> val name = "tom"
name: String = tom复制代码
```

scala可以自动根据变量的值来自动推断变量的类型，这样编写代码更加简洁。

###### 1.2.3 总结

- 声明变量时，类型可以省略，编译器自动推导，即类型推导。
- 类型确定后，就不能修改，说明 Scala 是强数据类型语言。
- 变量声明时，必须要有初始值。
- 在声明/定义一个变量时，可以使用 var 或者 val 来修饰，var 修饰的变量可改变，val 修饰的变量不可改。
  - var 修饰的对象引用可以改变，val 修饰的对象则不可改变，但对象的状态（值）却是可以改变的。（比如：自定义对象、数组、集合等等）

```
object TestVar {
     def main(args: Array[String]): Unit = {
        // p1 是 var 修饰的，p1 的属性可以变，而且 p1 本身也可以变
         var p1 = new Person()
         p1.name = "dalang"
         p1 = null

         // p2 是 val 修饰的，那么 p2 本身就不可变（即 p2 的内存地址不能变），但是，p2 的属性是可以变，因为属性并没有用 val 修饰。
         val p2 = new Person()
         p2.name="jinlian"
        // p2 = null // 错误的，因为 p2 是 val 修饰的
     }
}

class Person{
     var name : String = "jinlian"
}复制代码
```

##### 1.3 标识符的命名规范

实际开发中，我们会编写大量的代码，这些代码中肯定会有变量、方法、类等。那它们该如何命名呢？这就需要用到标识符了，**标识符就是用来给变量、方法、类等起名字的。**

Scala中的标识符和Java中的标识符非常相似。

**命名规范**

- 必须由`大小写英文字母, 数字, 下划线_, 美元符$`, 这四部分任意组合组成。
- 数字不能开头。
- 不能和Scala中的关键字重名。
- 最好做到**见名知意。**

**实操案例**

- 变量或方法：从第二个单词开始，每个单词的首字母都大写，其他字母全部小写(小驼峰命名法)。

  ```
  zhangSanAge, student_Country, getSum复制代码
  ```

- 类或特质(Trait)： 每个单词的首字母都大写，其他所有字母全部小写(大驼峰命名法)。

  ```
  Person, StudentDemo, OrderItems复制代码
  ```

- 包：全部小写，一般是公司的域名反写，多级包之间用 **.** 隔开。

  ```
  com.atstudy.add,  cn.atstudy.update复制代码
  ```

##### 1.4 字符串输出

Scala提供多种定义字符串的方式，将来我们可以根据需要来选择最方便的定义方式。

- 使用双引号
- 使用插值字符串
- 使用三引号

###### 1.4.1 使用双引号

语法

```
val/var 变量名 = “字符串”复制代码
```

**示例**

有一个人的名字叫"hadoop"，请打印他的名字以及名字的长度。

**参考代码**

```
scala> println(name + name.length)
hadoop6复制代码
```

###### 1.4.2 使用插值字符串

Scala中，可以使用插值表达式来定义字符串，有效避免大量字符串的拼接。

语法

```
val/var 变量名 = s"${变量/表达式}字符串"复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_2/image-20210823165604377.png)**注意**

> - 在定义字符串之前添加`s`
> - 在字符串中，可以使用`${}`来引用变量或者编写表达式

**示例**

定义若干个变量，分别保存："zhangsan"、23、"male"，定义一个字符串，保存这些信息。

打印输出：name=zhangsan, age=23, sex=male

**参考代码**

```
scala> val name = "zhangsan"
name: String = zhangsan

scala> val age = 23
age: Int = 23

scala> val sex = "male"
sex: String = male

scala> val result = s"name=${name}, age=${age}, sex=${sex}"
result: String = name=zhangsan, age=23, sex=male

scala> println(result)
name=zhangsan, age=23, sex=male复制代码
```

###### 1.4.3 使用三引号

如果有大段的文本需要保存，就可以使用三引号来定义字符串。例如：保存一大段的SQL语句。三个引号中间的所有内容都将作为字符串的值。

语法

```
val/var 变量名 = """字符串1
字符串2"""复制代码
```

**示例**

定义一个字符串，保存以下SQL语句

```
select
    *
from
    t_user
where
    name = "zhangsan"复制代码
```

打印该SQL语句

**参考代码**

```
val sql = """select
     | *
     | from
     |     t_user
     | where
     |     name = "zhangsan""""

println(sql)复制代码
```

或者将插值字符串和三引号相结合

![image-20230201102320110](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_2/image-20230201102320110.png)

### 任务二、数据类型

#### **【任务目标】**

数据类型是用来约束变量(常量)的取值范围的，Scala也是一门强类型语言，它里边的数据类型绝大多数和Java一样。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_2/image-20210824110318276.png?fileid=3270835009203363409)

视频-2、数据类型

##### 2.1 数据类型地图

Scala数据类型的整体结构：

- Scala中一切数据都是对象，都是Any的子类。
- Scala中数据类型分为两大类：数值类型（AnyVal）、引用类型（AnyRef），不管是值类型还是引用类型都是对象。

![image-20230201103528090](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_2/image-20230201103528090.png)

##### 2.2 数据类型特点

这里主要先介绍值类型的各种特点，对于引用类型我们在后面对象和集合章节中进行相应介绍。

（1）整数类型

Scala 的整数类型就是用于存放整数值的，比如 12，30，3456 等等，

- 主要有：Byte[1]、Short[2]、Int[4]、Long[8]
- Scala 的整型，**默认为 Int 型**，声明 Long 型，须后加‘l’或‘L’

```
var n1 = 10
println(n1)

var n2 = 9223372036854775807L
println(n2)复制代码
```

- Scala 程序中变量常声明为 Int 型，除非不足以表示大数，才使用 Long

（2）浮点类型

Scala 的浮点类型可以表示一个小数，比如 123.4f，7.8，0.12 等等

- 主要有：Float(4)，Double[8]
- Scala 的浮点型常量**默认为 Double 型**，声明 Float 型常量，须后加‘f’或‘F’。

```
// 建议，在开发中需要高精度小数时，请选择 Double
 var n3 = 2.2345678912f
 var n4 = 2.2345678912
 println("n3=" + n3)
 println("n4=" + n4)复制代码
```

（3）字符类型

字符类型可以表示单个字符，字符类型是 Char。

```
//字符常量是用单引号 ' ' 括起来的单个字符。
 var c1: Char = 'a'
 println("c1=" + c1)复制代码
```

（4）布尔类型

- 布尔类型也叫 Boolean 类型，Boolean 类型数据只允许取值 true 和 false
- Boolean 类型占 1 个字节。

（5）Scala特有类型（重点）

| 类型    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| Any     | **所有类型**的父类，它有两个子类AnyRef与AnyVal               |
| AnyVal  | **所有数值类型**的父类                                       |
| AnyRef  | **所有对象类型（引用类型）**的父类                           |
| Unit    | 表示无值，Unit是AnyVal的子类，和其他语言中 void 等同。用作不返回任何结果的方法的结果 |
| Null    | Null 类型只有一个实例值 null。Null是AnyRef的子类，也就是说它是所有引用类型的子类。它的实例是可以将null赋值给任何对象类型 |
| Nothing | 所有类型的**子类**, 不能直接创建该类型实例，某个方法抛出异常时，返回的就是Nothing类型，因为Nothing是所有类的子类，那么它可以赋值为任何类型 |

- Unit 类型用来标识过程，也就是没有明确返回值的函数。

```
def sayOk : Unit = {// unit 表示没有返回值，即 void
     
 }
 println(sayOk)复制代码
```

- Null 类只有一个实例对象，Null 类似于 Java 中的 **null** 引用。**Null可以赋值给任意引用类型（AnyRef），但是不能赋值给值类型（AnyVal）**

```
class Cat {
}

//null 可以赋值给任意引用类型（AnyRef），但是不能赋值给值类型（AnyVal）
 var cat = new Cat();
 cat = null 			// 正确

 var n1: Int = null 	// 错误复制代码
```

![image-20230201110345624](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_2/image-20230201110345624.png)

- Nothing，可以作为没有正常返回值的方法的返回类型

```
def test() : Nothing={
     throw new Exception()
}

test复制代码
```

（6）类型总结：

- Scala中所有的类型都使用**大写字母**开头
- 整形使用`Int`而不是Integer
- Scala中定义变量可以不写类型，让Scala编译器自动推断
- Scala中默认的整型是Int, 默认的浮点型是: Double

##### 2.3 类型转换

当Scala程序在进行运算或者赋值动作时，范围小的数据类型值会自动转换为范围大的数据类型值，然后再进行计算。

例如：`1 + 1.1`的运算结果就是一个Double类型的`2.1`。 而有些时候，我们会涉及到一些类似于"四舍五入"的动作，要把一个小数转换成整数再来计算，这些内容就是Scala中的类型转换。

> Scala中的类型转换分为`值类型的类型转换`和`引用类型的类型转换`，这里我们先重点介绍：`值类型的类型转换`。

值类型的类型转换分为:

- 自动类型转换
- 强制类型转换

###### 2.3.1 自动类型转换

1. 解释

   范围小的数据类型值会自动转换为范围大的数据类型值，这个动作就叫：自动类型转换.

   `自动类型转换从小到大分别为:Byte, Short, Char -> Int -> Long -> Float -> Double `

2. 示例代码

   ```
   val a:Int = 3
   val b:Double = 3 + 2.21	//因为是int类型和double类型的值进行计算, 所以最终结果为: Double类型
   val c:Byte = a + 1	    //这样写会报错, 因为最终计算结果是Int类型的数据, 将其赋值Byte类型肯定不行复制代码
   ```

###### 2.3.2 强制类型转换

1. 解释

   范围大的数据类型值通过一定的格式(强制转换函数)可以将其转换成范围小的数据类型值，这个动作就叫：强制类型转换

   `注意: 使用强制类型转换的时候可能会造成精度缺失问题!`

2. 格式

```
val/var 变量名:数据类型 = 具体的值.toXxx		//Xxx表示你要转换到的数据类型复制代码
```

1. 参考代码

```
val a:Double = 5.21
val b:Int = a.toInt复制代码
```

###### 2.3.4 **数值类型和** **String** 类型间转换

在程序开发中，我们经常需要将基本数值类型转成 String 类型，或者将 String 类型转成基本数值类型。

（1）值类型的数据转换成String类型

**格式一**:

```
val/var 变量名:String = 值类型数据 + ""复制代码
```

**格式二**:

```
val/var 变量名:String = 值类型数据.toString复制代码
```

**示例**

将Int、Double、Boolean类型的数据转换成其对应的字符串形式。

**参考代码**:

```
val a1:Int = 10
val b1:Double = 2.1
val c1:Boolean = true

//方式一: 通过和空字符串拼接的形式实现
val a2:String = a1 + ""
val b2:String = b1 + ""
val c2:String = c1 + ""

//方式二: 通过toString函数实现
val a3:String = a1.toString
val b3:String = b1.toString
val c3:String = c1.toString复制代码
```

（2）String类型的数据转换成其对应的值类型

**格式:**

```
val/var 变量名:值类型 = 字符串值.toXxx	//Xxx表示你要转换到的数据类型复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_2/image-20210823161648091.png)**注意:**

> - String类型的数据转成Char类型的数据，方式有点特殊，并不是调用toChar，而是toCharArray
> - 在将 String 类型转成基本数值类型时，要确保 String 类型能够转成有效的数据，比如我们可以把"123"，转成一个整数，但是不能把"hello"转成一个整数。`var n5:Int = "12.6".toInt` 会出现 NumberFormatException 异常

**需求:**

 将字符串类型的整数、浮点数、布尔数据转成其对应的值类型数据.

**参考代码:**

```
val s1:String = "100"
val s2:String = "2.3"
val s3:String = "false"

//将字符串类型的数据转成其对应的: Int类型
val a:Int = s1.toInt
//将字符串类型的数据转成其对应的: Double类型
val b:Double = s2.toDouble
//将字符串类型的数据转成其对应的: Boolean类型
val c:Boolean = s3.toBoolean复制代码
```

##### 2.4 键盘录入

前边我们涉及到的数据，都是我们写"死"的固定的数据，这样做用户体验并不是特别好。那如果这些数据是由用户录入，然后我们通过代码接收,，就非常好玩儿了。这就是接下来我们要学习的Scala中的"键盘录入"功能。

**使用步骤**

1. 导包

   > 格式: import scala.io.StdIn

2. 通过`StdIn.readXxx()`来接收用户键盘录入的数据

   > 接收字符串数据: StdIn.readLine()
   >
   > 接收整数数据: StdIn.readInt()

**示例**

- 提示用户录入字符串, 并接收打印.

  ```
  println("请录入一个字符串: ")
  val str = StdIn.readLine()
  println("您录入的字符串内容为: " + str)复制代码
  ```

- 提示用户录入整数, 并接收打印.

  ```
  println("请录入一个整数: ")
  val num = StdIn.readInt()
  println("您录入的数字为: " + num)复制代码
  ```

### 任务三、运算符

#### **【任务目标】**

Scala 运算符的使用和 Java 运算符的使用基本相同，重点是关注个别细节上不同

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_2/image-20210824110318276.png?fileid=3270835009203216739)

视频-3、运算符

##### 3.1 算术运算符

| 运算符 | 运算       | 示例       | 结果    |
| ------ | ---------- | ---------- | ------- |
| +      | 正号       | +3         | 3       |
| -      | 负号       | b=4;-b     | -4      |
| +      | 加         | 5+5        | 10      |
| -      | 减         | 6-4        | 2       |
| *      | 乘         | 3*4        | 12      |
| /      | 除         | 5/5        | 1       |
| %      | 取模       | 7%5        | 2       |
| +      | 字符串相加 | "He"+"llo" | "Hello" |

- 对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。

```
//对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。
 var r1: Int = 10 / 3 		// 3
 println("r1=" + r1)
 var r2: Double = 10 / 3 	// 3.0
 println("r2=" + r2)
 var r3: Double = 10.0 / 3  // 3.3333
 println("r3=" + r3)
 println("r3=" + r3.formatted("%.2f")) // 含义：保留小数点 2位，使用四舍五入复制代码
```

##### 3.2 关系运算符（比较运算符）

| 运算符 | 运算     | 示例 | 结果  |
| ------ | -------- | ---- | ----- |
| ==     | 相等于   | 4==3 | false |
| !=     | 不等于   | 4!=3 | true  |
| <      | 小于     | 4<3  | false |
| >      | 大于     | 4>3  | true  |
| <=     | 小于等于 | 4<=3 | false |
| >=     | 大于等于 | 4>=3 | true  |

Java 和 Scala 中关于==的区别

- Java：==比较两个变量本身的值，即两个对象在内存中的首地址；equals 比较字符串中所包含的内容是否相同。
- Scala：==更加类似于 Java 中的 equals

```
public static void main(String[] args) {
    String s1 = "abc";
     String s2 = new String("abc");
     System.out.println(s1 == s2);
     System.out.println(s1.equals(s2));
}

//输出结果：
//false
//true复制代码
def main(args: Array[String]): Unit = {
     val s1 = "abc"
     val s2 = new String("abc")
     println(s1 == s2)
    println(s1.eq(s2))
}
//输出结果：
//true
//false复制代码
```

##### 3.3 逻辑运算符

用于连接多个条件（一般来讲就是关系表达式），最终的结果也是一个 Boolean 值。

假定：变量 A 为 true，B 为 false

| 运算符 | 描述   | 示例                       |
| ------ | ------ | -------------------------- |
| &&     | 逻辑与 | A && B 运算结果为false     |
| \|\|   | 逻辑或 | A \|\| B 运算结果为true    |
| !      | 逻辑非 | ！(A && B) 运算结果为 true |

##### 3.4 赋值运算符

赋值运算符就是将某个运算后的值，赋给指定的变量

| 运算符 | 描述                       | 示例                            |
| ------ | -------------------------- | ------------------------------- |
| =      | 简单的赋值运算符，将一个表 | C = A + B 将 A + B 表达式结果赋 |
| +=     | 相加后再赋值               | C += A 等于 C = C + A           |
| ...    |                            |                                 |

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab1_2/warning.png)**注意**

> Scala 中没有++、-- 操作符,，可以通过+=、-=来实现同样的效果

```
var r1 = 10
 
r1 += 1 // 没有++
r1 -= 2 // 没有--复制代码
```

##### 3.5 位运算符

下表中变量 a 为 60，b 为 13。

| 运算符 | 描述           | 示例                                                         |
| ------ | -------------- | ------------------------------------------------------------ |
| &      | 按位与运算符   | (a & b)输出结果为12，二进制解释：0000 1100                   |
| \|     | 按位或运算符   | (a \| b) 输出结果 61 ，二进制解释： 0011 1101                |
| ^      | 按位异或运算符 | (a ^ b) 输出结果 49 ，二进制解释：0011 0001                  |
| ~      | 按位取反运算符 | (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 |
| <<     | 左移动运算符   | a << 2 输出结果 240 ，二进制解释：                           |
| >>     | 右移动运算符   | 0011 0000a >> 2 输出结果 15 ，二进制解释：                   |
| >>>    | 无符号右移     | 0000 1111a >>>2 输出结果 15, 二进制解释: 0000 1111           |

```
// 测试：1000 << 1 =>10000
var n1 :Int =8
n1 = n1 << 1
println(n1)复制代码
```

##### 3.6 Scala运算符本质

在 Scala 中其实是没有运算符的，所有运算符都是方法。

1）当调用对象的方法时，点**.**可以省略

2）如果函数参数只有一个，或者没有参数，( )可以省略

```
// 标准的加法运算
val i:Int = 1.+(1)

// （1）当调用对象的方法时，.可以省略
val j:Int = 1 + (1)

// （2）如果函数参数只有一个，或者没有参数，()可以省略
val k:Int = 1 + 1

println(1.toString())
println(1 toString())
println(1 toString)复制代码
```

##### 3.7 经典面试题

###### 3.7.1 需求

已知有两个Int类型的变量a和b，初始化值分别为10和20，请写代码实现变量a和变量b的值的交换。

即最终结果为: a=20, b=10.

> 注意: 不允许直接写`a=20, b=10`这种代码

###### 3.7.2 参考代码

- **方式一: 通过算术运算符实现.**

  ```
  //定义两个Int类型的变量a和b, 初始化值分别为10和20
  var a = 10
  var b = 20
  //将变量a和b的计算结果赋值给变量a
  a = a + b	//a = 30, b = 20
  //计算并赋值
  b = a - b	//a = 30, b = 10
  a = a - b	//a = 20, b = 10
  //打印结果
  println("a: " + a)		//a: 20
  println("b: " + b)		//b: 10复制代码
  ```

- **方式二: 通过定义临时变量实现**

  ```
  //定义两个Int类型的变量a和b, 初始化值分别为10和20
  var a = 10
  var b = 20
  //定义临时变量temp, 记录变量a的值
  var temp = a			//a = 10, b = 20, temp = 10
  //把变量b的值赋值给a
  a = b					//a = 20, b = 20, temp = 10
  //把临时变量temp的值赋值给b
  b = temp				//a = 20, b = 10, temp = 10
  //打印结果
  println("a: " + a)		//a: 20
  println("b: " + b)		//b: 10复制代码
  ```

- **方式三: 通过位运算符实现**

  ```
  //定义两个Int类型的变量a和b, 初始化值分别为10和20
  var a = 10
  var b = 20
  //定义临时变量temp, 记录变量a和b的位异或值(这个值不需要我们计算)
  var temp = a ^ b	//即: temp = 10 ^ 20
  //通过位异或进行交换变量值	
  a = a ^ temp		//运算流程: a = a ^ temp = a ^ a ^ b = 10 ^ 10 ^ 20 = 20
  b = b ^ temp		//运算流程: b = b ^ temp = b ^ a ^ b = 20 ^ 10 ^ 20 = 10
  //打印结果
  println("a: " + a)	//a: 20
  println("b: " + b)	//b: 10复制代码
  ```





# 实验2-1：流程控制和循环

## 实验概述

在实际开发中，我们要编写成千上万行代码，代码的顺序不同，执行结果肯定也会受到一些影响，并且有些代码是满足特定条件才能执行的，有些代码是要重复执行的。那如何合理规划这些代码呢? 这就需要用到: 流程控制了。

- AtStudy 实训平台
- Scala2

## 实验流程

![image.png](https://cdn.atstudy.com/lab/manual/16760063278227167.png)

## 实验目标

学习完成本实验后，您将能够

- 掌握分支结构的格式和用法
- 掌握for循环和while循环的格式和用法
- 掌握控制跳转语句的用法
- 理解do.while循环的格式和用法

## 实验任务

### 任务一、流程控制

#### **【任务目标】**

流程控制主要是确定代码的执行流程，包括：顺序、选择（分支）、循环，这里主要是掌握前两种流程控制。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab2_1/image-20210824110318276.png?fileid=3270835009202171600)

视频-1、流程控制

##### 1.1 顺序结构

序结构是指: 程序是按照**从上至下, 从左至右的顺序, 依次逐行执行**的, 中间没有任何判断和跳转

![1575884799644](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab2_1/1575884799644.png)

> 注意: 顺序结构是Scala代码的默认流程控制结构

**代码演示**

```
val a = 10
println("a: " + a)	//打印结果为10

println("键盘敲烂, ")
println("月薪过万! ")复制代码
```

**思考题**

下边这行代码的打印结果应该是什么呢?

```
println(10 + 10 + "Hello,Scala" + 10 + 10)复制代码
```

> 提示: 代码是按照从上至下, 从左至右的顺序, 依次逐行执行的

##### 1.2 选择结构(if语句)

选择结构是指：某些代码的执行需要依赖于特定的判断条件，如果判断条件成立，则代码执行，否则，代码不执行

选择结构有三种：

- 单分支
- 双分支
- 多分支

###### 1.2.1 单分支

所谓的单分支是指：只有一个判断条件的if语句

```
if(关系表达式) {
    //具体的代码
}复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab2_1/image-20210823165604377.png)**注意：**

> - 关系表达式不管简单还是复杂, 结果必须是Boolean类型的值
> - 当条件表达式为 ture 时，就会执行{ }的代码

**需求:** 输入人的年龄，如果该同志的年龄小于 18 岁，则输出“童年”

**参考代码**

```
println("input age:")
var age = StdIn.readShort()
if (age < 18){
    println("童年")
}复制代码
```

###### 1.2.2 双分支

所谓的双分支是指：只有两个判断条件的if语句

```
if(关系表达式) {
    //代码1
} else {
    //代码2
}复制代码
```

需求：输入年龄，如果年龄小于 18 岁，则输出“童年”。否则，输出“成年”

**参考代码**

```
println("input age:")
var age = StdIn.readShort()
if (age < 18){
    println("童年")
}else{
    println("成年")
}复制代码
```

###### 1.2.3 多分支

所谓的多分支是指：有多个判断条件的if语句

```
if(关系表达式1) {
    //代码1
} else if(关系表达式2) {
    //代码2
} else if(关系表达式n) {	//else if可以有多组
    //代码n
} else {
    //代码n+1			  //所有的关系表达式都不成立的时候, 执行这里的代码.
}复制代码
```

- 需求1：输入年龄，如果年龄小于 18 岁，则输出“童年”。如果年龄大于等于 18 且小于等于 30，则输出“中年”，否则，输出“老年”。

```
println("input age")
var age = StdIn.readInt()
if (age < 18){
    println("童年")
}else if(age>=18 && age<30){
    println("中年")
}else{
    println("老年")
}复制代码
```

- 需求 2：Scala 中 if else 表达式其实是有返回值的，具体返回值取决于满足条件的代码体的最后一行内容。

```
println("input age")
var age = StdIn.readInt()
val res :String = if (age < 18){
    "童年"
}else if(age>=18 && age<30){
    "中年"
}else{
    "老年"
}
println(res)复制代码
```

- 需求3：Scala 中返回值类型不一致，取它们共同的祖先类型

```
println("input age")
var age = StdIn.readInt()
val res:Any = if (age < 18){
    "童年"
}else if(age>=18 && age<30){
    "中年"
}else{
    100
}
println(res)复制代码
```

- 需求 4：Java 中的三元运算符可以用 if else 实现

```
// 如果大括号{}内的逻辑代码只有一行，大括号可以省略。如果省略大括号，if 只对最近的一行逻辑代码起作用。
// Java
// int result = flag?1:0
// Scala
println("input age")
var age = StdIn.readInt()
val res:Any = if (age < 18) "童年" else "成年"
"不起作用"
println(res)复制代码
```

##### 1.3 扩展: 块表达式

- scala中，使用{}表示一个块表达式
- 和if表达式一样，块表达式也是有值的
- 值就是最后一个表达式的值

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab2_1/image-20210823161648091.png)**问题**

> 请问以下代码，变量a的值是什么？

```
val a = {
   println("1 + 1")
   1 + 1
}
println("a: " + a)复制代码
```

### 任务二、循环控制

#### **【任务目标】**

循环，指的是事物周而复始的变化。使一部分代码按照次数或一定的条件反复执行的一种代码结构。例如：打印10次"Hello, Scala!"，如果纯写输出语句，需要写10次，而通过循环来实现的话，输出语句只需要写1次，这样就变得很简单了。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab2_1/image-20210824110318276.png?fileid=3270835009203470817)

视频-2、循环控制

##### 2.1 For循环

在Scala中, for的格式和用法和Java中有些差异, Scala中的for表达式功能更加强大.

###### 2.1.1 格式

```
for(i <- 表达式/数组/集合) {
    //逻辑代码
}复制代码
```

> 注意: 执行流程和Java一致

###### 2.1.2 简单循环

**需求:** 打印10次"Hello, Scala!"

```
//定义一个变量, 记录1到10的数字
val nums = 1 to 10	//to是Scala中的一个关键字

//通过for循环, 打印指定的内容
for(i <- nums) {
     println("Hello, Scala! " + i)
}复制代码
```

**上述代码可以简写成:**

```
for(i <- 1 to 10) println("Hello, Scala! " + i)复制代码
```

###### 2.1.3 嵌套循环

**需求:** 使用for表达式，打印以下字符, 每次只能输出一个"*"

```
*****
*****
*****复制代码
```

**步骤**

1. 使用for表达式打印3行，5列星星
2. 每打印5个星星，换行

**参考代码**

```
//写法一: 普通写法
for(i <- 1 to 3) {		//外循环控制行数
    for(j <- 1 to 5) {	//内循环控制列数
        print("*")		//每次打印一个*
    }
    println()			//打印完一行(5个*)之后, 记得换行
}

//写法二: 压缩版
for(i <- 1 to 3) {		
    //这是两行代码
    for(j <- 1 to 5) if(j == 5) println("*") else print("*")
}

//写法三: 合并版
for(i <- 1 to 3; j <- 1 to 5) if(j == 5) println("*") else print("*")复制代码
```

###### 2.1.4 循环守卫

for表达式中，可以添加if判断语句，这个if判断就称之为守卫。我们可以使用守卫让for表达式更简洁。

**语法**

```
for(i <- 表达式/数组/集合 if 表达式) {
    //逻辑代码
}复制代码
```

**示例**

使用for表达式打印1-10之间能够整除3的数字

**参考代码**

```
// 添加守卫，打印能够整除3的数字
for(i <- 1 to 10 if i % 3 == 0) println(i)

//等价于
for (i <- 1 to 10){
    if (i%3 == 0) {
        println(i)
    }
}复制代码
```

###### 2.1.5 for推导式

Scala中的for循环也是有返回值的, 在for循环体中，可以使用yield表达式构建出一个集合(可以简单理解为: 就是一组数据)，我们把使用yield的for表达式称之为**推导式.**

**示例**

生成一个10、20、30...100的集合

**参考代码**

```
// for推导式：for表达式中以yield开始，该for表达式会构建出一个集合
val v = for(i <- 1 to 10) yield i * 10
println(v)复制代码
```

##### 2.2 while循环

scala中while循环和Java中是一致的

```
初始化条件
while(判断条件) {
    //循环体
    //控制条件
}复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab2_1/image-20210823165604377.png)**说明：**

> （1）循环条件是返回一个布尔值的表达式
>
> （2）while 循环是先判断再执行语句
>
> （3）与 for 语句不同，**while 语句没有返回值**，即整个 while 语句的**结果是 Unit 类型**
>
> （4）**因为 while 中没有返回值**，所以当要用该语句来计算并返回结果时，就不可避免的使用变量，而变量需要声明在 while 循环的外部，那么就等同于循环的内部对外部的变量造成了影响，所以不推荐使用，而是推荐使用 for 循环。

**需求:** 打印1-10的数字

**参考代码**

```
//初始化条件
var i = 1
//判断条件
while(i <= 10) {
    //循环体
    println(i)
    //控制条件
    i = i + 1
}复制代码
```

##### 2.3 do.while循环

do..while 循环是先执行，再判断

###### 2.3.1 格式

```
初始化条件
do{
    //循环体
    //控制条件
}while(判断条件) 复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab2_1/image-20210823165604377.png)**注意:**

> - do...while循环不管判断条件是否成立，循环体都会执行一次
> - for循环、while循环都是如果判断条件不成立，则循环体不执行

###### 2.3.2 示例

**需求:** 打印1-10的数字

```
//初始化条件
var i = 1
do{
    //循环体
    println(i)
    //控制条件
    i = i + 1
} while(i <= 10)	//判断条件复制代码
```

##### 2.4 循环中断

Scala 内置控制结构特地**去掉了** **break** **和** **continue**，是为了更好的适应**函数式编程**，推荐使用函数式的风格解决break和continue的功能，而不是一个关键字。Scala中使用breakable控制结构来实现 break 和 continue 功能。

###### 2.4.1 实现break

**用法**

1. 导包：`import scala.util.control.Breaks._`
2. 使用breakable将for表达式包起来
3. for表达式中需要退出循环的地方，添加`break()`方法调用

**示例**：使用for表达式打印1-10的数字，如果遇到数字5，则退出for表达式

> 方法1：采用 Scala 自带的函数，退出循环

```
// 导入scala.util.control包下的Break
import scala.util.control.Breaks

Breaks.breakable{
    for(i <- 1 to 10) {
        if(i == 5) Breaks.break() else println(i)
    }
}复制代码
```

> 方法2：对 break 进行省略

```
// 导入scala.util.control包下的Break
import scala.util.control.Breaks._

breakable{
    for(i <- 1 to 10) {
        if(i == 5) break() else println(i)
    }
}复制代码
```

###### 2.4.2 实现continue

**用法**

continue的实现与break类似，但有一点不同：

> 注意:
>
> 1. 实现break是用breakable{}将整个for表达式包起来.
> 2. 而实现continue是用breakable{}将for表达式的循环体包含起来就可以了.

**示例**

用for表达式打印1~10之间, 所有不能整除3的数字.

```
// 导入scala.util.control包下的Break    
import scala.util.control.Breaks._

for(i <- 1 to 100 ) {
    breakable{
        if(i % 3 == 0) break()
        else println(i)
    }
}复制代码
```

### 任务三、综合案例

#### **【任务目标】**

通过综合案例掌握循环的使用。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab2_1/image-20210824110318276.png?fileid=3270835009203043993)

视频-3、综合案例

##### 3.1 九九乘法表

**需求:**

打印九九乘法表, 如下图:

![1575948461338](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab2_1/1575948461338.png)

**步骤**

1. 通过外循环控制打印的行数
2. 通过内循环控制每行打印的列数

注意: 因为列数是随着行数递增的, 即:

> | 行数 | 该行的总列数 |
> | ---- | ------------ |
> | 1    | 1            |
> | 2    | 2            |
> | 3    | 3            |
> | n    | n            |
>
> 结论: 如果用**i**表示行数，那么该行的列数取值范围为: [1, i]

**参考代码**

- **方式一: 普通写法**

```
//外循环控制行
for(i <- 1 to 9) {		
    //内循环控制列
    for(j <- 1 to i) {
        print(s"${i} * ${j} = ${i * j}\t")
    }
    println()			//别忘了换行
}复制代码
```

- **方式二: 合并版写法**

```
//外循环控制行
for(i <- 1 to 9; j <- 1 to i) {		
    print(s"${i} * ${j} = ${i * j}\t")
    if(j == i) println()	//别忘了换行
}复制代码
```

##### 3.2 模拟登陆

**需求:**

老王要登陆博为峰后台系统学习Scala, 假设老王的账号和密码分别为"atstudy"、"123456"，且同一账号只有3次登陆机会，如果3次都录入错误，则提示账号被锁定。

**步骤**

1. 导包
   - scala.io.StdIn
   - scala.util.control.Breaks._
2. 定义变量，记录用户录入的账号和密码
3. 因为涉及到break的动作，所以要用breakable{}把整个for表达式包裹起来
4. 因为只有3次登陆机会，所以推荐使用for循环
5. 提示用户录入他/她的账号和密码，并接收
6. 判断用户录入的账号和密码是否正确
7. 如果录入正确，则提示"登陆成功，开始学习Scala!"，循环结束
8. 如果录入错误，则判断是否还有登陆机会
   - 有，则提示"用户名或者密码错误，您还有N次机会"，然后返回第5步继续执行
   - 没有，则提示"账号被锁定，请与管理员联系"，循环结束

**参考代码**

```
//1. 导包
import scala.io.StdIn
import scala.util.control.Breaks._

//2. 定义变量, 记录用户录入的账号和密码
var username = ""
var password = ""
//3. 因为涉及到break的动作, 所以要用breakable{}把整个for表达式包裹起来
breakable {
     //4. 因为只有3次登陆机会, 所以推荐使用for循环.
    for(i <- 1 to 3) {
        //5. 提示用户录入他/她的账号和密码, 并接收.
        println("请录入您的账号: ")
        username = StdIn.readLine()
        println("请录入您的密码: ")
        password = StdIn.readLine()
        //6. 判断用户录入的账号和密码是否正确.
        if(username == "atstudy" && password == "123456") {
            //7. 走到这里, 说明登陆成功, 循环结束.
            println("登陆成功, 开始学习Scala吧!")
            break()
        } else {
            //8. 走到这里, 说明登陆失败. 则判断是否还有登陆机会
            if(i == 3) println("账号被锁定, 请与管理员联系!") 
            else println(s"用户名或者密码错误, 您还有${3 - i}次机会")
        }
    }  
}复制代码
```





# 实验3-1：函数式编程基础

## 实验概述

函数式编程是Scala最大的亮点，大大简单了复杂的代码过程，这里先掌握方法和函数的一些基本用户

## 实验环境

- AtStudy 实训平台
- Scala2

## 实验流程

![image.png](https://cdn.atstudy.com/lab/manual/1676006374279660.png)

## 实验目标

学习完成本实验后，您将能够

- 掌握方法的格式和用法
- 掌握函数的格式和用法
- 掌握九九乘法表案例

## 实验任务

### 任务一、方法

#### **【任务目标】**

掌握方法的基本使用

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab3_1/image-20210824110318276.png?fileid=3270835009203865975)

视频-1、方法

##### 1.1 方法介绍

实际开发中，我们需要编写大量的逻辑代码，这就势必会涉及到重复的需求。例如: 求10和20的最大值，求11和22的最大值，像这样的需求，`用来进行比较的逻辑代码需要编写两次`，而如果把比较的逻辑代码放到方法中，只需要编写一次就可以了，这就是方法。

Scala中的方法和Java方法类似，但Scala与Java定义方法的语法是不一样的

##### 1.2 方法定义

```
def 方法名(参数名:参数类型, 参数名:参数类型) : [return type] = {
    //方法体
}复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab3_1/image-20210823165604377.png)**注意:**

> - 参数列表的参数类型不能省略
> - 返回值类型可以省略，由Scala编译器自动推断
> - 返回值可以不写return，默认就是{}块表达式的值

**需求: **

1. 定义一个方法getMax，用来获取两个整型数字的最大值，并返回结果(最大值)。
2. 调用该方法获取最大值，并将结果打印到控制台上。

- 方式一: 标准写法

```
//1. 定义方法, 用来获取两个整数的最大值.
def getMax(a:Int, b:Int): Int = {
    return if(a > b) a else b
}
//2. 调用方法, 获取最大值.
val max = getMax(10, 20)
//3. 打印结果.
println("max: " + max)复制代码
```

- 方式二: 优化版

```
//1. 定义方法, 用来获取两个整数的最大值.
def getMax(a:Int, b:Int) = if(a > b) a else b
//2. 调用方法, 获取最大值.
val max = getMax(22, 11)
//3. 打印结果.
println("max: " + max)复制代码
```

##### 1.3 惰性方法

当记录方法返回值的变量被声明为lazy时，方法的执行将被推迟，直到我们首次使用该值时，方法才会执行，像这样的方法，就叫：惰性方法。

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab3_1/warning.png)**注意:**

> lazy 不能修饰 var 类型的变量

**需求**：定义一个方法用来获取两个整数和，通过"惰性"技术调用该方法，然后打印结果。

```
//1. 定义方法, 用来获取两个整数和
def getSum(a:Int, b:Int) = {
    println("getSum方法被执行了...")
    a + b
}
//2. 通过"惰性"方式调用该方法.
lazy val sum = getSum(1, 2)	//此时我们发现getSum方法并没有执行, 说明它的执行被推迟了.

//3. 打印结果, 并观察
println("sum: " + sum) 		//打印结果为sum: 3, 说明首次使用方法返回值时, 方法才会加载执行.复制代码
```

##### 1.4 方法参数

Scala中的方法参数，使用比较灵活。它支持以下几种类型的参数：

- 默认参数
- 带名参数
- 变长参数

###### 1.4.1 默认参数

在定义方法时可以给参数定义一个默认值。

**示例**

1. 定义一个计算两个整数和的方法，这两个值分别默认为10和20
2. 调用该方法，不传任何参数

```
//1. 定义一个方法, 用来获取两个整数的和
// x，y的默认值分别为10和20
def getSum(x:Int = 10, y:Int = 20) = x + y
//2. 通过默认参数的形式, 调用方法
val sum = getSum()
//3. 打印结果
println("sum: " + sum)复制代码
```

###### 1.4.2 带名参数

在调用方法时，可以指定参数的名称来进行调用。

**示例**

1. 定义一个计算两个整数和的方法，这两个值分别默认为10和20
2. 调用该方法，只设置第一个参数的值

```
//1. 定义一个方法, 用来获取两个整数的和
def getSum(x:Int = 10, y:Int = 20) = x + y
//2. 通过默认参数的形式, 调用方法
val sum = getSum(x=1)
//3. 打印结果
println("sum: " + sum)复制代码
```

###### 1.4.3 变长参数

如果方法的参数是不固定的，可以将该方法的参数定义成变长参数。

**语法格式：**

```
def 方法名(参数名:参数类型*) : 返回值类型 = {
    //方法体
}复制代码
```

> 注意：
>
> 1. 在参数类型后面加一个`*`号，表示参数可以是0个或者多个
> 2. 一个方法有且只能有一个变长参数，并且变长参数要放到参数列表的最后边

**示例一: **

1. 定义一个计算若干个值相加的方法
2. 调用方法，传入以下数据：1,2,3,4,5

**参考代码**

```
//1. 定义一个计算若干个值相加的方法
def getSum(a:Int*) = a.sum
//2. 调用方法，传入一些整数, 并获取它们的和
val sum = getSum(1,2,3,4,5)
//3. 打印结果
println("sum: " + sum)复制代码
```

##### 1.5 方法调用方式

在scala中，有以下几种方法调用方式:

- 后缀调用法
- 中缀调用法
- 花括号调用法
- 无括号调用法

> 注意: 在编写spark、flink程序时，会经常使用到这些方法调用方式。

###### 1.5.1 后缀调用法

这种方法与Java没有区别, 非常简单.

**语法**

```
对象名.方法名(参数)复制代码
```

**示例**

使用后缀法调用`Math.abs`, 用来求绝对值

```
//后缀调用法
Math.abs(-1)	//结果为1复制代码
```

###### 1.5.2 中缀调用法

**语法**

```
对象名 方法名 参数复制代码
```

例如：`1 to 10`

> 注意: 如果有多个参数，使用括号括起来

**示例**

使用中缀法调用`Math.abs`, 用来求绝对值

```
//中缀调用法
Math abs -1		//结果为1复制代码
```

**扩展: 操作符即方法**

来看一个表达式, 大家觉得这个表达式像不像方法调用？

```
1 + 1复制代码
```

在scala中，+ - * / %等这些操作符和Java一样，但在scala中，

- 所有的操作符都是方法
- 操作符是一个方法名字是符号的方法

###### 1.5.3 花括号调用法

语法

```
Math.abs{ 
    // 表达式1
    // 表达式2
}复制代码
```

> 注意: 方法只有一个参数，才能使用花括号调用法

**示例**

使用花括号调用法`Math.abs`求绝对值

**参考代码**

```
//花括号调用法
Math.abs{-10}	//结果为: 10复制代码
```

###### 1.5.4 无括号调用法

如果方法没有参数，可以省略方法名后面的括号

**示例**

- 定义一个无参数的方法，打印"Hello, Scala!"
- 使用无括号调用法调用该方法

**参考代码**

```
//1. 定义一个无参数的方法，打印"Hello, Scala!"
def sayHello() = println("Hello, Scala!")
//2. 调用方法
sayHello复制代码
```

> 注意:
>
> 1. 在Scala中, 如果方法的返回值类型是Unit类型, 这样的方法称之为**过程(procedure)**
> 2. **过程**的等号(=)可以省略不写，例如:
>
> ```
> def sayHello() = println("Hello, Scala!")   
> //可以改写为
> def sayHello() { println("Hello, Scala!") }	 //注意: 这个花括号{}不能省略复制代码
> ```

##### 1.6 方法至简原则

至简原则：能省则省

（1）return 可以省略，Scala 会使用函数体的最后一行代码作为返回值

（2）如果函数体只有一行代码，可以省略花括号

（3）返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）

（4）如果有 return，则不能省略返回值类型，必须指定

（5）如果函数明确声明 unit，那么即使函数体中使用 return 关键字也不起作用

（6）Scala 如果期望是无返回值类型，可以省略等号

（7）如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加

（8）如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略

（9）如果不关心名称，只关心逻辑处理，那么函数名（def）可以省略

```
object TestFunction {
    def main(args: Array[String]): Unit = {
        // （0）函数标准写法
        def f( s : String ): String = {
            return s + " jinlian"
        }
        println(f("Hello"))
        // 至简原则:能省则省
        //（1） return 可以省略,Scala 会使用函数体的最后一行代码作为返回值
        def f1( s : String ): String = {
            s + " jinlian"
        }
        println(f1("Hello"))
        
        //（2）如果函数体只有一行代码，可以省略花括号
        def f2(s:String):String = s + " jinlian"
        
        //（3）返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）
        def f3( s : String ) = s + " jinlian"
        println(f3("Hello3"))
       
        //（4）如果有 return，则不能省略返回值类型，必须指定。
        def f4() :String = {
            return "ximenqing4"
        }
        println(f4())
        
        //（5）如果函数明确声明 unit，那么即使函数体中使用 return 关键字也不起作用
        def f5(): Unit = {
            return "dalang5"
        }
        println(f5())
        
        //（6）Scala 如果期望是无返回值类型,可以省略等号
        // 将无返回值的函数称之为过程
        def f6() {
            "dalang6"
        }
        println(f6())
       
        //（7）如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加
        def f7() = "dalang7"
        println(f7())
        println(f7)
        
        //（8）如果函数没有参数列表，那么小括号可以省略,调用时小括号必须省略
        def f8 = "dalang"
        //println(f8())
        println(f8)
        
        //（9）如果不关心名称，只关心逻辑处理，那么函数名（def）可以省略
        def f9 = (x:String)=>{println("wusong")}
        def f10(f:String=>Unit) = {
            f("")
        }
        f10(f9)
        println(f10((x:String)=>{println("wusong")}))
    }
}复制代码
```

### 任务二、函数

#### **【任务目标】**

掌握函数的基本使用

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab3_1/image-20210824110318276.png?fileid=3270835009203767070)

视频-2、函数

##### 2.1 函数介绍

Scala支持函数式编程，将来编写Spark/Flink程序会大量使用到函数，目前，我们先对函数做一个简单入门，在后续的学习过程中，我们会逐步重点讲解函数的用法。

**语法**

```
val 函数变量名 = (参数名:参数类型, 参数名:参数类型....) => 函数体复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab3_1/image-20210823165604377.png)**注意:**

> - 在Scala中, 函数是一个**对象**（变量）
> - 类似于方法，函数也有参数列表和返回值
> - 函数定义不需要使用`def`定义
> - 无需指定返回值类型

**需求: **

1. 定义一个计算两个整数和的函数
2. 调用该函数

```
//1. 定义一个用来计算两个整数和的函数, 并将其赋值给变量sum
val getSum = (x:Int, y:Int) => x + y
//2. 调用函数.
val result = getSum(1,2)
//3. 打印结果
println("result: " + result)复制代码
```

##### 2.2 方法和函数的区别

在Java中，方法和函数之间没有任何区别，只是叫法不同。但是在Scala中，函数和方法就有区别了， 具体如下:

- 方法是隶属于类或者对象的，在运行时，它是加载到JVM的方法区中
- 可以将函数对象赋值给一个变量，在运行时，它是加载到JVM的堆内存中
- 函数是一个对象，继承自FunctionN，函数对象有apply、curried、toString、tupled这些方法。方法则没有

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab3_1/warning.png)**结论**

> 在Scala中，函数是对象，而方法是属于对象的，所以可以理解为: **方法归属于函数**

**示例**：演示方法无法赋值给变量

```
//1. 定义方法
def add(x:Int,y:Int)= x + y

//2. 尝试将方法赋值给变量.
//val a = add(1, 2)		//不要这样写, 这样写是在"调用方法", 而不是把方法赋值给变量
val a = add

//3. 上述代码会报错
<console>:12: error: missing argument list for method add
Unapplied methods are only converted to functions when a function type is expected.
You can make this conversion explicit by writing `add _` or `add(_,_)` instead of `add`.
       val a = add
复制代码
```

##### 2.3 方法转换为函数

有时候需要将方法转换为函数，例如：作为变量传递，就需要将方法转换为函数

**格式**

```
val 变量名 = 方法名 _		//格式为: 方法名 + 空格 + 下划线复制代码
```

> 注意: 使用` _`即可将方法转换为函数

**示例**

1. 定义一个方法用来计算两个整数和
2. 将该方法转换为一个函数，并赋值给变量

**参考代码**

```
//1. 定义一个方法用来计算两个整数和
def add(x:Int, y:Int)= x + y
//2. 将该方法转换为一个函数，并赋值给变量
val a = add _
//3. 调用函数, 用来获取两个整数的和.
val result = a(1, 2)
//4. 打印结果
println("result: " + result)复制代码
```

### 任务三、综合案例

#### **【任务目标】**

打印nn乘法表，考察`键盘录入和方法, 函数`的综合运用，体会方法和函数的不同。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab3_1/image-20210824110318276.png?fileid=3270835009203766047)

视频-3、综合案例

##### 3.1 任务需求

定义方法实现， 根据用户录入的整数， 打印对应的乘法表。

例如： 用户录入5，则打印55乘法表，用户录入9，则打印99乘法表。

##### 3.2 实现步骤

1. 定义方法(或者函数)，接收一个整型参数。
2. 通过for循环嵌套实现，根据传入的整数，打印对应的乘法表。
3. 调用方法(函数)，输出结果。

##### 3.3 具体实现

- 方式一：通过方法实现

```
//1. 定义一个方法, 接收一个整型参数.
def printMT(n:Int) = {   //Multiplication Table(乘法表)
    //2. 通过for循环嵌套实现, 根据传入的整数, 打印对应的乘法表.
    for(i <- 1 to n; j <- 1 to i) {
        print(s"${j} * ${i} = ${j * i}\t"); 
        if(j==i) println()
    }
}
//3. 调用方法
printMT(5)

//优化版: 上述定义方法的代码可以合并为一行(目前只要能看懂即可)
/*def printMT(n:Int) = for(i <- 1 to n; j <- 1 to i) print(s"${j} * ${i} = ${j * i}" + (if(j==i) "\r\n" else "\t"))*/复制代码
```

- 方式二: 通过函数实现

```
//1. 定义一个函数, 接收一个整型参数.
val printMT = (n:Int) => {
    //2. 通过for循环嵌套实现, 根据传入的整数, 打印对应的乘法表.
    for(i <- 1 to n; j <- 1 to i) {
        print(s"${j} * ${i} = ${j * i}\t"); 
        if(j==i) println()
    }
}
//3. 调用函数
printMT(9)

//优化版: 上述定义函数的代码可以合并为一行(目前只要能看懂即可)
/*val printMT = (n:Int) => for(i <- 1 to n; j <- 1 to i) print(s"${j} * ${i} = ${j * i}" + (if(j==i) "\r\n" else "\t"))*/复制代码
```





# 实验3-2：函数式编程进阶

## 实验概述

Scala 混合了面向对象和函数式的特性，在函数式编程语言中，函数是“头等公民”，它和Int、String、Class等其他

类型处于同等的地位，可以像其他类型的变量一样被传递和操作。也就是说，如果一个函数的参数列表可以接收函数对象，那么这个函数就被称之为高阶函数(High-Order Function) 。

## 实验环境

- AtStudy 实训平台
- Scala2

## 实验流程

![image.png](https://cdn.atstudy.com/lab/manual/16760065345091802.png)

## 实验目标

学习完成本实验后，您将能够

- 掌握作为值的函数及匿名函数的用法
- 了解柯里化的用法
- 掌握闭包

## 实验任务

### 任务一、作为值的函数

#### **【任务目标】**

掌握如何将函数作为值进行传递

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab3_2/image-20210824110318276.png?fileid=3270835009204029948)

视频-1、作为值的函数

##### 1.1 介绍

在Scala中，函数就像和数字、字符串一样，可以将函数对象传递给一个方法。例如: 我们可以对算法进行封装，然后将具体的动作传递给方法，这种特性很有用。

##### 1.2 作为值的函数传递

```
//定义一个函数，函数参数还是一个函数签名；f 表示函数名称;(Int,Int)表示输入两个 Int 参数；Int 表示函数返回值
def f1(x:Int, y:Int, f:(Int, Int)=>Int):Int={
    f(x, y)*10
}

//将 getMax 函数作为参数传递给 f1 函数
var getMax =  (a:Int, b:Int)=>if(a>b) a else b
var res = f1(10, 20, getMax)
println(res)复制代码
```

**需求**：将一个整数数组中的每个元素转换为对应个数的小星星，如下:

```
Array(1, 2, 3...) => *, **, ***复制代码
```

**步骤**

1. 创建一个函数，用于将数字装换为指定个数的小星星
2. 创建一个列表，调用map方法
3. 打印转换后的列表

```
//案例: 演示函数可以作为 对象传递
object ClassDemo01 {
    def main(args: Array[String]): Unit = {
        //需求: 定义一个数组, 记录数字, 将该数字转换成对应个数的 *
        //1: * , 2: **, 3: ***...
        //1. 定义一个数组, 记录1~4的数字.
        val arr = Array(1, 2, 3, 4)
        
        //2. 定义一个函数对象(函数是Scala中的头等公民), 用来将Int -> String
        val func = (a:Int) => "*" * a
        
        //3. 调用函数map, 用来转换数字
        //list1.map(这里需要一个函数)
        val arr2 = arr.map(func)
        
        //4. 打印结果
        println(arr2.mkString(","))
    }
}复制代码
```

### 任务二、匿名函数

#### **【任务目标】**

在实际应用中，匿名函数也是我们经常需要使用的。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab3_2/image-20210824110318276.png?fileid=3270835009202973361)

视频-2、匿名函数

##### 2.1 概述

上述的案例，把` (num:Int) => "*" * num` 这个函数赋值给了一个变量，虽然实现了指定的需求，但是这种写法有一些啰嗦，我们可以通过 **匿名函数** 来优化它。

在Scala中，没有赋值给变量的函数就是**匿名函数**。

##### 2.2 案例

通过匿名函数实现，将一个整数列表中的每个元素转换为对应个数的小星星。

```
//案例: 演示 匿名函数.
object ClassDemo02 {
    def main(args: Array[String]): Unit = {
        //需求: 定义一个数组, 记录数字, 将该数字转换成对应个数的*
        //1: * , 2: **, 3: ***...
        //1. 定义一个数组, 记录1~4的数字.
        val arr = Array(1, 2, 3, 4)
        
        //2. 通过map函数用来进行转换, 该函数内部接收一个: 匿名函数
        val arr2 = arr.map((a:Int) => "*" * a)
        
        //3. 打印结果.
        println(arr2.mkString(","))
    }
}复制代码
```

##### 2.3 传递匿名函数的至简原则

（1）参数的类型可以省略，会根据形参进行自动的推导

（2）类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况：没有参数和参数超过 1 的永远不能省略圆括号。

（3）匿名函数如果只有一行，则大括号也可以省略

（4）如果参数只出现一次，则参数省略且后面参数可以用`_`代替

```
def main(args: Array[String]): Unit = {
    // （1）定义一个方法：参数包含数据和逻辑函数
    def operation(arr: Array[Int], op: Int => Int) = {
        for (elem <- arr) yield op(elem)
    }
    // （2）定义逻辑方法
    def op(ele: Int): Int = {
        ele + 1
    }
    // （3）标准函数调用
    val arr = operation(Array(1, 2, 3, 4), op)
    println(arr.mkString(","))
    // （4）采用匿名函数
    val arr1 = operation(Array(1, 2, 3, 4), (ele: Int) => {
        ele + 1
    })
    println(arr1.mkString(","))
    // （4.1）参数的类型可以省略，会根据形参进行自动的推导;
    val arr2 = operation(Array(1, 2, 3, 4), (ele) => {
        ele + 1
    })
    println(arr2.mkString(","))
    // （4.2）类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况：没有参数和参数超过 1 的永远不能省略圆括号。
    val arr3 = operation(Array(1, 2, 3, 4), ele => {
        ele + 1
    })
    println(arr3.mkString(","))
    // (4.3) 匿名函数如果只有一行，则大括号也可以省略
    val arr4 = operation(Array(1, 2, 3, 4), ele => ele + 1)
    println(arr4.mkString(","))
    
    //（4.4）如果参数只出现一次，则参数省略且后面参数可以用_代替
    val arr5 = operation(Array(1, 2, 3, 4), _ + 1)
    println(arr5.mkString(","))
}复制代码
```

所以上面的案例最简洁写法为：

```
//案例: 演示 匿名函数.
object ClassDemo03 {
    def main(args: Array[String]): Unit = {
        //需求: 定义一个数组, 记录1~4的数组, 将该数字转换成对应个数的 *
        //1. 定义一个数组, 记录1~4的数字
        val arr = Array(1, 2, 3, 4)
        
        //通过下划线实现
        val arr2 = arr.map("*" * _)
        //val arr2 = arr.map(_ * "*") //不能这样写, 会报错
        println(arr2.mkString(","))
    }
}复制代码
```

### 任务三、柯里化和闭包

#### **【任务目标】**

了解柯里化的使用及函数闭包现象

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab3_2/image-20210824110318276.png?fileid=3270835009202715880)

视频-3、柯里化和闭包

##### 3.1 柯里化

在scala和spark的源代码中，大量使用到了柯里化。为了方便我们后续阅读源代码，我们需要来了解下柯里化。

柯里化(Currying)是指：将原先接受多个参数的方法转换为多个只有一个参数的参数列表的过程 。

###### 3.1.1 案例

首先我们定义一个方法:

```
def add(x:Int, y:Int) = x+y复制代码
```

那么我们应用的时候，应该是这样用：`add(1, 2)`

现在我们把这个函数变一下形：

```
def add(x:Int)(y:Int) = x + y复制代码
```

那么我们应用的时候，应该是这样用：`add(1)(2)`，最后结果都一样是3，这种方式（过程）就叫**柯里化**。

###### 3.1.2 实现过程

add(1)(2) 实际上是依次调用两个普通函数（非柯里化函数），第一次调用使用一个参数 x，返回一个函数类型的值，第二次使用参数y调用这个函数类型的值。

实质上最先演变成这样一个方法：

```
def add(x:Int)=(y:Int)=>x+y复制代码
```

那么这个函数是什么意思呢？ 接收一个x为参数，返回一个匿名函数，该匿名函数的定义是：接收一个Int型参数y，函数体为x+y。现在我们来对这个方法进行调用。

```
val result = add(1) 复制代码
```

返回一个result，那result的值应该是一个匿名函数：`(y:Int)=>1+y`

所以为了得到结果，我们继续调用result。

```
val sum = result(2)复制代码
```

最后打印出来的结果就是3。

###### 3.1.3 完整案例

下面是一个完整实例

```
object ClassDemo04 {
   def main(args: Array[String]) {
      val str1:String = "Hello, "
      val str2:String = "Scala!"
      println( "str1 + str2 = " +  strcat(str1)(str2) )
   }

   def strcat(s1: String)(s2: String) = {
      s1 + s2
   }
}复制代码
```

##### 3.2 闭包

闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。

闭包通常来讲可以简单的认为是**可以访问一个函数里面局部变量的另外一个函数**。

如下面这段匿名的函数：

```
val demo = (i:Int) => i * 10  复制代码
```

函数体内有一个变量 i，它作为函数的一个参数。如下面的另一段代码：

```
val demo = (i:Int) => i * factor复制代码
```

在 demo 中有两个变量：i 和 factor。其中的一个 i 是函数的形式参数，在 demo 函数被调用时，i 被赋予一个新的值。然而，factor不是形式参数，而是自由变量，考虑下面代码：

```
var factor = 3  
val demo = (i:Int) => i * factor 复制代码
```

这里我们引入一个自由变量 factor，这个变量定义在函数外面。

这样定义的函数变量 demo 成为一个"闭包"，因为它引用到函数外面定义的变量，定义这个函数的过程是将这个自由变量捕获而构成一个封闭的函数。

```
object ClassDemo05 {  
   def main(args: Array[String]) {  
      println( "demo(1) value = " +  demo(1) )  
      println( "demo(2) value = " +  demo(2) )  
   }  
   var factor = 3  
   val demo = (i:Int) => i * factor  
}复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab3_2/image-20210823165604377.png)**总结**

> **「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。**

##### 3.3 闭包和柯里化关系

函数柯里化，其实就是将复杂的参数逻辑变得简单化，函数柯里化一定存在闭包。

```
object ClassDemo06 {
    def main(args: Array[String]): Unit = {
        def f1()={
            var a:Int = 10
            def f2(b:Int)={
                a + b
            }
            f2 _
        }
        // 在调用时，f1 函数执行完毕后，局部变量 a 应该随着栈空间释放掉
        val f = f1()
        // 但是在此处，变量 a 其实并没有释放，而是包含在了 f2 函数的内部，形成了闭合的效果
        println(f(3))

        println(f1()(3))
        // 函数柯里化，其实就是将复杂的参数逻辑变得简单化,函数柯里化一定存	在闭包
        def f3(a:Int)(b:Int)={
            a + b
        }
        println(f3(2)(3))
    }
}复制代码
```





# 实验4-1：面向对象基础

## 实验概述

面向对象编程，是解决问题的一种方式，将问题分解为对象、行为、属性，然后通过对象的关系以及行为的调用来解决问题。Scala 语言也是一个完全面向对象编程语言，万物皆对象，而对象的本质就是对数据和行为的一个封装。

## 实验环境

- AtStudy 实训平台
- Scala2

## 实验流程

![image.png](https://cdn.atstudy.com/lab/manual/16760065879733709.png)

## 实验目标

学习完成本实验后，您将能够

- 掌握类和对象的定义
- 掌握访问修饰符和构造器的用法
- 掌握伴生对象的使用
- 掌握包的使用
- 掌握样例类的使用

## 实验任务

### 任务一、类和对象

#### **【任务目标】**

面向对象的基础就是类和对象，这里先需要大家掌握什么是类以及对象和类之间的关系。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/image-20210824110318276.png?fileid=3270835009206383140)

视频-1、类和对象

##### 1.1 面向对象介绍

什么是面向对象？

```
面向对象是一种编程思想, 它是基于面向过程的, 强调的是以对象为基础完成各种操作复制代码
```

面向对象的三大思想特点是什么？

1. 更符合人们的思考习惯.
2. 把复杂的事情简单化.
3. 把程序员从执行者变成指挥者.

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/image-20210823170539971.png)**面试题：**

> 什么是面向对象? 思路：概述，特点，举例，总结

**什么是类?**

```
类是属性和行为的集合, 是一个抽象的概念, 看不见, 也摸不着.复制代码
```

- 属性(也叫成员变量)：名词，用来描述事物的外在特征的
- 行为(也叫成员方法)：动词，表示事物能够做什么
  - 例如: 学生有姓名和年龄(这些是属性)，学生要学习，要吃饭(这些是行为)

**什么是对象?**

```
对象是类的具体体现, 实现复制代码
```

**面向对象的特征?**

```
封装、继承、多态复制代码
```

##### 1.2 创建类和对象

Scala中创建类和对象可以通过class和new关键字来实现。**用class来创建类，用new来创建对象**

###### 1.2.1 示例

创建一个Person类，并创建它的对象，然后将对象打印到控制台上

###### 1.2.2 步骤

- 创建一个scala项目，并创建一个object类

> 注意: object修饰的类是单例对象, 这点先了解即可, 稍后会详细解释

- 在object类中添加main方法
- 创建Person类，并在main方法中创建Person类的对象，然后输出结果

###### 1.2.3 实现

- 在IDEA中创建项目，并创建一个object类（main方法必须放在Object中）

  - 第一步: 创建Scala项目

    

     

    

     

    

  - 第二步: 创建object类

    ![image-20230202102751422](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/image-20230202102751422.png)

    ![image-20230202102857704](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/image-20230202102857704.png)

- 在object类中添加main方法, 并按照需求完成指定代码

```
//案例: 测试如何在Scala程序中创建类和对象
object ClassDemo01 {

  //1. 创建Person类
  class Person {}

  //2. 定义main函数, 它是程序的主入口.
  def main(args: Array[String]): Unit = {
    //3. 创建Person类型的对象.
    val p = new Person()
    //4. 将对象打印到控制台上
    println(p)
  }
}
复制代码
```

###### 1.2.4 简写方式

**用法**

- 如果类是空的，没有任何成员，可以省略`{}`
- 如果构造器的参数为空，可以省略`()`

**示例**

使用简写方式重新创建Person类和对象, 并打印对象.

**参考代码**

```
//案例: 通过简写方式在Scala中创建类和对象
object ClassDemo02 {

  //1. 创建Person类
  class Person 

  //2. 定义main函数, 它是程序的主入口.
  def main(args: Array[String]): Unit = {
    //3. 创建Person类型的对象.
    val p = new Person
    //4. 将对象打印到控制台上
    println(p)
  }
}复制代码
```

##### 1.3 定义和访问成员变量

一个类会有自己的属性，例如：人类，就有自己的姓名和年龄。我们接下来学习如何在类中定义和访问成员变量。

###### 1.3.1 用法

- 在类中使用`var/val`来定义成员变量
- 对象可以通过`对象名.`的方式来访问成员变量

###### 1.3.2 示例

**需求**

1. 定义一个Person类，包含一个姓名和年龄字段
2. 创建一个名为"张三"、年龄为23岁的对象
3. 打印对象的名字和年龄

**步骤**

1. 创建一个object类，添加main方法
2. 创建Person类，添加姓名字段和年龄字段，并对字段进行初始化，让scala自动进行类型推断
3. 在main方法中创建Person类对象，设置成员变量为"张三"、23
4. 打印对象的名字和年龄

**参考代码**

```
//案例: 定义和访问成员变量.
object ClassDemo03 {

  //1. 创建Person类
  class Person {
    //2. 定义成员变量
    //val name:String = ""
    //通过类型推断来实现
    //var修饰的变量, 值是可以修改的.  val修饰的变量, 值不能修改.
    var name = ""   //姓名
    var age = 0     //年龄
  }

  //定义main函数, 它是程序的主入口.
  def main(args: Array[String]): Unit = {
    //3. 创建Person类型的对象.
    val p = new Person
    //4. 给成员变量赋值
    p.name = "张三"
    p.age = 23
    //5. 打印成员变量值到控制台上
    println(p.name, p.age)
  }
}复制代码
```

##### 1.4 使用下划线初始化成员变量

scala中有一个更简洁的初始化成员变量的方式，可以让代码看起来更加简洁，更优雅

###### 1.4.1 用法

- 在定义

  ```
  var
  ```

  类型的成员变量时，可以使用

  ```
  _
  ```

  来初始化成员变量

  - String => null
  - Int => 0
  - Boolean => false
  - Double => 0.0
  - ...

- `val`类型的成员变量，必须要自己手动初始化

###### 1.4.2 示例

**需求**

1. 定义一个Person类，包含一个姓名和年龄字段
2. 创建一个名为"张三"、年龄为23岁的对象
3. 打印对象的名字和年龄

**步骤**

1. 创建一个object类，添加main方法
2. 创建Person类，添加姓名字段和年龄字段，指定数据类型，使用下划线初始化
3. 在main方法中创建Person类对象，设置成员变量为"张三"、23
4. 打印对象的名字和年龄

**参考代码**

```
//案例: 使用下划线来初始化成员变量值.
//注意: 该方式只针对于var类型的变量有效. 如果是val类型的变量, 需要手动赋值.
object ClassDemo04 {

  //1. 创建Person类
  class Person {
    //2. 定义成员变量
    var name:String = _   //姓名
    var age:Int = _       //年龄
    //val age:Int = _     //这样写会报错, 因为"下划线赋值"的方式只针对于var修饰的变量有效.
  }

  //定义main函数, 它是程序的主入口.
  def main(args: Array[String]): Unit = {
    //3. 创建Person类型的对象.
    val p = new Person
    //4. 给成员变量赋值
    p.name = "张三"
    p.age = 23
    //5. 打印成员变量值到控制台上
    println(p.name, p.age)
  }
}复制代码
```

##### 1.5 定义和访问成员方法

类可以有自己的行为，scala中也可以通过定义成员方法来定义类的行为。

###### 1.5.1 格式

在scala的类中，也是使用`def`来定义成员方法的.

```
def 方法名(参数1:数据类型, 参数2:数据类型): [return type] = {
    //方法体
}复制代码
```

> 注意: 返回值的类型可以不写, 由Scala自动进行类型推断.

###### 1.5.2 示例

**需求**

1. 创建一个Customer类

   ![1557322180244](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/1557322180244.png)

2. 创建一个该类的对象，并调用printHello方法

**步骤**

1. 创建一个object类，添加main方法
2. 创建Customer类，添加成员变量、成员方法
3. 在main方法中创建Customer类对象，设置成员变量值(张三、男)
4. 调用成员方法

**参考代码**

```
//案例: 定义和访问成员方法
object ClassDemo05 {

  //1. 创建Customer类
  class Customer {
    //2. 定义成员变量
    var name:String = _   //姓名
    var sex = ""          //性别

    //3. 定义成员方法printHello
    def printHello(msg:String) = {
      println(msg)
    }
  }

  //定义main函数, 它是程序的主入口.
  def main(args: Array[String]): Unit = {
    //4. 创建Customer类型的对象.
    val c = new Customer
    //5. 给成员变量赋值
    c.name = "张三"
    c.sex = "男"
    //6. 打印成员变量值到控制台上
    println(c.name, c.sex)
    //7. 调用成员方法
    printHello("你好!")
  }
}复制代码
```

### 任务二、访问权限

#### **【任务目标】**

面向对象编程过程中需要对属性中的数据进行一定的保护，这就涉及到访问权限问题，所以本任务的主要目的是搞清楚封装和访问权限相关问题。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/image-20210824110318276.png?fileid=3270835009206864909)

视频-2、访问权限

##### 2.1 封装介绍

面向对象的第一个特性就是：封装，就是把抽象出的数据和对数据的操作封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作（成员方法），才能对数据进行操作。

Java 封装操作如下，

（1）将属性进行私有化

（2）提供一个公共的 set 方法，用于对属性赋值

（3）提供一个公共的 get 方法，用于获取属性的值

Scala 中的 public 属性，底层实际为 private，并通过 get 方法（obj.field()）和 set 方法（obj.field_=(value)）对其进行操作。所以 Scala 并不推荐将属性设为 private，再为其设置public 的 get 和 set 方法的做法。但由于很多 Java 框架都利用反射调用 getXXX 和 setXXX 方法，有时候为了和这些框架兼容，也会为 Scala 的属性设置 getXXX 和 setXXX 方法（通过@BeanProperty 注解实现）。

```
import scala.beans.BeanProperty
class Person {
    var name: String = "bobo" //定义属性
    var age: Int = _ // _表示给属性一个默认值
    //Bean 属性（@BeanProperty）
    @BeanProperty var sex: String = "男"
    //val 修饰的属性不能赋默认值，必须显示指定
}
object ClassDemo06 {
    def main(args: Array[String]): Unit = {
        var person = new Person()
        println(person.name)
        person.setSex("女")
        println(person.getSex)
    }
}复制代码
```

> **注意**：Bean 属性（@BeanPropetry），可以自动生成规范的 setXxx/getXxx 方法

##### 2.2 访问权限

在 Java 中，访问权限分为：public，private，protected 和默认。在 Scala 中，你可以通过类似的修饰符达到同样的效果。但是使用上有区别。

（1）Scala 中属性和方法的默认访问权限为 public，但 Scala 中**无 public 关键字**。

（2）private 为私有权限，只在类的内部和伴生对象中可用。

（3）protected 为受保护权限，Scala 中受保护权限比 Java 中更严格，同类、子类可以访问，同包无法访问。

（4）private[包名]增加包访问权限，包名下的其他类也可以使用。

> 注意：如果某个成员的权限设置为private[this]，表示只能在当前类中访问。

```
package com.itluma.chapter02

class Person {
    private var name: String = "bobo"
    protected var age: Int = 18
    private[chapter02] var sex: String = "男"
    def say(): Unit = {
        println(name)
    }
}
object Person {
    def main(args: Array[String]): Unit = {
        val person = new Person
        person.say()
        println(person.name)
        println(person.age)
    }
}
class Teacher extends Person {
    def test(): Unit = {
        this.age
        this.sex
    }
}
class Animal {
    def test: Unit = {
        new Person().sex
    }
}复制代码
```

### 任务三、构造对象

#### **【任务目标】**

当创建对象的时候，会自动调用类的构造器。之前使用的都是默认构造器，接下来我们要学习如何自定义构造器来完成对象的构造。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/image-20210824110318276.png?fileid=3270835009206287171)

视频-3、构造对象

##### 3.1 构造器

和 Java 一样，Scala 构造对象也需要调用构造方法，并且可以有任意多个构造方法。

Scala 类的构造器包括：

- **主构造器**
- **辅助构造器**

###### 3.1.1 主构造器

**语法**

```
class 类名(var/val 参数名:类型 = 默认值, var/val 参数名:类型 = 默认值){
    //构造代码块
}复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/image-20210823165604377.png)**注意:**

> - 主构造器的参数列表直接定义在类名后面，添加了val/var表示直接通过主构造器定义成员变量
> - 构造器参数列表可以指定默认值
> - 创建实例，调用构造器可以指定字段进行初始化
> - 整个class中除了字段定义和方法定义的代码都是构造代码

**示例**

1. 定义一个Person类，通过主构造器参数列表定义姓名和年龄字段，并且设置它们的默认值为张三, 23
2. 在主构造器中输出"调用主构造器"
3. 创建"李四"对象（姓名为李四，年龄为24），打印对象的姓名和年龄
4. 创建"空"对象，不给构造器传入任何的参数，打印对象的姓名和年龄
5. 创建"测试"对象，不传入姓名参数，仅指定年龄为30，打印对象的姓名和年龄

**参考代码**

```
//案例: 演示Scala中的类的主构造器.
/*
  注意:
    1. Scala中主构造器的参数列表是直接写在类名后的.
    2. 主构造器的参数列表可以有默认值.
    3. 调用主构造器创建对象时, 可以指定参数赋值.
    4. 整个类中除了定义成员变量和成员方法的代码, 其他都叫: 构造代码.
 */
object ClassDemo07 {

  //1. 创建person类, 主构造器参数列表为: 姓名和年龄.
  class Person(val name: String = "张三", val age: Int = 23) { //这里应该用var修饰.
    //2. 在主构造器中输出"调用主构造器"
    println("调用主构造器!...")
  }

  //定义main函数, 它是程序的主入口.
  def main(args: Array[String]): Unit = {
    //3. 创建"空"对象, 什么都不传.
    val p1 = new Person()
    println(s"p1: ${p1.name}...${p1.age}")

    //4. 创建"李四"对象, 传入姓名和年龄
    val p2 = new Person("李四", 24)
    println(s"p2: ${p2.name}...${p2.age}")

    //5. 创建测试对象, 仅传入年龄.
    val p3 = new Person(age = 30)
    println(s"p3: ${p3.name}...${p3.age}")
  }
}复制代码
```

###### 3.1.2 辅助构造器

在scala中，除了定义主构造器外，还可以根据需要来定义辅助构造器。例如：允许通过多种方式，来创建对象，这时候就可以定义其他更多的构造器。我们把除了主构造器之外的构造器称为**辅助构造器**。

**语法**

- 定义辅助构造器与定义方法一样，也使用`def`关键字来定义
- 辅助构造器的默认名字都是`this`, 且不能修改

```
def this(参数名:类型, 参数名:类型) {
    // 第一行需要调用主构造器或者其他构造器
    // 构造器代码
}复制代码
```

> 注意: 辅助构造器的第一行代码，必须要**调用主构造器或者其他辅助构造器**

**需求**

- 定义一个Customer类，包含一个姓名和地址字段
- 定义Customer类的主构造器（初始化姓名和地址）
- 定义Customer类的辅助构造器，该辅助构造器接收一个数组参数，使用数组参数来初始化成员变量
- 使用Customer类的辅助构造器来创建一个"张三"对象
  - 姓名为张三
  - 地址为上海
- 打印对象的姓名、地址

**参考代码**

```
//案例: 演示Scala中的类的辅助构造器.
object ClassDemo08 {

  //1. 创建Customer类, 主构造器参数列表为: 姓名和地址.
  class Customer(var name: String, var address: String) { //这里应该用var修饰.
    //2. 定义一个辅助构造器, 接收一个数组参数
    def this(arr:Array[String]) {
      this(arr(0), arr(1))    //将数组的前两个元素分别传给主构造器的两个参数.
    }
  }

  //定义main函数, 它是程序的主入口.
  def main(args: Array[String]): Unit = {
    //3. 调用辅助构造器, 创建Customer对象.
    val c = new Customer(Array("张三", "上海"))
    //4. 打印结果.
    println(c.name, c.address)
  }
}复制代码
```

##### 3.2 单例对象

Scala中是没有static关键字的，要想定义类似于Java中的static变量、static方法，就要使用到scala中的单例对象了, 也就是object。

###### 3.2.1 定义单例对象

单例对象表示全局仅有一个对象，也叫`孤立对象`。定义单例对象和定义类很像，就是把class换成object。

**格式**

```
object 单例对象名{ }			//定义一个单例对象.复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/image-20210823165604377.png)**注意:**

> - 在object中定义的成员变量类似于Java中的静态变量, 在内存中都只有一个对象
> - 在单例对象中, 可以直接使用`单例对象名.`的形式调用成员

**需求**

- 定义一个Dog单例对象，保存狗有几条腿
- 在main方法中打印狗腿的数量

**参考代码**

```
//案例: 演示Scala中的单例对象之定义和访问成员变量.
object ClassDemo09 {

  //1. 定义单例对象Dog
  object Dog {
    //2. 定义一个变量, 用来存储狗腿子的数量
    val leg_num = 4
  }

  //定义main方法, 它是程序的主入口.
  def main(args: Array[String]): Unit = {
    //3. 打印狗腿子的数量
    println(Dog.leg_num)
  }
}复制代码
```

###### 3.2.2 在单例对象中定义方法

在单例对象中定义的成员方法类似于Java中的静态方法

**需求**

- 设计一个单例对象，定义一个能够打印分割线（15个减号）的方法
- 在main方法调用该方法，打印分割线

**参考代码**

```
//案例: 演示Scala中的单例对象之定义和访问成员方法.
object ClassDemo10 {

  //1. 定义单例对象PrintUtil
  object PrintUtil {
    //2. 定义一个方法, 用来打印分割线
    def printSpliter() = println("-" * 15)
  }

  //定义main方法, 它是程序的主入口.
  def main(args: Array[String]): Unit = {
    //3. 调用单例对象中的成员方法
    PrintUtil.printSpliter()
  }
}复制代码
```

###### 3.2.3 main方法

Scala和Java一样，如果要运行一个程序，必须有一个main方法。在Java中main方法是静态的，而在Scala中没有静态方法。所以在Scala中，这个main方法必须放在一个单例对象中。

**main方法**

```
def main(args:Array[String]):Unit = {
    // 方法体
}复制代码
```

**例如**:创建一个单例对象，在该单例对象中打印"hello, scala"

```
object Main5 {
  def main(args:Array[String]) = {
    println("hello, scala")
  }
}复制代码
```

##### 3.3 伴生对象

在Java中，经常会有一些类，同时有实例成员又有静态成员。例如：

```
public class Generals {

    private static String armsName = "青龙偃月刀";

    public void toWar() {
        //打仗
        System.out.println("武将拿着"+ armsName +", 上阵杀敌!");
    }

    public static void main(String[] args) {
        new Generals().toWar();
    }
}复制代码
```

在Scala中，要实现类似的效果，可以使用**伴生对象**来实现。

###### 3.3.1 定义伴生对象

一个class和object具有同样的名字。这个object称为**伴生对象**，这个class称为**伴生类**

- 伴生对象必须要和伴生类一样的名字
- 伴生对象和伴生类在同一个scala源文件中
- 伴生对象和伴生类可以互相访问private属性

**需求**

- 编写一个Generals类，有一个toWar方法，打印

  ```
  武将拿着**武器, 上阵杀敌!		//注意: **表示武器的名字.复制代码
  ```

- 编写一个Generals伴生对象，定义一个私有变量，用于保存武器名称.

- 创建Generals对象，调用toWar方法

**参考代码**

```
//案例: 演示Scala中的伴生对象
object ClassDemo11 {

  //1. 定义一个类Generals, 作为一个伴生类.
  class Generals {    //这里写的都是非静态成员.
    //2. 定义一个toWar()方法, 输出一句话, 格式为"武将拿着**武器, 上阵杀敌!"
    def toWar() = println(s"武将拿着${Generals.armsName}武器, 上阵杀敌!")
  }

  //3. 定义一个伴生对象, 用来保存"武将的武器".
  object Generals {   //这里写的都是静态成员.
    private var armsName = "青龙偃月刀"
  }

  //定义main方法, 作为程序的主入口
  def main(args: Array[String]): Unit = {
    //4. 创建Generals类的对象.
    val g = new Generals
    //5. 调用Generals类中的toWar方法
    g.toWar()
  }
}复制代码
```

##### 3.4 apply方法

在Scala中, 支持创建对象的时候, `免new`的动作, 这种写法非常简便，优雅。要想实现`免new`, 我们就要通过伴生对象的apply方法来实现。

###### 3.4.1 格式

**定义apply方法的格式**

```
object 伴生对象名 {
    def apply(参数名:参数类型, 参数名:参数类型...) = new 类(...)
}复制代码
```

**创建对象**

```
val 对象名 = 伴生对象名(参数1, 参数2...)复制代码
```

> 例如: val p = Person("张三", 23)

###### 3.4.2 示例

**需求**

- 定义一个Person类，它包含两个字段：姓名和年龄
- 在伴生对象中定义apply方法，实现创建Person对象的免new操作.
- 在main方法中创建该类的对象，并打印姓名和年龄

**参考代码**

```
//案例: 演示Scala中的apply方法
object ClassDemo12 {

  //1. 定义Person类, 属性为姓名和年龄
  class Person(var name: String = "", var age: Int = 0)

  //2. 定义Person类的伴生对象.
  object Person {
    //3. 定义apply方法, 实现创建Person对象的时候免new.
    def apply(name:String, age:Int) = new Person(name, age)
  }

  //定义main方法, 作为程序的主入口
  def main(args: Array[String]): Unit = {
    //4. 创建Person类型的对象.
    val p = Person("张三", 23)
    //5. 打印Person对象的属性值.
    println(p.name, p.age)
  }
}复制代码
```

### 任务四、包

#### **【任务目标】**

在实际开发中，肯定会遇到同名的类，例如: 两个Person类。那在不改变类名的情况下，如何区分它们呢?

这就要使用到`包(package)`了。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/image-20210824110318276.png?fileid=3270835009205065895)

视频-4、包

##### 4.1 包的秘密

包就是文件夹，用关键字`package`修饰，它可以区分重名类，且功能相似的代码可以放到同一个包中，便于我们维护和管理代码。

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/image-20210823165604377.png)**注意:**

> 1. 编写Scala源代码时，包名和源码所在的目录结构可以不一致
>
> 2. 编译后，字节码文件和包名路径会保持一致(由编译器自动完成).
>
> 3. 包名由数字、大小写英文字母、 _(下划线)、$(美元符)组成，多级包之间用**.**隔开, 一般是公司域名反写
>
>    `例如: com.atstudy.demo01, com.atstudy.demo02`

##### 4.2 使用方式

- **格式一: 文件顶部标记法, 合并版**

  ```
  package 包名1.包名2.包名3		//根据实际需求, 可以写多级包名
  //这里可以写类、特质...		   复制代码
  ```

- **格式二: 文件顶部标记法, 分解版**

  ```
  package 包名1.包名2
  package 包名3				  //这种写法和
  //这里可以写类, 特质...复制代码
  ```

- **格式三: 串联式包语句**

  ```
  package 包名1.包名2 {
      //包名1的内容在这里不可见
      
      package 包名3 {
          //这里可以写类, 特质...
      }
  }复制代码
  ```

  > 注意: 上述这种写法， 建议包名嵌套不要超过3级

  ```
  //案例: 演示包的3种写法
  //格式一: 文件顶部标记法, 合并版.
  /*
  package com.atstudy.scala
  class Person
  */
  
  //格式二: 文件顶部标记法, 分解版.
  /*
  package com.atstudy
  package scala
  class Person
  */
  
  //格式三: 串联式包语句
  package com {         //嵌套不建议超过3层.
    package atstudy {
      package scala {
        class Person{}
      }
    }
  }
  
  //测试类
  object ClassDemo13 {
    //main方法是程序的主入口, 所有的代码都是从这里开始执行的.
    def main(args: Array[String]): Unit = {
      val p = new com.atstudy.scala.Person()
      println(p)
    }
  }复制代码
  ```

##### 4.3 包的作用范围

Scala中的包和其它作用域一样，也是支持嵌套的，具体的访问规则(作用域)如下:

1. 下层可以直接访问上层中的内容

   `即: 在Scala中, 子包可以直接访问父包中的内容`

2. 上层访问下层内容时，可以通过`导包(import)或者写全包名`的形式实现

3. 如果上下层有相同的类，使用时将采用就近原则来访问.

   `即: 上下层的类重名时，优先使用下层的类，如果明确需要访问上层的类，可通过上层路径+类名的形式实现 `

**需求**

1. 创建`com.atstudy`包, 并在其中定义Person类, Teacher类, 及子包scala.
2. 在`com.atstudy.scala`包中定义Person类, Student类.
3. 在测试类中测试.

**参考代码**

```
//案例: 演示包的作用域
package com.atstudy{  //父包
  class Person{}      //这是com.atstudy包中的Person类
  class Teacher{}     //这是com.atstudy包中的Teacher类

  object ClassDemo14 { //父包中的测试类
    def main(args: Array[String]): Unit = {
      //方式一: 导包, 导包语句可以出现在Scala代码中的任意位置, 不一定是行首.
     /*import com.atstudy.scala.Student  
      val s = new Student()   //父包访问子包的类, 需要导包.
      println(s)*/

      //方式二: 全包名
      val s = new com.atstudy.scala.Student()
      //因为当前包就是com.atstudy, 所以上述代码可以简写成如下格式
      //val s = new scala.Student()
      println(s)
    }
  }

  package scala{    //子包
    class Person{}  //这是com.atstudy.scala包中的Person类
    class Student{} //这是com.atstudy.scala包中的Student类

    object ClassDemo15 {  //子包中的测试类.
      def main(args: Array[String]): Unit = {
        val t = new Teacher()      //子包可以直接访问父包中的内容.
        println(t)

        val p = new Person()       //子父包有同名类时, 采用就近原则来访问.
        println(p)

        val p2 = new com.atstudy.Person() //子父包有同名类, 且想访问父包类时, 写全路径即可.
        println(p2)
      }
    }
  }
}复制代码
```

##### 4.4 包的引入

###### 4.4.1 概述

在Scala中，导入包也是通过关键字`import`来实现的，但是Scala中的import功能更加强大，更加灵活，它不再局限于编写到scala文件的顶部，而是可以编写到scala文件中任何你需要用的地方。且Scala默认引入了java.lang包、scala包及Predef包。

###### 4.4.2 注意事项

1. Scala中并不是完全引入了Scala包和Predef包中的所有内容，它们中的部分内容在使用时依旧需要先导包

   `例如: import scala.io.StdIn`

2. import语句可以写到scala文件中任何需要用到的地方，好处是: 缩小import包的作用范围，从而提高效率

3. 在Scala中，如果要导入某个包中所有的类和特质，要通过`_(下划线)`来实现

   `例如:import scala._ 的意思是, 导入scala包下所有的内容`

4. 如果仅仅是需要某个包中的某几个类或者特质，则可以通过`选取器(就是一对大括号)`来实现

   `例如:import scala.collection.mutable.{HashSet, TreeSet}表示只引入HashSet和TreeSet两个类`

5. 如果引入的多个包中含有相同的类, 则可以通过`重命名或者隐藏`的方式解决.

   - `重命名`的格式

     ```
     import 包名1.包名2.{原始类名=>新类名, 原始类名=>新类名}
     
     //例如: import java.util.{HashSet=>JavaHashSet}复制代码
     ```

   - `隐藏`的格式

     ```
     import 包名1.包名2.{原始类名=>_, _}
     
     //例如:import java.util.{HashSet=>_, _} 表示引入java.util包下除了HashSet类之外所有的类复制代码
     ```

###### 4.4.3 示例

**需求**

1. 创建测试类, 并在main方法中测试上述的5点注意事项
2. 需求1: 导入java.util.HashSet类
3. 需求2: 导入java.util包下所有的内容
4. 需求3: 只导入java.util包下的ArrayList类和HashSet类
5. 需求4: 通过重命名的方式, 解决多个包中类名重复的问题
6. 需求5: 导入时, 隐藏某些不需要用到的类, 即: 导入java.util包下除了HasSet和TreeSet之外所有的类

```
//案例: 演示包的引入
object ClassDemo16 {
  //测试方法1
  def test01() = {
    //1.导入java.util.HashSet
    import java.util.HashSet    //好处: 缩小import包的作用范围, 从而提高效率.
    val hs = new HashSet()
    println(hs.getClass)

    //2.导入java.util包下所有的内容.
    import java.util._
    val hm = new HashMap()
    println(hm.getClass)
    val list = new ArrayList()
    println(list.getClass)
  }

  //测试方法2
  def test02() = {
    //val hs = new HashSet()      //这样写会报错, 因为没有导包.

    //3.只导入java.util包下的ArrayList类和HashSet类
    /*import java.util.{ArrayList, HashSet}
    val list = new ArrayList()
    val hs = new HashSet()
    val hm = new HashMap()        //这样写会报错, 因为没有导包.*/

    //4.通过重命名的方式, 解决多个包中类名重复的问题
    /*import java.util.{HashSet => JavaHashSet}
    import scala.collection.mutable.HashSet
    val hs = new HashSet()
    val jhs = new JavaHashSet()
    println(hs.getClass)
    println(jhs.getClass)*/

    //5. 导入时, 隐藏某些不需要用到的类.
    //导入java.util包下除了HasSet和TreeSet之外所有的类
    import java.util.{HashSet=>_, TreeSet=>_, _}
    //val hs = new HashSet()      //这样写会报错
    val hm = new HashMap()
    println(hm.getClass)
  }

  //main方法, 程序的入口.
  def main(args: Array[String]): Unit = {
    //调用test01()和test02()这两个测试方法.
    test01()
    println("-" * 15)
    test02()
  }
}复制代码
```

### 任务五、样例类

#### **【任务目标】**

在Scala中，样例类是一种特殊类，一般是用于**保存数据**的(类似于Java POJO类)，在并发编程以及Spark、Flink这些框架中都会经常使用它，本任务的重点就是掌握样例类的使用。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/image-20210824110318276.png?fileid=3270835009205065911)

视频-5、样例类

##### 5.1 格式

```
case class 样例类名([var/val] 成员变量名1:类型1, 成员变量名2:类型2, 成员变量名3:类型3){}复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_1/image-20210823165604377.png)**重点**

> - 如果不写，则变量的默认修饰符是val，即: val是可以省略不写的
> - 如果要实现某个成员变量值可以被修改，则需手动添加var来修饰此变量

##### 5.2 示例

**需求**

- 定义样例类Person，包含姓名和年龄这两个成员变量

  `其中: 姓名用val修饰, 年龄用var修饰`

- 在测试类中创建Person类的对象，并打印它的属性值

- 尝试修改姓名，年龄这两个成员变量的值，并观察结果

```
//案例: 样例类入门
object ClassDemo17 {
  //1. 创建一个Person样例类, 属性为: 姓名, 年龄.
  case class Person(name:String = "张三",var age:Int = 23) {}

  def main(args: Array[String]): Unit = {
    //2. 创建Person类型的对象, 然后打印属性值.
    val p = new Person()
    println(p)
    //3. 尝试修改对象p的属性值
    //p.name = "李四"     //这样写会报错, 因为样例类的成员变量默认修饰符是: val
    p.age = 24
    println(p)
  }
}复制代码
```

##### 5.3 样例类中的默认方法

###### 5.3.1 简介

当我们定义一个样例类后，编译器会自动帮助我们生成一些方法，常用的如下:

- apply()方法
- toString()方法
- equals()方法
- hashCode()方法
- copy()方法

###### 5.3.2 功能详解

- **apply()方法**

  - 可以让我们快速地使用类名来创建对象, 省去了new这个关键字
  - 例如: `val p = Person()`

- **toString()方法**

  - 可以让我们通过输出语句打印对象时, 直接打印该对象的各个属性值.
  - 例如: `println(p) 打印的是对象p的各个属性值, 而不是它的地址值`

- **equals()方法**

  - 可以让我们直接使用`==`来比较两个样例类对象的所有成员变量值是否相等.
  - 例如: `p1 == p2 比较的是两个对象的各个属性值是否相等, 而不是比较地址值`

- **hashCode()方法**

  - 用来获取对象的哈希值的. 即: 同一对象哈希值肯定相同, 不同对象哈希值一般不同.

  - 例如:

    ```
    val p1 = new Person("张三", 23)
    val p2 = new Person("张三", 23)
    println(p1.hashCode() == p2.hashCode())		//结果为: true复制代码
    ```

- **copy()方法**

  - 可以用来快速创建一个属性值相同的实例对象，还可以使用带名参数的形式给指定的成员变量赋值.

  - 例如:

    ```
    val p1 = new Person("张三", 23)
    val p2 = p1.copy(age = 24)
    println(p1)		//结果为: 张三, 23
    println(p2)		//结果为: 张三, 24复制代码
    ```

###### 5.3.3 示例

**需求**

1. 创建Person样例类, 指定姓名, 年龄.
2. 在测试类中创建Person类的对象, 并测试上述的5个方法.

```
//案例: 演示样例类的默认方法.t6g
object ClassDemo18 {
  //1. 定义一个样例类Person.
  case class Person(var name:String, var age:Int) {}

  def main(args: Array[String]): Unit = {
    //2. 测试样例类中的一些默认方法.
    val p1 = Person("张三", 23)       //免new, 说明支持apply方法
    println(p1)                      //直接打印对象输出属性值, 说明支持toString方法

    val p2 = Person("张三", 23)
    println(p1 == p2)                //比较的是属性值, 说明重写了equals方法
    println("-" * 15)

    //记忆: 同一对象哈希值肯定相同, 不同对象哈希值一般不同.
    println(p1.hashCode())           //可以获取哈希值, 说明重写了hashCode方法
    println(p2.hashCode())

    //演示copy方法, 就是用来复制对象的.
    //需求:  想创建一个张三, 50这样的对象.
    val p3 = p2.copy(age = 50)
    println(p3)						//结果为: 张三, 50
  }
}
```





# 实验4-2：面向对象核心

## 实验概述

基于前面的面向对象基础，接下来需要掌握一些面向对象的核心内容，就是对象的扩展，主要就是通过继承和特质来实现。

## 实验环境

- AtStudy 实训平台
- Scala2

## 实验流程

![image.png](https://cdn.atstudy.com/lab/manual/16760066309466704.png)

## 实验目标

学习完成本实验后，您将能够

- 掌握继承和抽象类相关知识点
- 掌握特质的用法
- 掌握程序员案例

## 实验任务

### 任务一、继承

#### **【任务目标】**

实际开发中，我们发现好多类中的内容是相似的(例如：相似的属性和行为)，每次写很麻烦。于是我们可以把这些相似的内容提取出来单独的放到一个类中(父类)，然后让那多个类(子类)和这个类(父类)产生一个关系，从而实现子类可以访问父类的内容，这个关系就叫: 继承，从而减少重复代码。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://www.atstudy.com/learn/%E5%AE%9E%E9%AA%8C4-2%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A0%B8%E5%BF%83.assets/image-20210824110318276.png?fileid=3270835009205759942)

视频-1、继承

##### 1.1 继承语法

- scala中使用**extends**关键字来实现继承
- 可以在子类中定义父类中没有的字段和方法，或者重写父类的方法
- 类和单例对象都可以有父类

**语法**

```
class/object A类 extends B类 {	
    ...
}复制代码
```

**叫法**

- 上述格式中，A类称之为：子类，派生类
- B类称之为：父类、超类、基类

##### 1.2 类继承

**需求**

已知学生类(Student)和老师类(Teacher)，他们都有姓名和年龄(属性)，都要吃饭(行为)。

- 方式一: 非继承版

```
object ClassDemo01 {
  //1. 定义老师类.
  class Teacher{
    var name = ""
    var age = 0

    def eat() = println("老师喝牛肉汤!...")
  }
  //2. 定义学生类.
  class Student{
    var name = ""
    var age = 0

    def eat() = println("学生吃牛肉!...")
  }

  //main方法, 程序的主入口
  def main(args: Array[String]): Unit = {
    //3. 测试老师类.
    //3.1 创建对象.
    val t = new Teacher
    //3.2 给属性赋值
    t.name = "刘老师"
    t.age = 32
    //3.3 打印属性值.
    println(t.name, t.age)
    //3.4 调用方法
    t.eat()
    println("-" * 15)

    //4. 测试学生类.
    val s = new Student
    s.name = "张三"
    s.age = 21
    println(s.name, s.age)
    s.eat()
  }
}复制代码
```

- 方式二: 继承版

```
object ClassDemo02 {
  //1. 定义人类.
  class Person {
    var name = ""
    var age = 0

    def eat() = println("人要吃饭!...")
  }
  //2. 定义老师类.
  class Teacher extends Person
  //3. 定义学生类.
  class Student extends Person

  def main(args: Array[String]): Unit = {
    //4. 测试老师类.
    val t = new Teacher
    t.name = "刘老师"
    t.age = 32
    println(t.name, t.age)
    t.eat()
    println("-" * 15)
    //5. 测试学生类.
    val s = new Student
    s.name = "张三"
    s.age = 23
    println(s.name, s.age)
    s.eat()
  }
}复制代码
```

##### 1.3 单例对象继承

在Scala中，单例对象也是可以继承类的.

**需求**

定义Person类(成员变量: 姓名, 成员方法: sayHello())，定义单例对象Student继承自Person, 然后测试

```
object ClassDemo03 {
  //1. 定义Person类.
  class Person {
    var name = ""

    def sayHello() = println("Hello, Scala!..")
  }
  //2. 定义单例对象Student, 继承Person.
  object Student extends Person

  //main方法, 程序的主入口
  def main(args: Array[String]): Unit = {
    //3. 测试Student中的成员.
    Student.name = "张三"
    println(Student.name)
    Student.sayHello()
  }
}复制代码
```

##### 1.4 方法重写

###### 1.4.1 概述

子类中出现和父类一模一样的方法时，称为方法重写。Scala代码中可以在子类中使用override来重写父类的成员，也可以使用super来引用父类的成员

###### 1.4.2 注意事项

- 子类要重写父类中的某一个方法，该方法必须要使用override关键字来修饰

- 可以使用override来重写一个val字段

  > 注意: 父类用var修饰的变量，子类不能重写

- 使用super关键字来访问父类的成员方法

###### 1.4.3 示例

- 定义Person类, 属性(姓名, 年龄), 有一个sayHello()方法
- 然后定义Student类继承Person类，重写Person类中的字段和方法，并测试

**参考代码**

```
object ClassDemo04 {
  //1. 定义父类Person.
  class Person {
    var name = "张三"
    val age = 23

    def sayHello() = println("Hello, Person!...")
  }
  //2. 定义子类Student, 继承Person.
  class Student extends Person{
    //override var name = "李四"    //这样写会报错, 子类不能重写父类用var修饰的变量.
    override val age = 24

    override def sayHello() = {
      //通过super调用父类的成员.
      super.sayHello()
      println("Hello, Student!...")
    }
  }
  //程序的入口.
  def main(args: Array[String]): Unit = {
    //3. 创建学生类型的对象, 然后测试.
    val s = new Student
    println(s.name, s.age)
    s.sayHello()
  }
}复制代码
```

### 任务二、抽象

#### **【任务目标】**

Scala语言是支持抽象类的，主要通过abstract关键字来实现。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_2/image-20210824110318276.png?fileid=3270835009205073421)

视频-2、抽象

##### 2.1 抽象类定义

如果类中有抽象字段或者抽象方法，那么该类就应该是一个**抽象类**

> - 抽象字段: 没有初始化值的变量就是抽象字段.
> - 抽象方法: 没有方法体的方法就是一个抽象方法.

##### 2.2 格式

```
// 定义抽象类
abstract class 抽象类名 {
  // 定义抽象字段
  val/var 抽象字段名:类型
  // 定义抽象方法
  def 方法名(参数:参数类型, 参数:参数类型...):返回类型
}复制代码
```

##### 2.3 抽象方法案例

**需求**

![1552449400240](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_2/1552449400240.png)

- 设计4个类，表示上述图中的继承关系
- 每一个形状都有自己求面积的方法，但是不同的形状计算面积的方法不同

**步骤**

1. 创建一个Shape抽象类，添加一个area抽象方法，用于计算面积
2. 创建一个Square正方形类，继承自Shape，它有一个边长的主构造器，并实现计算面积方法
3. 创建一个长方形类，继承自Shape，它有一个长、宽的主构造器，实现计算面积方法
4. 创建一个圆形类，继承自Shape，它有一个半径的主构造器，并实现计算面积方法
5. 编写main方法，分别创建正方形、长方形、圆形对象，并打印它们的面积

**参考代码**

```
// 创建形状抽象类
abstract class Shape {
  def area:Double
}

// 创建正方形类
class Square(var edge:Double /*边长*/) extends Shape {
  // 实现父类计算面积的方法
  override def area: Double = edge * edge
}

// 创建长方形类
class Rectangle(var length:Double /*长*/, var width:Double /*宽*/) extends Shape {
  override def area: Double = length * width
}

// 创建圆形类
class Circle(var radius:Double /*半径*/) extends Shape {
  override def area: Double = Math.PI * radius * radius
}

object ClassDemo07 {
  def main(args: Array[String]): Unit = {
    val s1:Shape = new Square(2)
    val s2:Shape = new Rectangle(2,3)
    val s3:Shape = new Circle(2)

    println(s1.area)
    println(s2.area)
    println(s3.area)
  }
}复制代码
```

##### 2.4 抽象字段

在Scala的抽象类中，不仅可以定义抽象方法，也可以定义抽象字段。如果一个成员变量是没有初始化，我们就认为它是抽象的。

**语法**

```
abstract class 抽象类 {
    val/var 抽象字段:类型
}复制代码
```

**示例说明**

1. 创建一个Person抽象类，它有一个String抽象字段occupation
2. 创建一个Student类，继承自Person类，重写occupation字段，初始化为学生
3. 创建一个Teacher类，继承自Person类，重写occupation字段，初始化为老师
4. 添加main方法，分别创建Student/Teacher的实例，然后分别打印occupation

**参考代码**

```
object ClassDemo08 {
  //1. 定义抽象类Person, 有一个抽象字段occupation(职业)
  abstract class Person {
    val occupation:String
  }
    
  //2. 定义Student类继承Person, 重写抽象字段occupation.
  class Student extends Person{
    override val occupation: String = "学生"
  }
    
  //3. 定义Teacher类继承Person, 重写抽象字段occupation.
  class Teacher extends Person{
    override val occupation: String = "老师"
  }
    
  //main方法, 作为程序的主入口
  def main(args: Array[String]): Unit = {
    //4. 创建Student类的对象, 打印occupation的值.
    val s = new Student
    println(s.occupation)
      
    //5. 创建Teacher类的对象, 打印occupation的值.
    val t = new Teacher
    println(t.occupation)
  }
}复制代码
```

### 任务三、特质

#### **【任务目标】**

掌握trait的使用特点

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_2/image-20210824110318276.png?fileid=3270835009205365256)

视频-3、特质

##### 3.1 特质概述

有些时候，我们会遇到一些特定的需求，即: 在不影响当前继承体系的情况下，对某些类(或者某些对象)的功能进行加强，例如：有猴子类和大象类，它们都有姓名、年龄、以及吃的功能，但是部分的猴子经过马戏团的训练后， 学会了骑独轮车，那骑独轮车这个功能就不能定义到父类(动物类)或者猴子类中，而是应该定义到`特质`中。而Scala中的特质，要用关键字`trait`修饰。

##### 3.2 特点

- 特质可以提高代码的复用性
- 特质可以提高代码的扩展性和可维护性
- 类与特质之间是继承关系, 只不过类与类之间只支持`单继承`, 但是类与特质之间, `既可以单继承, 也可以多继承`
- Scala的特质中可以有普通字段、抽象字段、普通方法、抽象方法

![img](https://www.atstudy.com/learn/%E5%AE%9E%E9%AA%8C4-2%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A0%B8%E5%BF%83.assets/image-20210823165604377.png)**注意:**

> 1. 如果特质中只有抽象内容，这样的特质叫: 瘦接口
> 2. 如果特质中既有抽象内容，又有具体内容，这样的特质叫: 富接口

##### 3.3 语法

**定义特质**

```
trait 特质名称 {
    // 普通字段
    // 抽象字段
    
    // 普通方法
    // 抽象方法
}复制代码
```

**继承特质**

```
class 类 extends 特质1 with 特质2 {
    // 重写抽象字段
    // 重写抽象方法
}复制代码
```

**注意**

- scala中不管是类还是特质，继承关系用的都是`extends`关键字
- 如果要继承多个特质(trait)，则特质名之间使用`with`关键字隔开

##### 3.4 示例

###### 3.4.1 类继承单个特质

**需求**

1. 创建一个Logger特质，添加`log(msg:String)`方法
2. 创建一个ConsoleLogger类，继承Logger特质，实现log方法，打印消息
3. 添加main方法，创建ConsoleLogger对象，调用log方法.

**参考代码**

```
//案例: Trait入门之类继承单个特质
object ClassDemo01 {
  //1. 定义一个特质.
  trait Logger {
    def log(msg:String)   //抽象方法
  }

  //2. 定义一个类, 继承特质.
  class ConsoleLogger extends Logger {
    override def log(msg: String): Unit = println(msg)
  }

  def main(args: Array[String]): Unit = {
    //3. 调用类中的方法
    val cl = new ConsoleLogger
    cl.log("trait入门: 类继承单个特质")
  }
}复制代码
```

###### 3.4.2 类继承多个trait

**需求**

1. 创建一个MessageSender特质，添加`send(msg:String)`方法
2. 创建一个MessageReceiver特质，添加`receive()`方法
3. 创建一个MessageWorker类, 继承这两个特质, 重写上述的两个方法
4. 在main中测试，分别调用send方法、receive方法

**参考代码**

```
//案例: 类继承多个trait
object ClassDemo02 {
  //1. 定义一个特质: MessageSender, 表示发送信息.
  trait MessageSender {
    def send(msg:String)
  }
  //2. 定义一个特质: MessageReceiver, 表示接收信息.
  trait MessageReceiver {
    def receive()
  }
  //3. 定义一个类MessageWorker, 继承两个特质.
  class MessageWorker extends MessageSender with MessageReceiver {
    override def send(msg: String): Unit = println("发送消息: " + msg)

    override def receive(): Unit = println("消息已收到, 我很好, 谢谢!...")
  }

  //main方法, 作为程序的主入口
  def main(args: Array[String]): Unit = {
    //4. 调用类中的方法
    val mw = new MessageWorker
    mw.send("Hello, 你好啊!")
    mw.receive()
  }
}复制代码
```

###### 3.4.3 object继承trait

**需求**

1. 创建一个Logger特质，添加`log(msg:String)`方法
2. 创建一个Warning特质, 添加`warn(msg:String)`方法
3. 创建一个单例对象ConsoleLogger，继承Logger和Warning特质, 重写特质中的抽象方法
4. 编写main方法，调用单例对象ConsoleLogger的log和warn方法

**参考代码**

```
//案例: 演示object单例对象继承特质
object ClassDemo03 {
  //1. 定义一个特质Logger, 添加log(msg:String)方法.
  trait Logger{
    def log(msg:String)
  }

  //2. 定义一个特质Warning, 添加warn(msg:String)方法.
  trait Warning{
    def warn(msg:String)
  }

  //3. 定义单例对象ConsoleLogger, 继承上述两个特质, 并重写两个方法.
  object ConsoleLogger extends Logger with Warning{
    override def log(msg: String): Unit = println("控制台日志信息: "  + msg)

    override def warn(msg: String): Unit = println("控制台警告信息: " + msg)
  }

  //main方法, 作为程序的入口
  def main(args: Array[String]): Unit = {
    //4. 调用ConsoleLogger单例对象中的两个方法.
    ConsoleLogger.log("我是一条普通日志信息!")
    ConsoleLogger.warn("我是一条警告日志信息!")
  }
}复制代码
```

###### 3.4.4 演示trait中的成员

**需求**

1. 定义一个特质Hero, 添加具体字段name(姓名), 抽象字段arms(武器), 具体方法eat(), 抽象方法toWar()
2. 定义一个类Generals, 继承Hero特质, 重写其中所有的抽象成员.
3. 在main方法中, 创建Generals类的对象, 调用其中的成员.

**参考代码**

```
//案例: 演示特质中的成员
object ClassDemo04 {
  //1. 定义一个特质Hero
  trait Hero{
    var name = ""     //具体字段
    var arms:String   //抽象字段

    //具体方法
    def eat() = println("吃肉喝酒, 养精蓄锐!")

    //抽象方法
    def toWar():Unit
  }

  //2. 定义一个类Generals, 继承Hero特质, 重写其中所有的抽象成员.
  class Generals extends Hero {
    //重写父特质中的抽象字段
    override var arms: String = ""

    //重写父特质中的抽象方法
    override def toWar(): Unit = println(s"${name}带着${arms}, 上阵杀敌!")
  }

  //main方法, 作为程序的入口
  def main(args: Array[String]): Unit = {
    //3. 创建Generals类的对象.
    val gy = new Generals

    //4. 测试Generals类中的内容.
    //给成员变量赋值
    gy.name = "关羽"
    gy.arms = "青龙偃月刀"
    //打印成员变量值
    println(gy.name, gy.arms)
    //调用成员方法
    gy.eat()
    gy.toWar()
  }
}复制代码
```

### 任务四、综合案例：程序员

#### **【任务目标】**

考察`继承、特质、抽象类`的相关内容，简单理解：整个继承体系的共性内容定义到父类中，整个继承体系的扩展内容定义到父特质中。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_2/image-20210824110318276.png?fileid=3270835009205821157)

视频-4、综合案例：程序员

##### 4.1 需求

现实生活中有很多程序员，例如: Python程序员、Java程序员等，他们都有姓名和年龄、都要吃饭、都有自己所掌握的技能(skill)。不同的是，部分的Java程序员和Python程序员通过培训学习握了大数据技术，实现更好的就业。 请用所学模拟该场景。

##### 4.2 结构分析

![1578388916738](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab4_2/1578388916738.png)

##### 4.3 实现过程

```
//案例: 程序员案例
object ClassDemo11 {
  //1. 定义程序员类Programmer.
  abstract class Programmer {
    //属性: 姓名和年龄
    var name = ""
    var age = 0

    //行为: 吃饭和技能
    def eat()
    def skill()
  }
    
  //2. 定义特质BigData.
  trait BigData {
    def learningBigData() = {
      println("来到培训之后: ")
      println("我学会了: Hadoop, Zookeeper, HBase, Hive, Sqoop, Scala, Spark, Flink等技术")
      println("我学会了: 企业级360°全方位用户画像、千亿级数据仓、电信信号强度诊断等项目")
    }
  }
    
  //3. 定义Java程序员类JavaProgrammer.
  class JavaProgrammer extends Programmer {
    override def eat(): Unit = println("Java程序员吃大白菜, 喝大米粥.")

    override def skill(): Unit = println("我精通Java技术.")
  }

  //4. 定义Python程序员类PythonProgrammer.
  class PythonProgrammer extends Programmer {
    override def eat(): Unit = println("Python程序员吃小白菜, 喝小米粥.")

    override def skill(): Unit = println("我精通Python技术.")
  }

  //5. 定义PartJavaProgrammer类, 表示精通: Java和大数据的程序员.
  class PartJavaProgrammer extends JavaProgrammer with BigData {
    override def eat(): Unit = println("精通Java和大数据的程序员, 吃牛肉, 喝牛奶")

    override def skill(): Unit = {
      super.skill()     //本身就掌握的内容.
      learningBigData() //来培训之后学习的技能.
    }
  }

  //6. 定义PartPythonProgrammer类, 表示精通: Python和大数据的程序员.
  class PartPythonProgrammer extends PythonProgrammer with BigData {
    override def eat(): Unit = println("精通Python和大数据的程序员, 吃羊肉, 喝羊奶")

    override def skill(): Unit = {
      super.skill()     //本身就掌握的内容.
      learningBigData() //来到培训之后学习的技能.
    }
  }

  def main(args: Array[String]): Unit = {
    //7. 测试.
    //7.1 测试普通Java程序员.
    val jp = new JavaProgrammer
    jp.name = "张三"
    jp.age = 23
    println(s"我叫${jp.name}, 年龄为${jp.age}, 我是普通的Java程序员")
    jp.eat()
    jp.skill()
    println("-" * 15)   //分割线

    //7.2 测试精通Java + 大数据的程序员
    val pjp = new PartJavaProgrammer
    pjp.name = "李四"
    pjp.age = 24
    println(s"我叫${pjp.name}, 年龄为${pjp.age}, 我精通Java技术和大数据技术")
    pjp.eat()
    pjp.skill()

    //7.3 测试普通的Python程序员, 自行测试.
    //7.4 测试精通Python + 大数据的程序员, 自行测试.
  }
}复制代码
```





# 实验5-1：内功修炼之集合篇

## 实验概述

在进行程序开发时，各种数据结构的使用是衡量一个程序员水平的关键之一，而数据结构包括数组、集合等，所以本实验的主要任务就是掌握各种集合的使用，这也是我们修炼编程内功的技术手段。

## 实验环境

- AtStudy 实训平台
- Scala2

## 实验流程

![image.png](https://cdn.atstudy.com/lab/manual/1676006673857102.png)

## 实验目标

学习完成本实验后，您将能够

- 掌握数组, 元组相关知识点
- 掌握列表, 集, 映射相关知识点
- 了解迭代器的用法
- 掌握集合的高阶函数用法

## 实验任务

### 任务一、数组

#### **【任务目标】**

掌握数组的使用

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20210824110318276.png?fileid=3270835009206520314)

视频-1、数组

##### 1.1 数组分类

**数组**就是用来存储多个同类型元素的容器，每个元素都有编号(也叫: 下标、脚标、索引)，且编号都是从0开始数的

Scala中, 有两种数组，一种是**定长数组**，另一种是**变长数组**

###### 1.1.1 定长数组

**特点**

- 数组的长度不允许改变
- 数组的内容是可变的

**语法**

> 格式一：通过指定长度定义数组 格式二：通过指定元素定义数组

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20210823165604377.png)**注意:**

> 1. 在scala中，数组的泛型使用 [] 来指定
> 2. 使用 数组名(索引) 来获取数组中的元素
> 3. 数组元素是有默认值的，Int:0、Double:0.0、String: null
> 4. 通过 **数组名.length** 或者 **数组名.size** 来获取数组的长度

**需求**

1. 定义一个长度为10的整型数组，设置第1个元素为11，并打印第1个元素
2. 定义一个包含"java", "scala", "python"这三个元素的数组，并打印数组长度

**参考代码**

```
//案例: 演示定长数组
object ClassDemo01 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个长度为10的整型数组, 设置第1个元素为11, 并打印第1个元素.
        val arr1 = new Array[Int](10)
        arr1(0) = 11
        println(arr1(0)) //打印数组的第1个元素.
        println("-" * 15) //分割线
        
        //2. 定义一个包含"java", "scala", "python"这三个元素的数组, 并打印数组长度.
        val arr2 = Array("java", "scala", "python")
        println(arr2.length) //打印数组的长度
    }
}复制代码
```

###### 1.1.2 变长数组

**特点**

- 数组的长度和内容都是可变的，可以往数组中添加、删除元素

**语法**

> 创建变长数组，需要先导入ArrayBuffer类

```
import scala.collection.mutable.ArrayBuffer复制代码
```

> 定义格式一：创建空的ArrayBuffer变长数组

```
val/var 变量名 = ArrayBuffer[元素类型]()复制代码
```

> 定义格式二：创建带有初始元素的ArrayBuffer变长数组

```
val/var 变量名 = ArrayBuffer(元素1，元素2，元素3....)复制代码
```

- **示例一**: **定义变长数组**

1. 定义一个长度为0的整型变长数组
2. 定义一个包含"hadoop"、"storm"、"spark"这三个元素的变长数组
3. 打印结果

**参考代码**

```
//1. 导包
import scala.collection.mutable.ArrayBuffer

//案例: 演示变长数组
object ClassDemo02 {
    def main(args: Array[String]): Unit = {
        //2. 定义一个长度为0的整型变长数组.
        val arr1 = new ArrayBuffer[Int]()
        println("arr1:" + arr1)

        //3. 定义一个包含"hadoop", "storm", "spark"这三个元素的变长数组.
        val arr2 = ArrayBuffer("hadoop", "storm", "spark")
        println("arr2:" + arr2)
    }
}复制代码
```

- **示例二: 增删改元素**

针对Scala中的变长数组，可通过下述方式来修改数组中的内容

**格式**

- 使用 `+=` 添加单个元素
- 使用 `-=` 删除单个元素
- 使用 `++=` 追加一个数组到变长数组中
- 使用 `--=` 移除变长数组中的指定多个元素

**示例**

1. 定义一个变长数组，包含以下元素： "hadoop"、"spark"、"flink"
2. 往该变长数组中添加一个"flume"元素
3. 从该变长数组中删除"hadoop"元素
4. 将一个包含"hive"、"sqoop"元素的数组，追加到变长数组中
5. 从该变长数组中删除"sqoop"、"spark"这两个元素
6. 打印数组，查看结果

```
//导包
import scala.collection.mutable.ArrayBuffer

//案例: 修改变长数组中的内容.
object ClassDemo03 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个变长数组，包含以下元素: "hadoop", "spark", "flink"
        val arr = ArrayBuffer("hadoop", "spark", "flink")
        //2. 往该变长数组中添加一个"flume"元素
        arr += "flume"
        //3. 从该变长数组中删除"hadoop"元素
        arr -= "hadoop"
        //4. 将一个包含"hive", "sqoop"元素的数组, 追加到变长数组中
        arr ++= Array("hive", "sqoop")
        //5. 从该变长数组中删除"sqoop", "spark"这两个元素
        arr --= Array("sqoop", "spark")
        //6. 打印数组, 查看结果.
        println(s"arr: ${arr}")
    }
}复制代码
```

##### 1.2 遍历数组

**概述**

在Scala中, 可以使用以下两种方式来遍历数组：

1. 使用 `索引` 遍历数组中的元素
2. 使用 `for表达式` 直接遍历数组中的元素

**示例**

1. 定义一个数组，包含以下元素1,2,3,4,5
2. 通过两种遍历方式遍历数组，并打印数组中的元素

**参考代码**

```
//案例: 遍历数组
object ClassDemo04 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个数组，包含以下元素1,2,3,4,5
        val arr = Array(1, 2, 3, 4, 5)
        //2. 通过两种遍历方式遍历数组，并打印数组中的元素.
        //方式一: 遍历索引的形式实现.
        for(i <- 0 to arr.length -1) println(arr(i))
        println("-" * 15) //分割线
        for(i <- 0 until arr.length) println(arr(i))
        println("-" * 15) //分割线
        
        //方式二: 直接遍历数组元素.
        for(i <- arr) println(i)
    }
}复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20210823165604377.png)**注意:**

> 0 until n 获取0~n之间的所有整数，包含0, 不包含n。
>
> 0 to n 获取0~n之间的所有整数，包含0, 也包含n。

##### 1.3 数组常用算法

**概述**

Scala中的数组封装了一些常用的计算操作，将来在对数据处理的时候，不需要我们自己再重新实现，而是可以直接拿来用。以下为常用的几个算法：

- sum()方法：求和
- max()方法：求最大值
- min()方法：求最小值
- sorted()方法：排序，返回一个新的数组.
- reverse()方法：反转，返回一个新的数组.

**需求**

1. 定义一个数组, 包含4, 1, 6, 5, 2, 3这些元素.
2. 在main方法中, 测试上述的常用算法.

**参考代码**

```
//案例: 数组的常用算法
object ClassDemo05 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个数组, 包含4, 1, 6, 5, 2, 3这些元素.
        val arr = Array(4, 1, 6, 5, 2, 3)
        //2. 在main方法中, 测试上述的常用算法.
        //测试sum
        println(s"sum: ${arr.sum}")
        //测试max
        println(s"max: ${arr.max}")
        //测试min
        println(s"min: ${arr.min}")
        //测试sorted
        val arr2 = arr.sorted //即: arr2的内容为:1, 2, 3, 4, 5, 6
        //测试reverse
        val arr3 = arr.sorted.reverse //即: arr3的内容为: 6, 5, 4, 3, 2, 1
        //3. 打印数组.
        for(i <- arr) println(i)
        println("-" * 15)
        for(i <- arr2) println(i)
        println("-" * 15)
        for(i <- arr3) println(i)
    }
}复制代码
```

### 任务二、元组

#### **【任务目标】**

掌握元组的使用

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20210824110318276.png?fileid=3270835009206792475)

视频-2、元组

##### 2.1 元组介绍

元组一般用来存储多个不同类型的值。例如同时存储姓名、年龄、性别、出生年月这些数据，就要用到元组来存储

了。并且**元组的长度和元素都是不可变的**。

定义元组的方式有：

- 方式一：通过小括号实现

  ```
  val/var 元组 = (元素1, 元素2, 元素3....)复制代码
  ```

- 方式二：通过箭头来实现

  ```
  val/var 元组 = 元素1->元素2复制代码
  ```

  > 注意: 上述这种方式，只适用于**元组中只有两个元素**的情况

##### **2.2** 示例

**需求**

1. 定义一个元组，包含学生的姓名和年龄
2. 分别使用小括号以及箭头的方式来定义元组

```
//案例: 演示元组的定义格式
object ClassDemo06 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个元组，包含学生的姓名和年龄.
        //2. 分别使用小括号以及箭头的方式来定义元组.
        val tuple1 = ("张三", 23)
        val tuple2 = "张三" -> 23
        println(tuple1)
        println(tuple2)
    }
}复制代码
```

##### 2.3 访问元组中的元素

在Scala中, 可以通过 `元组名._编号`的形式来访问元组中的元素，`_1`表示访问第一个元素，依次类推。

也可以通过 `元组名.productIterator` 的方式，来获取该元组的迭代器，从而实现遍历元组。

**格式**

- 格式一：访问元组中的单个元组

  ```
  println(元组名._1) //打印元组的第一个元素
  println(元组名._2) //打印元组的第二个元组
  ...复制代码
  ```

- 格式二：遍历元组

  ```
  val tuple1 = (值1, 值2, 值3, 值4, 值5...) //可以有多个值
  val it = tuple1.productIterator //获取当前元组的迭代器对象
  for(i <- it) println(i) //打印元组中的所有内容复制代码
  ```

**示例**

1. 定义一个元组，包含一个学生的姓名和性别，"zhangsan", "male"
2. 分别获取该学生的姓名和性别，并将结果打印到控制台上.

**参考代码**

```
//案例: 获取元组中的元组.
object ClassDemo07 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个元组，包含一个学生的姓名和性别，"zhangsan", "male"
        val tuple1 = "zhangsan" -> "male"

        //2. 分别获取该学生的姓名和性别
        //方式一: 通过 _编号 的形式实现.
        println(s"姓名: ${tuple1._1}, 性别: ${tuple1._2}")

        //方式二: 通过迭代器遍历的方式实现.
        //获取元组对应的迭代器对象.
        val it = tuple1.productIterator

        //遍历元组.
        for(i <- it) println(i)
    }
}复制代码
```

### 任务三、集合

#### **【任务目标】**

掌握各种集合的使用

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20210824110318276.png?fileid=3270835009205608152)

视频-3、集合

##### 3.1 列表List

列表(List)是Scala中最重要的，也是最常用的一种数据结构。它存储的数据特点是: **有序，可重复**。

在Scala中，列表分为两种，即：**不可变列表**和**可变列表**

> 解释:
>
> 1. 有序的意思并不是排序，而是指元素的存入顺序和取出顺序是一致的
> 2. 可重复的意思是列表中可以添加重复元素

###### 3.1.1 不可变列表

不可变列表指的是：**列表的元素、长度都是不可变的。**

**语法**

- 格式一：通过 `小括号` 直接初始化

  ```
  val/var 变量名 = List(元素1, 元素2, 元素3...)复制代码
  ```

- 格式二：通过 `Nil `创建一个空列表

  ```
  val/var 变量名 =  Nil复制代码
  ```

- 格式三: 使用 `::` 方法实现

  ```
  val/var 变量名 = 元素1 :: 元素2 :: Nil复制代码
  ```

  > 注意: 使用**::**拼接方式来创建列表，必须在最后添加一个**Nil**

**示例**

1. 创建一个不可变列表，存放以下几个元素（1,2,3,4）
2. 使用 Nil 创建一个不可变的空列表
3. 使用 :: 方法创建列表，包含-2、-1两个元素

```
//案例: 演示不可变列表.
object ClassDemo08 {
    def main(args: Array[String]): Unit = {
        //1. 创建一个不可变列表，存放以下几个元素（1,2,3,4）
        val list1 = List(1, 2, 3, 4)
        
        //2. 使用 Nil 创建一个不可变的空列表
        val list2 = Nil
        
        //3. 使用 :: 方法创建列表，包含-2、-1两个元素
        val list3 = -2 :: -1 :: Nil
        
        //4. 打印结果.
        println(s"list1: ${list1}")
        println(s"list2: ${list2}")
        println(s"list3: ${list3}")
    }
}复制代码
```

###### 3.1.2 可变列表

可变列表指的是**列表的元素、长度都是可变的**

**语法**

- 要使用可变列表, 必须先导包

  ```
  import scala.collection.mutable.ListBuffer复制代码
  ```

  > 小技巧: 可变集合都在 mutable 包中，不可变集合都在 immutable 包中（默认导入）

- 格式一：创建空的可变列表

  ```
  val/var 变量名 = ListBuffer[数据类型]()复制代码
  ```

- 格式二：通过 小括号 直接初始化

  ```
  val/var 变量名 = ListBuffer(元素1，元素2，元素3...)复制代码
  ```

**示例**

1. 创建空的整形可变列表
2. 创建一个可变列表，包含以下元素：1,2,3,4

```
//1. 导包
import scala.collection.mutable.ListBuffer
//案例: 演示可变列表
object ClassDemo09 {
    def main(args: Array[String]): Unit = {
        //2. 创建空的整形可变列表.
        val list1 = new ListBuffer[Int]()
        
        //3. 创建一个可变列表，包含以下元素：1,2,3,4
        val list2 = ListBuffer(1, 2, 3, 4)
        println(s"list1: ${list1}")
        println(s"list2: ${list2}")
    }
}复制代码
```

**可变列表的常用操作**

关于可变列表的常见操作如下:

| **格式**          | 功能                                           |
| ----------------- | ---------------------------------------------- |
| 列表名(索引)      | 根据索引(索引从0开始), 获取列表中的指定元素    |
| 列表名(索引) = 值 | 修改元素值                                     |
| +=                | 往列表中添加单个元素                           |
| ++=               | 往列表中追加一个列表                           |
| -=                | 删除列表中的某个指定元素                       |
| --=               | 以列表的形式, 删除列表中的多个元素             |
| toList            | 将可变列表(ListBuffffer)转换为不可变列表(List) |
| toArray           | 将可变列表(ListBuffffer)转换为数组             |

**示例**

1. 定义一个可变列表包含以下元素：1,2,3
2. 获取第一个元素, 并打印结果到控制台
3. 添加一个新的元素：4
4. 追加一个列表，该列表包含以下元素：5,6,7
5. 删除元素7
6. 删除元素3, 4
7. 将可变列表转换为不可变列表
8. 将可变列表转换为数组
9. 打印结果

```
//案例: 演示可变列表的常见操作.
object ClassDemo10 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个可变列表包含以下元素：1,2,3
        val list1 = ListBuffer(1, 2, 3)
        //2. 获取第一个元素, 并打印结果到控制台.
        println(list1(0))
        //3. 添加一个新的元素：4
        list1 += 4
        //4. 追加一个列表，该列表包含以下元素：5,6,7
        list1 ++= List(5, 6, 7)
        //5. 删除元素7
        list1 -= 7
        //6. 删除元素3, 4
        list1 --= List(3, 4)
        //7. 将可变列表转换为不可变列表
        val list2 = list1.toList
        //8. 将可变列表转换为数组
        val arr = list1.toArray
        //9. 打印结果.
        println(s"list1: ${list1}")
        println(s"list2: ${list2}")
        println(s"arr: ${arr}")
    }
}复制代码
```

###### 3.1.3 列表的常用操作

在实际开发中, 我们经常要操作列表, 以下列举的是列表的常用的操作：

| 格式      | 功能                                             |
| --------- | ------------------------------------------------ |
| isEmpty   | 判断列表是否为空                                 |
| ++        | 拼接两个列表, 返回一个新的列表                   |
| head      | 获取列表的首个元素                               |
| tail      | 获取列表中除首个元素之外, 其他所有的元素         |
| reverse   | 对列表进行反转, 返回一个新的列表                 |
| take      | 获取列表中的前缀元素(具体个数可以自定义)         |
| drop      | 获取列表中的后缀元素(具体个数可以自定义)         |
| flatten   | 对列表进行扁平化操作, 返回一个新的列表           |
| zip       | 对列表进行拉链操作, 即: 将两个列表合并成一个列表 |
| unzip     | 对列表进行拉开操作, 即: 将一个列表拆解成两个列表 |
| toString  | 将列表转换成其对应的默认字符串形式               |
| mkString  | 将列表转换成其对应的指定字符串形式               |
| union     | 获取两个列表的并集元素, 并返回一个新的列表       |
| intersect | 获取两个列表的交集元素, 并返回一个新的列表       |
| diff      | 获取两个列表的差集元素, 并返回一个新的列表       |

**示例一：基础操作**

1. 定义一个列表list1，包含以下元素：1,2,3,4
2. 使用isEmpty方法判断列表是否为空, 并打印结果.
3. 再定义一个列表list2，包含以下元素: 4,5,6
4. 使用 ++ 将两个列表拼接起来, 并打印结果.
5. 使用head方法，获取列表的首个元素, 并打印结果.
6. 使用tail方法，获取列表中除首个元素之外, 其他所有的元素, 并打印结果.
7. 使用reverse方法将列表的元素反转, 并打印反转后的结果.
8. 使用take方法获取列表的前缀元素, 并打印结果.
9. 使用drop方法获取列表的后缀元素, 并打印结果.

```
//案例: 演示列表的基础操作.
object ClassDemo11 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个列表list1，包含以下元素：1,2,3,4
        val list1 = List(1, 2, 3, 4)
        //2. 使用isEmpty方法判断列表是否为空, 并打印结果.
        println(s"isEmpty: ${list1.isEmpty}")
        //3. 再定义一个列表list2，包含以下元素: 4,5,6
        val list2 = List(4, 5, 6)
        //4. 使用`++`将两个列表拼接起来, 并打印结果.
        val list3 = list1 ++ list2
        println(s"list3: ${list3}")
        //5. 使用head方法，获取列表的首个元素, 并打印结果.
        println(s"head: ${list3.head}")
        //6. 使用tail方法，获取列表中除首个元素之外, 其他所有的元素, 并打印结果.
        println(s"tail: ${list3.tail}")
        //7. 使用reverse方法将列表的元素反转, 并打印反转后的结果.
        val list4 = list3.reverse
        println(s"list4: ${list4}")
        //8. 使用take方法获取列表的前缀元素(前三个元素), 并打印结果.
        println(s"take: ${list3.take(3)}")
        //9. 使用drop方法获取列表的后缀元素(除前三个以外的元素), 并打印结果.
        println(s"drop: ${list3.drop(3)}")
    }
}复制代码
```

**示例二：扁平化(压平)**

扁平化表示将嵌套列表中的所有具体元素单独的放到一个新列表中，如下图:

![image-20230203095504962](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20230203095504962.png)

> 注意: 如果某个列表中的所有元素都是列表，那么这样的列表就称之为: 嵌套列表

**需求**

1. 定义一个列表，该列表有三个元素，分别为：List(1,2)、List(3)、List(4,5)
2. 使用flatten将这个列表转换为List(1,2,3,4,5)
3. 打印结果.

```
//案例: 演示扁平化操作.
object ClassDemo12 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个列表, 该列表有三个元素, 分别为：List(1,2)、List(3)、List(4,5)
        val list1 = List(List(1,2), List(3), List(4, 5))
        //2. 使用flatten将这个列表转换为List(1,2,3,4,5)
        val list2 = list1.flatten
        //3. 打印结果
        println(list2)
    }
}复制代码
```

**示例三：拉链与拉开**

- 拉链：将两个列表，组合成一个元素为元组的列表

  > 解释：将列表List("张三", "李四")、List(23, 24)组合成列表List((张三, 23)、(李四, 24))

- 拉开：将一个包含元组的列表，拆解成包含两个列表的元组

  > 解释：将列表List((张三,23)、(李四,24))拆解成元组(List(张三, 李四)、List(23, 24))

**需求**

1. 定义列表names, 保存三个学生的姓名，分别为：张三、李四、王五
2. 定义列表ages, 保存三个学生的年龄，分别为：23, 24, 25
3. 使用zip将列表names和ages, 组合成一个元素为元组的列表list1
4. 使用unzip将列表list1拆解成包含两个列表的元组tuple1
5. 打印结果

```
//案例: 演示拉链与拉开
object ClassDemo13 {
    def main(args: Array[String]): Unit = {
        //1. 定义列表names, 保存三个学生的姓名，分别为：张三、李四、王五
        val names = List("张三", "李四", "王五")
        //2. 定义列表ages, 保存三个学生的年龄，分别为：23, 24, 25
        val ages = List(23, 24, 25)
        //3. 使用zip将列表names和ages, 组合成一个元素为元组的列表list1.
        val list1 = names.zip(ages)
        //4. 使用unzip将列表list1拆解成包含两个列表的元组tuple1
        val tuple1 = list1.unzip
        //5. 打印结果
        println("拉链: "+ list1)
        println("拉开: " + tuple1)
    }
}复制代码
```

**示例四：列表转字符串**

将列表转换成其对应的字符串形式，可以通过 toString方法或者mkString方法 实现，其中

- toString方法：可以返回List中的所有元素
- mkString方法：可以将元素以指定分隔符拼接起来

> 注意：默认没有分隔符

**需求**

1. 定义一个列表，包含元素：1,2,3,4
2. 使用toString方法输出该列表的元素
3. 使用mkString方法, 用冒号将元素都拼接起来, 并打印结果.

```
//案例: 演示将列表转成其对应的字符串形式.
object ClassDemo14 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个列表，包含元素：1,2,3,4
        val list1 = List(1, 2, 3, 4)
        //2. 使用toString方法输出该列表的元素
        println(list1.toString)
        //简写形式, 因为: 输出语句打印对象, 默认调用了该对象的toString()方法
        println(list1)
        println("-" * 15)
        //3. 使用mkString方法, 用冒号将元素都拼接起来, 并打印结果.
        println(list1.mkString(":"))
    }
}复制代码
```

##### 3.2 Set集合

**代表没有重复元素的集合**。特点是: **唯一、无序**

Scala中的集分为两种，一种是不可变集，另一种是可变集。

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20210823165604377.png)**解释:**

> 1. `唯一` 的意思是 `Set中的元素具有唯一性, 没有重复元素`
> 2. `无序` 的意思是 `Set集中的元素, 添加顺序和取出顺序不一致`

###### 3.2.1 不可变集

不可变集指的是**元素，集的长度都不可变**

**语法**

- 格式一：创建一个空的不可变集

  ```
  val/var 变量名 = Set[类型]()复制代码
  ```

- 格式二：给定元素来创建一个不可变集

  ```
  val/var 变量名 = Set(元素1, 元素2, 元素3...)复制代码
  ```

**示例一：创建不可变集**

1. 定义一个空的整型不可变集
2. 定义一个不可变集，保存以下元素：1,1,3,2,4,8
3. 打印结果

```
//案例: 演示不可变集.
object ClassDemo16 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个空的整型不可变集.
        val set1 = Set[Int]()
        //2. 定义一个不可变集，保存以下元素：1,1,3,2,4,8.
        val set2 = Set(1, 1, 3, 2, 4, 8)
        //3. 打印结果.
        println(s"set1: ${set1}")
        println(s"set2: ${set2}")
    }
}复制代码
```

**示例二：不可变集的常见操作**

1. 获取集的大小（ size ）
2. 遍历集（ 和遍历数组一致 ）
3. 添加一个元素，生成一个新的Set（ + ）
4. 拼接两个集，生成一个新的Set（ ++ ）
5. 拼接集和列表，生成一个新的Set（ ++ ）

注意:

> 1. `-(减号)` 表示删除一个元素，生成一个新的Set
> 2. `-- `表示批量删除某个集中的元素，从而生成一个新的Set

**需求**

1. 创建一个集，包含以下元素：1,1,2,3,4,5
2. 获取集的大小, 并打印结果.
3. 遍历集，打印每个元素.
4. 删除元素1，生成新的集, 并打印.
5. 拼接另一个集Set(6, 7, 8), 生成新的集, 并打印.
6. 拼接一个列表List(6,7,8, 9), 生成新的集, 并打印.

```
//案例: 演示不可变集的常用操作.
object ClassDemo17 {
    def main(args: Array[String]): Unit = {
        //1. 创建一个集，包含以下元素：1,1,2,3,4,5
        val set1 = Set(1, 1, 2, 3, 4, 5)
        //2. 获取集的大小
        println("set1的长度为: " + set1.size)
        //3. 遍历集，打印每个元素
        println("set1集中的元素为: ")
        for(i <- set1) println(i)
        println("-" * 15)
        //4. 删除元素1，生成新的集
        val set2 = set1 - 1
        println("set2: " + set2)
        //5. 拼接另一个集（6, 7, 8)
        val set3 = set1 ++ Set(6, 7, 8)
        println("set3: " + set3)
        //6. 拼接一个列表(6,7,8, 9)
        val set4 = set1 ++ List(6, 7, 8, 9)
        println("set4: " + set4)
    }
}复制代码
```

###### 3.2.2 可变集

可变集指的是**元素，集的长度都可变**，它的创建方式和不可变集的创建方式一致，只不过需要先导入可变集类。

手动导入： import scala.collection.mutable.Set

**示例**

1. 定义一个可变集，包含以下元素: 1,2,3, 4
2. 添加元素5到可变集中
3. 添加元素6, 7, 8到可变集中
4. 从可变集中移除元素1
5. 从可变集中移除元素3, 5, 7
6. 打印结果

```
//案例: 演示可变集.
object ClassDemo18 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个可变集，包含以下元素: 1,2,3, 4
        val set1 = Set(1, 2, 3, 4)
        //2. 添加元素5到可变集中
        set1 += 5
        //3. 添加元素6, 7, 8到可变集中
        //set1 ++= Set(6, 7, 8)
        set1 ++= List(6, 7, 8) //两种写法均可.
        //4. 从可变集中移除元素1
        set1 -= 1
        //5. 从可变集中移除元素3, 5, 7
        //set1 --= Set(3, 5, 7)
        set1 --= List(3, 5, 7) //两种写法均可.
        //6. 打印结果.
        println(set1)
    }
}复制代码
```

##### 3.3 Map集合

它是由键值对(key, value)组成的集合。特点是: **键具有唯一性，但是值可以重复**， 在Scala中，Map也分为不可变Map和可变Map。

> 注意：如果添加重复元素(即: 两组元素的键相同)，则` 会用新值覆盖旧值`

###### 3.3.1 不可变Map

不可变Map指的是**元素、长度都不可变**。

- 方式一：通过 `箭头` 的方式实现

  ```
  val/var map = Map(键->值, 键->值, 键->值...) // 推荐，可读性更好复制代码
  ```

- 方式二：通过 `小括号` 的方式实现

  ```
  val/var map = Map((键, 值), (键, 值), (键, 值), (键, 值)...)复制代码
  ```

**需求**

1. 定义一个映射，包含以下学生姓名和年龄数据：张三 -> 23，李四 -> 24，李四 -> 40
2. 打印结果.

```
//案例: 演示不可变Map
object ClassDemo19 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个映射，包含以下学生姓名和年龄数据.
        val map1 = Map("张三" -> 23, "李四" -> 24, "李四" -> 40)
        val map2 = Map(("张三", 23),("李四", 24), ("李四" -> 40))
        //2. 打印结果.
        println(s"map1: ${map1}")
        println(s"map2: ${map2}")
    }
}复制代码
```

###### 3.3.2 可变Map

可变Map指的是**元素、长度都可变**。定义语法与不可变Map一致, 只不过需要先手动导包:

```
import scala.collection.mutable.Map复制代码
```

**需求**

1. 定义一个映射，包含以下学生姓名和年龄数据: 张三 -> 23, 李四 -> 24
2. 修改张三的年龄为30
3. 打印结果

```
import scala.collection.mutable.Map
//案例: 演示可变Map.
object ClassDemo20 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个映射，包含以下学生姓名和年龄数据.
        val map1 = Map("张三" -> 23, "李四" -> 24)
        val map2 = Map(("张三", 23),("李四", 24))
        //2. 修改张三的年龄为30
        map1("张三") = 30
        //3. 打印结果
        println(s"map1: ${map1}")
        println(s"map2: ${map2}")
    }
}复制代码
```

###### 3.3.3 Map基本操作

1. `map(key) `: 根据键获取其对应的值，键不存在返回None

2. `map.keys` : 获取所有的键

3. `map.values` : 获取所有的值

4. 遍历map集合: 可以通过普通for实现

5. `getOrElse`: 根据键获取其对应的值, 如果键不存在, 则返回指定的默认值

6. `+号` : 增加键值对, 并生成一个新的Map

   > 注意: 如果是可变Map, 则可以通过 +=或者++= 直接往该可变Map中添加键值对元素

7. `-号` : 根据键删除其对应的键值对元素, 并生成一个新的Map

   > 注意: 如果是可变Map, 则可以通过 -=或者--= 直接从该可变Map中删除键值对元素

**示例**

1. 定义一个映射，包含以下学生姓名和年龄数据: 张三 -> 23, 李四 -> 24
2. 获取张三的年龄, 并打印.
3. 获取所有的学生姓名, 并打印.
4. 获取所有的学生年龄, 并打印.
5. 打印所有的学生姓名和年龄.
6. 获取 王五 的年龄，如果 王五 不存在，则返回-1, 并打印.
7. 新增一个学生：王五, 25, 并打印结果.
8. 将 李四 从可变映射中移除, 并打印.

```
import scala.collection.mutable.Map
//案例: 演示Map的常见操作.

object ClassDemo21 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个映射，包含以下学生姓名和年龄数据: 张三 -> 23, 李四 -> 24
        val map1 = Map("张三" -> 23, "李四" -> 24)
        //2. 获取张三的年龄, 并打印.
        println(map1.get("张三"))
        //3. 获取所有的学生姓名, 并打印.
        println(map1.keys)
        //4. 获取所有的学生年龄, 并打印.
        println(map1.values)
        //5. 打印所有的学生姓名和年龄.
        for((k, v) <- map1) println(s"键:${k}, 值:${v}")
        println("-" * 15)
        //6. 获取`王五`的年龄，如果`王五`不存在，则返回-1, 并打印.
        println(map1.getOrElse("王五", -1))
        println("-" * 15)
        //7. 新增一个学生：王五, 25, 并打印结果.
        /*//不可变Map
        val map2 = map1 + ("王五" -> 25)
        println(s"map1: ${map1}")
        println(s"map2: ${map2}")*/
        map1 += ("王五" -> 25)
        //8. 将`李四`从可变映射中移除, 并打印.
        map1 -= "李四"
        println(s"map1: ${map1}")
    }
}复制代码
```

### 任务四、集合高阶函数

#### **【任务目标】**

前面任务中将各种数据结构做了详细介绍，在使用集合时还涉及到更多高阶用法，这里主要就是介绍一些高阶的函数的使用，这些用法我们也可以称为函数式编程。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20210824110318276.png?fileid=3270835009206501369)

视频-4、集合高阶函数

##### 4.1 函数式编程

函数式编程指定就是`方法的参数列表可以接收函数对象`，例如：`add(10, 20)`就不是函数式编程，而 `add(函数对象)` 这种格式就叫函数式编程。我们将来编写Spark/Flink的大量业务代码时，都会使用到函数式编程。那么这里我们主要就是介绍关于集合操作过程中的一些函数对象：

| 函数名   | 功能                           |
| -------- | ------------------------------ |
| foreach  | 用来遍历集合的                 |
| map      | 用来对集合进行转换的           |
| flatmap  | 用来对集合进行映射扁平化操作   |
| filter   | 用来过滤出指定的元素           |
| sorted   | 用来对集合元素进行默认排序     |
| sortBy   | 用来对集合按照指定字段排序     |
| sortWith | 用来对集合进行自定义排序       |
| groupBy  | 用来对集合元素按照指定条件分组 |
| reduce   | 用来对集合元素进行聚合计算     |
| fold     | 用来对集合元素进行折叠计算     |

##### 4.2 示例一：遍历(foreach)

采用 `foreach` 来遍历集合，可以让代码看起来更简洁，更优雅

**格式**

```
def foreach(f:(A) => Unit): Unit

//简写形式
def foreach(函数)复制代码
```

**执行过程**

![image-20230203105233981](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20230203105233981.png)

**需求：**有一个列表，包含以下元素1,2,3,4，请使用foreach方法遍历打印每个元素

```
//案例: 演示foreach函数
object ClassDemo23 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个列表, 包含1, 2, 3, 4
        val list1 = List(1, 2, 3, 4)
        //2. 通过foreach函数遍历上述的列表.
        //x:表示集合中的每个元素 函数体表示输出集合中的每个元素.
        list1.foreach((x:Int) => println(x))
    }
}复制代码
```

##### 4.3 示例二：简化函数定义

上述案例函数定义有点啰嗦，我们有更简洁的写法。可以通过如下两种方式来简化函数定义:

- 方式一: 通过 `类型推断` 来简化函数定义.

  > 解释:
  >
  > 因为使用foreach来迭代列表，而列表中的每个元素类型是确定的，所以我们可以通过 `类型推断`让Scala程序来自动推断出来集合中每个元素参数的类型, 即: 在我们创建函数时,可以省略其参数列表的类型.

- 方式二: 通过 `下划线` 来简化函数定义.

  > 解释:
  >
  > 当函数参数，只在函数体中出现一次，而且函数体没有嵌套调用时，可以使用下划线来简化函数定义

**示例**

1. 有一个列表，包含元素1,2,3,4，请使用foreach方法遍历打印每个元素.
2. 使用类型推断来简化函数定义.
3. 使用下划线来简化函数定义

```
//案例: 演示简化函数定义.
object ClassDemo24 {
    def main(args: Array[String]): Unit = {
        //1. 有一个列表，包含元素1,2,3,4，请使用foreach方法遍历打印每个元素.
        val list1 = List(1, 2, 3, 4)
        list1.foreach((x:Int) => println(x))
        println("-" * 15)
        
        //2. 使用类型推断来简化函数定义.
        list1.foreach(x => println(x))
        println("-" * 15)
        
        //3. 使用下划线来简化函数定义
        list1.foreach(println(_))
    }
}复制代码
```

##### 4.4 示例三：映射(Map)

集合的映射操作是指`将一种数据类型转换为另外一种数据类型的过程` , 它是在进行数据计算的时候, 甚至将来在编写

Spark/Flink程序时用得最多的操作。

> 例如: 把List[Int]转换成List[String]

**格式**

```
def map[B](f: (A) ⇒ B): TraversableOnce[B]

//简写形式:
def map(函数对象)复制代码
```

**执行过程**

![image-20230203111436712](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20230203111436712.png)

**需求**

1. 创建一个列表，包含元素1,2,3,4
2. 将上述的数字转换成对应个数的 `* `, 即: 1变为`*`, 2变为`**`, 以此类推

```
//案例: 演示map函数(映射)
object ClassDemo25 {
    def main(args: Array[String]): Unit = {
        //1. 创建一个列表，包含元素1,2,3,4
        val list1 = List(1, 2, 3, 4)
        //2. 将上述的数字转换成对应个数的`*`, 即: 1变为*, 2变为**, 以此类推.
        //方式一: 普通写法
        val list2 = list1.map((x:Int) => "*" * x)
        println(s"list2: ${list2}")
        
        //方式二: 通过类型推断实现.
        val list3 = list1.map(x => "*" * x)
        println(s"list3: ${list3}")
        
        //方式三: 通过下划线实现.
        val list4 = list1.map("*" * _)
        println(s"list4: ${list4}")
    }
}复制代码
```

##### 4.5 示例四： 扁平化映射(flatMap)

扁平化映射可以理解为**先map，然后再flatten**, 它也是将来用得非常多的操作，也是必须要掌握的, 如图:

![image-20230203111718949](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20230203111718949.png)

> 解释:
>
> 1. map是将列表中的**元素转换为一个List**
> 2. flatten再将整个列表进行扁平化

**格式：**

```
def flatMap[B](f:(A) => GenTraversableOnce[B]): TraversableOnce[B]
//简写形式:
def flatMap(f:(A) => 要将元素A转换成的集合B的列表)复制代码
```

**需求**

1. 有一个包含了若干个文本行的列表："hadoop hive spark flink flume", "kudu hbase sqoop storm"
2. 获取到文本行中的每一个单词，并将每一个单词都放到列表中

**思路分析**

![image-20230203112822258](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20230203112822258.png)

```
//案例: 演示映射扁平化(flatMap)
object ClassDemo26 {
    def main(args: Array[String]): Unit = {
        //1. 有一个包含了若干个文本行的列表："hadoop hive spark flink flume", "kudu hbase sqoop storm"
        val list1 = List("hadoop hive spark flink flume", "kudu hbase sqoop storm")
        //2. 获取到文本行中的每一个单词，并将每一个单词都放到列表中.
        //方式一: 通过map, flatten实现.
        val list2 = list1.map(_.split(" "))
        val list3 = list2.flatten
        println(s"list3: ${list3}")

        //方式二: 通过flatMap实现.
        val list4 = list1.flatMap(_.split(" "))
        println(s"list4: ${list4}")
    }
}复制代码
```

##### 4.6 示例五：过滤(filter)

过滤指的是`过滤出(筛选出)`符合一定条件的元素

**格式：**

```
def filter(f:(A) => Boolean): TraversableOnce[A]

//简写形式:
def filter(f:(A) => 筛选条件)复制代码
```

**执行过程**

![image-20230203113226885](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20230203113226885.png)

**案例**

1. 有一个数字列表，元素为：1,2,3,4,5,6,7,8,9
2. 请过滤出所有的偶数

```
//案例: 演示过滤(filter)
object ClassDemo27 {
    def main(args: Array[String]): Unit = {
        //1. 有一个数字列表，元素为：1,2,3,4,5,6,7,8,9
        val list1 = (1 to 9).toList
        //2. 请过滤出所有的偶数
        val list2 = list1.filter(_ % 2 == 0)
        println(s"list2: ${list2}")
    }
}复制代码
```

##### 4.7 示例六：排序

在scala集合中，可以使用以下三种方式来进行排序:

| 函数名   | 功能                       |
| -------- | -------------------------- |
| sorted   | 用来对集合元素进行默认排序 |
| sortBy   | 用来对集合按照指定字段排序 |
| sortWith | 用来对集合进行自定义排序   |

###### 4.7.1 默认排序

所谓的默认排序指的是 `对列表元素按照升序进行排列` . 如果需要降序排列, 则升序后, 再通过 reverse 实现.

**需求**

1. 定义一个列表，包含以下元素: 3, 1, 2, 9, 7
2. 对列表进行升序排序
3. 对列表进行降序排列

```
//案例: 演示默认排序(sorted)
object ClassDemo28 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个列表，包含以下元素: 3, 1, 2, 9, 7
        val list1 = List(3, 1, 2, 9, 7)
        //2. 对列表进行升序排序
        val list2 = list1.sorted
        println(s"list2: ${list2}")
        //3. 对列表进行降序排列.
        val list3 = list2.reverse
        println(s"list3: ${list3}")
    }
}复制代码
```

###### 4.7.2 指定字段排序(sortBy)

所谓的指定字段排序是指 `对列表元素根据传入的函数转换后，再进行排序 `

> 例如：根据列表List("01 hadoop", "02 flume")的字母进行排序

**示例**

1. 有一个列表，分别包含几下文本行："01 hadoop", "02 flume", "03 hive", "04 spark"
2. 请按照单词字母进行排序

```
//案例: 演示根据指定字段排序(sortBy)
object ClassDemo29 {
    def main(args: Array[String]): Unit = {
        //1. 有一个列表，分别包含几下文本行："01 hadoop", "02 flume", "03 hive", "04 spark"
        val list1 = List("01 hadoop", "02 flume", "03 hive", "04 spark")
        //2. 请按照单词字母进行排序
        //val list2 = list1.sortBy(x => x.split(" ")(1))
        //简写形式:
        val list2 = list1.sortBy(_.split(" ")(1))
        println(s"list2: ${list2}")
    }
}复制代码
```

###### 4.7.3 自定义排序(sortWith)

所谓的自定义排序指的是 `根据一个自定义的函数(规则)来进行排序`

**示例**

1. 有一个列表，包含以下元素：2,3,1,6,4,5
2. 使用sortWith对列表进行降序排序

```
//案例: 演示自定义排序(sortWith)
object ClassDemo30 {
    def main(args: Array[String]): Unit = {
        //1. 有一个列表，包含以下元素：2,3,1,6,4,5
        val list1 = List(2,3,1,6,4,5)
        //2. 使用sortWith对列表进行降序排序
        //val list2 = list1.sortWith((x, y)=> x > y) //降序
        //简写形式:
        val list2 = list1.sortWith(_ > _) //降序
        println(s"list2: ${list2}")
    }
}复制代码
```

##### 4.8 示例七：分组(groupBy)

分组指的是 `将数据按照指定条件进行分组` , 从而方便我们对数据进行统计分析

**格式**

```
def groupBy[K](f:(A) => K): Map[K, List[A]]
//简写形式:
def groupBy(f:(A) => 具体的分组代码)复制代码
```

**执行过程**

![image-20230203114044902](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20230203114044902.png)

**需求**

1. 有一个列表，包含了学生的姓名和性别: "刘德华" -> "男", "刘亦菲" -> "女", "胡歌" -> "男"
2. 请按照性别进行分组
3. 统计不同性别的学生人数

```
//案例: 演示分组函数(groupBy)
object ClassDemo31 {
    def main(args: Array[String]): Unit = {
        //1. 有一个列表，包含了学生的姓名和性别: "刘德华" -> "男", "刘亦菲" -> "女", "胡歌" -> "男"
        val list1 = List("刘德华" -> "男", "刘亦菲" -> "女", "胡歌" -> "男")
        //2. 请按照性别进行分组.
        //val list2 = list1.groupBy(x => x._2)
        //简写形式
        val list2 = list1.groupBy(_._2)
        //println(s"list2: ${list2}")
        //3. 统计不同性别的学生人数.
        val list3 = list2.map(x => x._1 -> x._2.size)
        println(s"list3: ${list3}")
    }
}复制代码
```

##### 4.9 示例八：聚合

所谓的聚合操作指的是`将一个列表中的数据合并为一个` 。这种操作经常用来统计分析中，常用的聚合操作主要有两个：

- reduce: 用来对集合元素进行聚合计算
- fold: 用来对集合元素进行折叠计算

###### 4.9.1 聚合(reduce)

reduce表示将列表传入一个函数进行聚合计算

**格式：**

```
def reduce[A1 >: A](op:(A1, A1) ⇒ A1): A1
//简写形式:
def reduce(op:(A1, A1) ⇒ A1)复制代码
```

**执行过程**

![image-20230203114542397](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20230203114542397.png)

> 注意:
>
> - reduce和reduceLeft效果一致，表示从左到右计算
> - reduceRight表示从右到左计算

**需求**

1. 定义一个列表，包含以下元素：1,2,3,4,5,6,7,8,9,10
2. 使用reduce计算所有元素的和

```
object ClassDemo32 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个列表，包含以下元素：1,2,3,4,5,6,7,8,9,10
        val list1 = (1 to 10).toList
        //2. 使用reduce计算所有元素的和
        //val list2 = list1.reduce((x, y) => x + y)
        //简写形式:
        val list2 = list1.reduce(_ + _)
        val list3 = list1.reduceLeft(_ + _)
        val list4 = list1.reduceRight(_ + _)
        println(s"list2: ${list2}")
        println(s"list3: ${list3}")
        println(s"list4: ${list4}")
    }
}复制代码
```

###### 4.9.2 折叠(fold)

fold与reduce很像，只不过多了一个指定初始值参数.

**格式**

```
def fold[A1 >: A](z: A1)(op:(A1, A1) => A1): A1
//简写形式:
def fold(初始值)(op:(A1, A1) => A1)复制代码
```

> 注意:
>
> - fold和foldLet效果一致，表示从左往右计算
> - foldRight表示从右往左计算

**需求**

1. 定义一个列表，包含以下元素：1,2,3,4,5,6,7,8,9,10
2. 假设初始化值是100, 使用fold方法计算所有元素的和.

```
//案例: 演示折叠计算(fold)
object ClassDemo33 {
    def main(args: Array[String]): Unit = {
        //1. 定义一个列表，包含以下元素：1,2,3,4,5,6,7,8,9,10
        val list1 = (1 to 10).toList
        //2. 假设初始化值是100, 使用fold计算所有元素的和
        //val list2 = list1.fold(100)((x, y) => x + y)
        //简写形式:
        val list2 = list1.fold(100)(_ + _)
        val list3 = list1.foldLeft(100)(_ + _)
        val list4 = list1.foldRight(100)(_ + _)
        println(s"list2: ${list2}")
        println(s"list3: ${list3}")
        println(s"list4: ${list4}")
    }
}复制代码
```

##### 4.10 综合案例

单词计数：将集合中出现的相同的单词，进行计数，取计数排名前三的结果

![image-20230203115545146](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_1/image-20230203115545146.png)

```
object TestWordCount {
  def main(args: Array[String]): Unit = {
    // 单词计数：将集合中出现的相同的单词，进行计数，取计数排名前三的结果
    val stringList = List("Hello Scala Hbase kafka", "Hello Scala Hbase", "Hello Scala", "Hello")
    // 1) 将每一个字符串转换成一个一个单词
    val wordList: List[String] =
      stringList.flatMap(str => str.split(" "))
    //println(wordList)
    // 2) 将相同的单词放置在一起
    val wordToWordsMap: Map[String, List[String]] = wordList.groupBy(word => word)
    //println(wordToWordsMap)
    // 3) 对相同的单词进行计数
    // (word, list) => (word, count)
    val wordToCountMap: Map[String, Int] = wordToWordsMap.map(tuple => (tuple._1, tuple._2.size))
    // 4) 对计数完成后的结果进行排序（降序）
    val sortList: List[(String, Int)] = wordToCountMap.toList.sortWith {
      (left, right) => {
        left._2 > right._2
      }
    }
    // 5) 对排序后的结果取前 3 名
    val resultList: List[(String, Int)] = sortList.take(3)
    println(resultList)
  }
}复制代码
```





# 实验5-2：砥砺前行之扩展篇

## 实验概述

在Scala编程过程中还会经常涉及到一些模式匹配、Options和异常等相关的内容，这些应用也非常广泛，这些是我们Scala脚步砥砺前行的拓展内容。

## 实验环境

- AtStudy 实训平台
- Scala2

## 实验流程

![image.png](https://cdn.atstudy.com/lab/manual/1676006716584367.png)

## 实验目标

学习完成本实验后，您将能够

- 掌握模式匹配相关内容
- 掌握option类型及偏函数的用法
- 掌握异常处理的用法

## 实验任务

### 任务一、模式匹配

#### **【任务目标】**

掌握模式匹配机制

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_2/image-20210824110318276.png?fileid=3270835009206816726)

视频-1、模式匹配

##### 1.1 模式匹配基本用法

Scala中有一个非常强大的模式匹配机制，应用也非常广泛， 例如:

- 判断固定值
- 类型查询
- 快速获取数据

类似于 Java 中的 switch 语法

```
int i = 10
switch (i) {
    case 10 :
        System.out.println("10");
        	break;
    case 20 : 
        System.out.println("20");
        break;
    default : 
        System.out.println("other number");
        break;
}复制代码
```

**基本语法**

```
变量 match {
    case "常量1" => 表达式1
    case "常量2" => 表达式2
    case "常量3" => 表达式3
    case _ => 表达式4 // 默认匹配项
}复制代码
```

模式匹配语法中，采用 match 关键字声明，每个分支采用 case 关键字进行声明，当需要匹配时，会从第一个 case 分支开始，如果匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下一个分支进行判断。如果所有 case 都不匹配，那么会执行 case _分支，类似于 Java 中 default 语句。

**示例：**

1. 提示用户录入一个单词并接收.
2. 判断该单词是否能够匹配以下单词，如果能匹配，返回一句话
3. 打印结果.

| 单词      | 返回                       |
| --------- | -------------------------- |
| hadoop    | 大数据分布式存储和计算框架 |
| zookeeper | 大数据分布式协调服务框架   |
| spark     | 大数据分布式内存计算框架   |
| 未匹配    | 未匹配                     |

```
import scala.io.StdIn
//案例: 模式匹配之简单匹配
object ClassDemo01 {
    def main(args: Array[String]): Unit = {
        //1. 提示用户录入字符串并接收.
        println("请录入一个字符串: ")
        var str = StdIn.readLine()
        //2. 判断字符串是否是指定的内容, 并接收结果.
        val result = str match {
            case "hadoop" => "大数据分布式存储和计算框架"
            case "zookeeper" => "大数据分布式协调服务框架"
            case "spark" => "大数据分布式内存计算框架"
            case _ => "未匹配"
        }
        //3. 打印结果.
        println(result)
        println("-" * 15) //分割线.
        //简写形式
        str match {
            case "hadoop" => println("大数据分布式存储和计算框架")
            case "zookeeper" => println("大数据分布式协调服务框架")
            case "spark" => println("大数据分布式内存计算框架")
            case _ => println("未匹配")
        }
    }
}复制代码
```

![img](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_2/image-20210823165604377.png)**注意：**

> （1）如果所有 case 都不匹配，那么会执行 case _ 分支，类似于 Java 中 default 语句，若此时没有 case _ 分支，那么会抛出 MatchError。
>
> （2）每个 case 中，不需要使用 break 语句，自动中断 case。
>
> （3）match case 语句可以匹配任何类型，而不只是字面量。
>
> （4）=> 后面的代码块，直到下一个 case 语句之前的代码是**作为一个整体执行**，可以使用{}括起来，也可以不括。

##### 1.2 模式守卫

所谓的模式守卫指的是 `在case语句中添加if条件判断` , 这样可以让我们的代码更简洁, 更优雅.

**语法：**

```
变量 match {
    case 变量名 if条件1 => 表达式1
    case 变量名 if条件2 => 表达式2
    case 变量名 if条件3 => 表达式3
    ...
    case _ => 表达式4
}复制代码
```

**示例：**

1. 从控制台读入一个数字a（使用StdIn.readInt）
2. 如果 a >= 0 而且 a <= 3，打印[0-3]
3. 如果 a >= 4 而且 a <= 8，打印[4,8]
4. 否则，打印未匹配

```
//案例: 模式匹配之守卫
object ClassDemo02 {
    def main(args: Array[String]): Unit = {
        //1. 从控制台读入一个数字a（使用StdIn.readInt）
        println("请录入一个整数: ")
        var num = StdIn.readInt()
        //2. 模式匹配
        num match {
            //2.1 如果 a >= 0 而且 a <= 3，打印[0-3]
            case a if a >= 0 && a <= 3 => println("[0-3]")
            //2.2 如果 a >= 4 而且 a <= 8，打印[4,8]
            case a if a >= 4 && a <= 8 => println("[4-8]")
            //2.3 否则，打印未匹配
            case _ => println("未匹配")
        }
    }
}复制代码
```

##### 1.3 变量声明的模式匹配

在定义变量时，可以使用模式匹配快速获取数据. 例如: `快速从数组,列表中获取数据`

**需求**

1. 生成包含0-10数字的数组，使用模式匹配分别获取第二个、第三个、第四个元素
2. 生成包含0-10数字的列表，使用模式匹配分别获取第一个、第二个元素

```
//案例: 演示变量声明中的模式匹配.
object ClassDemo03 {
    def main(args: Array[String]): Unit = {
        //1. 生成包含0-10数字的数组，使用模式匹配分别获取第二个、第三个、第四个元素
        //1.1 生成包含0-10数字的数组
        val arr = (0 to 10).toArray
        //1.2 使用模式匹配分别获取第二个、第三个、第四个元素
        val Array(_, x, y, z, _*) = arr;
        //1.3 打印结果.
        println(x, y, z)
        println("-" * 15)
        
        //2. 生成包含0-10数字的列表，使用模式匹配分别获取第一个、第二个元素
        //2.1 生成包含0-10数字的列表，
        val list = (0 to 10).toList
        
        //2.2 使用模式匹配分别获取第一个、第二个元素
        //思路一: List() 实现
        val List(a, b, _*) = list
        
        //思路二: ::, tail 实现.
        val c :: d :: tail = list
        //2.3 打印结果.
        println(a, b)
        println(c, d)
    }
}复制代码
```

##### 1.4 匹配for表达式

Scala中还可以使用模式匹配来匹配for表达式，从而实现快速获取指定数据，让我们的代码看起来更简洁，更优雅

**需求**

1. 定义变量记录学生的姓名和年龄, 例如: "张三" -> 23, "李四" -> 24, "王五" -> 23, "赵六" -> 26
2. 获取所有年龄为23的学生信息, 并打印结果.

```
//案例: 模式匹配之匹配for表达式
object ClassDemo04 {
    def main(args: Array[String]): Unit = {
        //1. 定义变量记录学生的姓名和年龄.
        val map1 = Map("张三" -> 23, "李四" -> 24, "王五" -> 23, "赵六" -> 26)
        
        //2. 获取所有年龄为23的学生信息.
        //2.1 格式一: 通过if语句实现.
        for((k,v) <- map1 if v == 23) println(s"${k} = ${v}")
        //分割线.
        println("-" * 15)
        //2.2 格式二: 通过固定值实现.
        for((k, 23) <- map1) println(k + " = 23")
    }
}复制代码
```

### 任务二、Option类型

#### **【任务目标】**

Option类型可以有效的避免空指针问题，在实际中用途非常大。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_2/image-20210824110318276.png?fileid=3270835009206546142)

视频-2、Option类型

##### 2.1 概述

实际开发中，在返回一些数据时，难免会遇到空指针异常(`NullPointerException`)， 遇到一次就处理一次相对来讲还是比较繁琐的。在Scala中, 我们返回某些数据时，可以返回一个Option类型的对象来封装具体的数据，从而实现有效的避免空指针异常。

##### 2.2 格式

Scala中，Option类型表示可选值。这种类型的数据有两种形式：

- Some(x)：表示实际值

  ```
  final case class Some[+A](x: A) extends Option[A] {
    def isEmpty: Boolean = false
    def get: A = x
  }复制代码
  ```

- None：表示没有值

  ```
  case object None extends Option[Nothing]{
      def isEmpty:Boolean = true
      def get:Nothing = throw new NoSuchElementException("None.get")
  }复制代码
  ```

  > 注意：使用getOrElse方法，当值为None时可以指定一个默认值。

##### 2.3 案例

**需求**

1. 定义一个两个数相除的方法，使用Option类型来封装结果

2. 打印结果

   > - 不是除零，打印结果
   > - 除零, 则打印异常错误

```
//案例: 演示Option类型
object ClassDemo05 {
    //1. 定义一个两个数相除的方法，使用Option类型来封装结果
    def div(a:Int, b:Int) = {
        if (b == 0) {
            None //除数为0, 没有结果.
        } else {
            Some(a / b) //除数不为0, 返回具体的结果.
        }
    }
    def main(args: Array[String]): Unit = {
        //2. 然后使用模式匹配来打印结果
        val result = div(10 , 0)
        //思路一: 通过模式匹配来打印结果.
        result match {
            //不是除零，打印结果
            case Some(x) => println(x)
            //除零打印异常错误
            case None => println("除数不能为0")
        }
        println("-" * 15)
        //思路二: 采用getOrElse()方法实现.
        println(result.getOrElse(0))
    }
}复制代码
```

### 任务三、异常

#### **【任务目标】**

掌握异常的基本使用。

#### **【任务步骤】**

**视频讲解：**

![image-20210824110318276](https://atstudy-1253850831.cos.ap-shanghai.myqcloud.com/lab-d3/etl-bigdata/05_scala/lab5_2/image-20210824110318276.png?fileid=3270835009207625536)

视频-3、异常

##### 3.1 概述

来看看下面这一段代码:

```
def main(args: Array[String]): Unit = {
    val i = 10 / 0
    println("你好！")
}

Exception in thread "main" java.lang.ArithmeticException: / by zero
at ForDemo$.main(ForDemo.scala:3)
at ForDemo.main(ForDemo.scala)复制代码
```

执行程序，可以看到scala抛出了异常，而且没有打印出来"你好! "。说明程序出现错误后就终止了。

那怎么解决该问题呢？

在Scala中，可以使用异常处理来解决这个问题. 而异常处理又分为两种方式:

- 方式一: 捕获异常

  > 注意: 该方式处理完异常后, 程序会继续执行

- 方式二: 抛出异常

  > 注意: 该方式处理完异常后, 程序会终止执行.

##### 3.2 捕获异常

**格式**

```
try {
    //可能会出现问题的代码
}
catch{
    case ex:异常类型1 => //代码
    case ex:异常类型2 => //代码
}
finally {
    //代码
}复制代码
```

> 解释:
>
> 1. try中的代码是我们编写的业务处理代码.
> 2. 在catch中表示当出现某个异常时，需要执行的代码.
> 3. 在finally中，写的是不管是否出现异常都会执行的代码.

##### 3.3 抛出异常

我们也可以在一个方法中，抛出异常。格式如下:

**格式**

```
throw new Exception("这里写异常的描述信息")复制代码
```

##### 3.4 案例

1. 通过try...catch来处理 除数为零异常.
2. 在main方法中抛出一个异常.

```
//案例: 演示异常处理.
object ClassDemo16 {
    def main(args: Array[String]): Unit = {
        //1. 通过try.catch来处理 除数为零异常.
        try {
            //可能出问题的代码
            val i = 10 / 0
        } catch {
            //出现问题后的解决方案.
            //case ex:Exception => println("代码出问题了!")
            case ex:Exception => ex.printStackTrace()
        }
        println("你好！")
        println("-" * 15) //我是分割线.
        //2. 抛出一个异常对象.
        throw new Exception("我是一个Bug!")
        println("Hello, Scala!") //这行代码并不会被执行.
    }
}复制代码
```





